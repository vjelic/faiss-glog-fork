{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "55832926-9b88-31cd-b897-314138476b4d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the code. These functions are prone to various types of security vulnerabilities such as buffer overflows, format string vulnerabilities, integer overflows, etc. The specific sink `ails->ptr != MAP_FAILED` is not a prohibited C function itself, but it's related to the use of `mmap` function which can lead to vulnerabilities if not used properly.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. If you must use them, ensure that you handle all possible error conditions. Always validate and sanitize input data. Use secure alternatives to these functions whenever possible.\n\n## Source Code Fix Recommendation\n\nThe `mmap` function is used to map files or devices into memory. It can return `MAP_FAILED` in case of an error. The correct way to use it is to always check the return value against `MAP_FAILED` before using the returned pointer.\n\n```cpp\nvoid* ptr = mmap(...);\nif (ptr == MAP_FAILED) {\n    // handle error\n} else {\n    // use ptr\n}\n```\n\n## Library Dependencies\n\nThe `mmap` function is part of the POSIX library. To use it, you need to include the `sys/mman.h` header file.\n\n```cpp\n#include <sys/mman.h>\n```\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "829d1dd4-e357-3254-a241-891b8e5a8158",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. In the provided code snippet, the function `strerror(errno)` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `strerror(errno)`, a safer alternative would be `strerror_r(errno, buf, buflen)`, which is thread-safe.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nchar buf[1024];\nFAISS_THROW_IF_NOT_FMT(ret == 0, \"fstat failed: %s\", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<errno.h>`: for `errno`\n- `<string.h>`: for `strerror_r(errno)`\n- `<sys/stat.h>`: for `fstat`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that all the provided links are active and accessible by anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1d886a41-cf71-3977-abb2-58039de5f671",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of potentially unsafe C standard library functions which can lead to various security issues such as buffer overflows, format string vulnerabilities, and others. In the provided code snippet, the `printf` function is used, which can lead to format string vulnerabilities if the format string contains user-supplied data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `printf`, consider using `fprintf` or `snprintf` which are safer as they allow to specify the maximum number of characters to be written to the output buffer, thus preventing buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"IO_FLAG_ONDISK_SAME_DIR: updating ondisk filename from %s to %s\\n\", od->filename.c_str(), filename.c_str());\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for `snprintf` and `puts` functions.\n- `<string>` for `std::string` and its `c_str` method.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bd247ac0-9838-3c52-b1d8-36a7df58ed5d",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior when using memory copy functions like memcpy. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null, which further increases the risk. The destination is not likely to be null, but the overlap and null source risks are sufficient to make this a high-confidence issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. For example, change the code to:\n\n```cpp\nmemmove(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n```\n\nAdditionally, ensure that `ids_in` is not null before calling the function to avoid null pointer dereference:\n\n```cpp\nif (ids_in != nullptr) {\n    memmove(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "11784b33-ea2d-3411-b7a4-9b55e3fb520c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory areas, as indicated by the dataflow analysis. Additionally, there is a possibility that either the source or destination pointer could be null, and there are no explicit checks or guards in place to prevent this. The operation does not use a count value derived from the destination's capacity, and there is no evidence of explicit null-termination or bounds checking. These factors together indicate a high risk of undefined behavior and potential memory corruption.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. Additionally, ensure that both the source and destination pointers are not null before performing the operation. For example:\n\n```cpp\nif (new_lists.data() != nullptr && &lists[l0] != nullptr) {\n    memmove(new_lists.data(), &lists[l0], (l1 - l0) * sizeof(List));\n}\n```\nThis change ensures that the copy is safe even if the source and destination regions overlap, and avoids dereferencing null pointers.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8c89d273-2481-32bb-836a-44ffb7f16096",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent the source from being null, which further increases the risk. The destination is not likely to be null, but the source may be. The operation does not use a standard size or length check, and the count is calculated from variables whose safety is not guaranteed. These factors together indicate a real risk of undefined behavior, which can lead to security vulnerabilities or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that the source pointer is not null before performing the copy operation.\n\nExample remediation:\n\n```cpp\nif (code != nullptr) {\n    memmove(&codes[list_no][o * code_size], code, n_block * block_size);\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds a null check for the source pointer. This ensures that the operation is safe even if the source and destination overlap, and avoids undefined behavior if the source is null.\n\n## References\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "146d6b8d-9500-30e4-acbf-b793742fe9fc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This can cause unpredictable program behavior, data corruption, or crashes. Additionally, the analysis could not rule out the possibility that the source pointer is null, which further increases the risk. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the source and destination do not overlap. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original memory copy operation with `memmove`:\n\n```cpp\nmemmove(ptr + new_l.offset + new_l.capacity * code_size, get_ids(list_no), n * sizeof(idx_t));\n```\n\nThis change ensures that the copy will be performed correctly even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9fdb8f84-49f3-3364-9160-2e20b247a0f9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This is a well-known source of undefined behavior in C/C++ when using functions like memcpy. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null, which further increases the risk of undefined behavior. The verdict is supported by the classification and the high-confidence 'GENUINE' label from the analysis.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that is safe for overlapping regions, such as `memmove`. This function is designed to handle overlapping memory areas correctly.\n\n```cpp\nmemmove(codes + offset * code_size, codes_in, code_size * n_entry);\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the operation:\n\n```cpp\nif (codes_in != nullptr && codes != nullptr) {\n    memmove(codes + offset * code_size, codes_in, code_size * n_entry);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fd9b7f22-eff3-399a-94da-50a1c2e20523",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can potentially introduce a security risk. In the context of C++ programming, certain C library functions are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service.\n\nIn the provided code snippet, the function `fopen` is used, which is a standard C library function for opening a file. The vulnerability arises when the filename is manipulated in a way that it points to a location that the program should not have access to, leading to potential unauthorized file system access.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to use these functions in a way that their risks are minimized. In the case of `fopen`, it is important to ensure that the filename cannot be manipulated to point to an unintended location.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ofstream f;\nf.open(filename.c_str(), std::ios::out);\nif (!f.is_open()) {\n    // Handle error\n}\n```\n\nIn this fixed code, the C++ `std::ofstream` is used instead of the C `fopen` function. This provides better type safety and exception handling.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "886f4aac-e5fe-3289-a467-e133d81a4541",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. In the provided code snippet, the function `strerror` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using non-thread-safe functions or those that can lead to buffer overflows or other security issues. Instead, use safer alternatives provided by the language or third-party libraries. In the case of `strerror`, a thread-safe alternative `strerror_r` can be used.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with `strerror_r`:\n\n```cpp\nchar buf[1024];\nFAISS_THROW_IF_NOT_FMT(err == 0, \"munmap error: %s\", strerror_r(errno, buf, sizeof(buf)));\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- `cstring` for `strerror` function.\n- `cerrno` for `errno`.\n- `stdexcept` for `runtime_error`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f1869165-b929-3ebf-ab27-b2097321677a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis suggests that the destination and source may refer to overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, the source pointer may be null at this location, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. Developers should be aware that copying between overlapping memory regions using this function can lead to unpredictable results, including data corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that is safe for overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is specifically designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(ptr + new_l.offset, get_codes(list_no), n * code_size);\n```\n\nThis ensures that even if the source and destination regions overlap, the data will be copied correctly without causing undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ad1af128-cc77-3257-b9a5-1957e66c1d2f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the filename is not properly validated or controlled, potentially leading to arbitrary file read/write operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives provided by the C++ Standard Library, which includes exception handling and type safety. In this case, you can use the `fstream` class from the `<fstream>` library to open files.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `fstream` class:\n\n```cpp\n#include <fstream>\n\nstd::fstream f;\nf.open(filename.c_str(), std::fstream::in | std::fstream::out);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: This library provides facilities for file-based input and output.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "17c9bad1-4dfb-3ab8-be94-9df7f03d028d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, there is a risk that the source pointer may be null at this point, as there is no prior check ensuring it is non-null. The destination is considered safe from being null, but the overlap and null source risks make this a high-confidence, actionable issue. No explicit bounds or null-termination handling is present, and the count argument is not directly derived from the destination's capacity, increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(ids + offset, ids_in, sizeof(ids_in[0]) * n_entry);\n```\n\nAdditionally, ensure that both the source (`ids_in`) and destination (`ids + offset`) pointers are valid and not null before performing the copy. For example:\n\n```cpp\nif (ids_in != nullptr) {\n    memmove(ids + offset, ids_in, sizeof(ids_in[0]) * n_entry);\n}\n```\n\nThis change eliminates the risk of undefined behavior due to overlapping memory and null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "114fa345-18d9-309b-91c9-2db23400ed96",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination may be derived from the source, which can lead to overlapping memory regions. The use of a fixed length (16 bytes) does not mitigate this risk if the regions overlap. Additionally, the analysis could not rule out the possibility that the source pointer is null, which could also result in undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the data is copied correctly even if the regions overlap.\n\n```cpp\nmemmove(dest + (sq / 2 * nq + qi) * 32, src + (q * nsq + sq) * 16, 16);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (src != nullptr && dest != nullptr) {\n    memmove(dest + (sq / 2 * nq + qi) * 32, src + (q * nsq + sq) * 16, 16);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b0d3fda1-07f6-33a5-9e10-70ab8481fc6d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The classification explicitly states there is a risk of undefined behavior, and the verdict confirms this is a genuine issue. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, the source pointer may be null, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's capacity is not clearly defined or checked. These factors all contribute to the assessment that this is a real and potentially serious problem that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap when using memcpy. If there is any possibility of overlap, use memmove instead, which is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(dest + (sq / 2 * nq + q) * 32 + 16, src + (q * nsq + sq + 1) * 16, 16);\n```\n\nAdditionally, validate that both the source and destination pointers are not null before performing the copy, and ensure that the destination buffer is large enough to accommodate the copied data to prevent buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "730b0633-00ea-332d-881a-74012922eecc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that overlap is feasible based on data flow between the source and destination, which can cause unpredictable results with functions like memcpy that do not support overlapping regions. Additionally, the source pointer may be null at this call site, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's capacity is not clearly defined or checked. Therefore, this is a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not result in data corruption or unpredictable behavior if the source and destination regions overlap.\n\n```cpp\n// Replace memcpy with memmove for safe overlapping copy\nmemmove(dest + (sq / 2 * nq + qi) * 32 + 16, src + (q * nsq + sq + 1) * 16, 16);\n```\n\nAdditionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy operation to avoid potential crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "578c55e4-4d0f-3c8f-aefc-e39096208a50",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may reference overlapping memory, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, the source pointer may be null at this call site, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. The classification specifically highlights the undefined behavior risk, and the call verdict is marked as genuine, reinforcing the need for remediation.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. The `memmove` function is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(dest + (sq / 2 * nq + q) * 32, src + (q * nsq + sq) * 16, 16);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. For example:\n\n```cpp\nif (src != nullptr && dest != nullptr) {\n    memmove(dest + (sq / 2 * nq + q) * 32, src + (q * nsq + sq) * 16, 16);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "64180376-1b1c-3b46-a98a-a43d6eacfdcc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The source and destination pointers may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null at this point in the code, since there is no prior check ensuring it is non-null. The destination pointer is less likely to be null, but the primary concern is the undefined behavior from overlapping memory regions. The function used for copying does not handle overlapping memory safely, which can lead to unpredictable results or crashes. These factors make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory correctly. For example, change the code to:\n\n```cpp\nmemmove(centroids, x, n * sizeof(*x));\n```\n\nThis ensures that the copy operation is safe even if the source and destination regions overlap. Additionally, consider adding a check to ensure that the source pointer is not null before performing the copy to avoid null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fa6777c6-3a7b-3661-b932-8ef4d4b1aeac",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior when using memory copy functions like memcpy. Additionally, the source may be null, which further increases the risk of undefined behavior. There are no explicit guards or checks to prevent these issues, and the verdict for this call site is marked as genuine. The destination is not a pointer-based member, but the overlap and null source risks are sufficient to treat this as a real issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(&norm2, &norm_i, 4);\n```\n\nAdditionally, ensure that both source and destination pointers are valid and not null before performing the operation. If the size of the data type is not guaranteed to be 4 bytes, use `sizeof(norm2)` instead of a hardcoded value to avoid potential buffer overflows or underflows.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a2c11e15-4514-3a7c-be79-bcb17aa257ff",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis indicates that they may refer to overlapping memory areas. This can lead to unpredictable program behavior, data corruption, or crashes. The function used for copying does not guarantee correct behavior when the source and destination overlap. There are no explicit checks or guards in the code to prevent this overlap, and neither the source nor the destination is null at the call site, which means the operation will proceed and potentially trigger undefined behavior. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy` for such cases. `memmove` correctly handles overlapping memory areas by ensuring the copy is performed in a way that avoids data corruption.\n\n**Remediation Example:**\n\n```cpp\nmemmove(xi, c, sizeof(*x) * d);\n```\n\nThis change ensures that even if `xi` and `c` overlap, the memory copy will be performed safely and predictably.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "30394aae-25d1-396e-acb7-3a7ad1986dca",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The source and destination expressions are both identifiers, and dataflow analysis indicates that the destination may be derived from the source, which can lead to overlapping memory regions. The use of a standard memory copy function in such a scenario is unsafe, as it does not handle overlapping regions correctly. Additionally, there is no evidence of a guard to prevent null pointers for the source, further increasing the risk. The destination is not likely to be null, but the source may be, which could also result in undefined behavior. These factors together confirm the presence of a genuine issue that requires remediation.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. For example, change the code to:\n\n```cpp\nmemmove(ips, LUT, sizeof(*ips) * nc);\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the operation to avoid null pointer dereference:\n\n```cpp\nif (ips != nullptr && LUT != nullptr) {\n    memmove(ips, LUT, sizeof(*ips) * nc);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4f1fd3bf-2b1f-3163-b6a9-a44a10046044",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The use of a raw memory copy function without explicit checks for overlap or null pointers increases the risk of subtle bugs or security issues. These factors indicate a real and actionable problem that should be addressed to ensure program correctness and security.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with a function that safely handles overlapping regions, such as `memmove`. Additionally, ensure that the source pointer is not null before performing the copy. For example:\n\n```cpp\nif (c != nullptr && xi != nullptr) {\n    memmove(xi, c, sizeof(*xi) * d);\n}\n```\nThis change ensures that the copy operation is safe even if the source and destination regions overlap, and it avoids dereferencing null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "58a11958-a1cc-3655-87a0-99e4648597d1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts characters until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to a buffer overflow. This can result in undefined behavior, including program crashes, incorrect results, or even code execution.\n\nIn the provided code snippet, the `strlen` function is used to check if the length of the string `sx` is equal to 4. If `sx` is not null-terminated, this could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen` on strings that may not be null-terminated. Instead, consider using functions that take the length of the string as an argument, such as `strnlen`, which will not read past the specified length.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` and add a maximum length to prevent buffer overflow:\n\n```cpp\nFAISS_THROW_IF_NOT(4 == strnlen(sx, MAX_LENGTH))\n```\n\nReplace `MAX_LENGTH` with the maximum length of the string `sx`.\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- `cstring` or `string.h` for `strlen` or `strnlen`\n- `faiss/impl/FaissAssert.h` for `FAISS_THROW_IF_NOT`\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "b168ac0e-b0a7-3d56-8ff8-764ce3c43096",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis indicates that they may refer to overlapping memory areas. This can cause unpredictable results with memcpy, which does not support overlapping regions. Additionally, there is no evidence of a guard to prevent null pointers for the source, increasing the risk of a crash or further undefined behavior. The destination is not likely to be null, but the source may be. The use of a calculated size (sizeof(*x) * d) does not guarantee that the memory regions are distinct or properly sized. These factors make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the regions overlap.\n\n```cpp\nmemmove(xi, c, sizeof(*x) * d);\n```\n\nAdditionally, ensure that both `xi` and `c` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (xi != nullptr && c != nullptr) {\n    memmove(xi, c, sizeof(*x) * d);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a5d2717d-e878-33d4-bc4a-8062b34a3bbf",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there are no checks ensuring that the source and destination pointers are non-null before the operation, which increases the risk of null pointer dereference. The copy length is determined by a variable whose relationship to the actual buffer sizes is not clear, and there are no explicit bounds or guards to prevent buffer overflows or underflows. These factors together make this a high-confidence, actionable issue that could lead to memory corruption or program crashes.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination pointers are not null and that the memory regions do not overlap. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove`. Also, validate that the copy length does not exceed the size of either buffer to prevent buffer overflows.\n\n```cpp\nif (buffer.data() != nullptr && src != nullptr &&\n    (buffer.data() + nb1 <= src || src + nb1 <= buffer.data())) {\n    memcpy(buffer.data(), src, nb1);\n} else if (buffer.data() != nullptr && src != nullptr) {\n    // Safe handling for overlapping regions\n    memmove(buffer.data(), src, nb1);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2dc4f657-1f96-3c4a-b264-85598cc8d15a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which increases the risk of null pointer dereference. The absence of explicit bounds checks or guards for the buffer size and the copy length further increases the risk. The verdict is supported by the high-confidence classification and the explicit 'GENUINE' verdict from the analysis.\n\n## In Context Remediation\nTo remediate the undefined behavior risk caused by possible overlapping memory regions in the memory copy operation, ensure that the source and destination do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is safe for overlapping regions. Additionally, add explicit checks to ensure that both the source and destination pointers are not null before performing the copy. Also, verify that the copy length does not exceed the bounds of the destination buffer.\n\n```cpp\nif (src != nullptr && buffer.data() != nullptr && nb > 0) {\n    // If overlap is possible, use memmove instead of memcpy\n    memmove(buffer.data() + b0, src, nb);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1836240b-80c0-30c9-ad4f-58fbb19d69a3",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as genuine, and the classification explicitly states a risk of undefined behavior. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions. Additionally, the source may be null at this point, which further increases the risk. There are no explicit guards or checks to prevent these issues, and the destination is not confirmed to be a safe, non-overlapping region. This combination of factors means the issue is real and should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. This ensures that the copy operation works correctly even if the source and destination overlap.\n\n```cpp\nmemmove(&inorm, &norm, 4);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. If the size of the data type is not guaranteed to be 4 bytes, use `sizeof` to avoid hardcoding the size:\n\n```cpp\nmemmove(&inorm, &norm, sizeof(inorm));\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9b9f1611-450e-36e8-a28d-51defe71bddc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null, which further increases the risk of undefined behavior. The destination buffer is a pointer with no known capacity, and the length argument is not derived from the destination's size, making it difficult to guarantee safe copying. These factors together indicate a real risk of memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n**Remediation example:**\n\n```cpp\nif (buffer.data() != nullptr && dst != nullptr) {\n    memmove(dst, buffer.data(), nb2);\n}\n```\n\nIf you know for certain that the regions never overlap, document this assumption clearly in the code and add assertions to enforce it at runtime:\n\n```cpp\nassert(dst != buffer.data()); // or a more precise non-overlap check\nmemcpy(dst, buffer.data(), nb2);\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6786065e-61c7-3c7b-aca0-8deed6ba7411",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file name (`fname`) is manipulated by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `fopen`, consider using `fopen_s` which is a more secure alternative. Always validate and sanitize inputs to these functions to prevent any malicious manipulation.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with `fopen_s`:\n\n```cpp\nerrno_t err;\nFILE* f;\nerr = fopen_s(&f, fname, \"rb\");\nif (err != 0) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "649b1afd-bf2b-3fb8-ba10-4d6aa27fd77e",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source may refer to overlapping memory areas, as indicated by the data flow from the destination to the source. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, which further increases the risk of undefined behavior. The destination is a pointer type with no known capacity, and the count argument is not derived from the destination's size or a safe bound. All these factors contribute to a high confidence that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. `memcpy` does not guarantee correct behavior if the source and destination overlap, while `memmove` is specifically designed for this scenario. Replace the original call with:\n\n```cpp\nmemmove(dst, buffer.data() + b0, nb);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dba21b98-c748-3a27-b3dd-15474d13c799",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can potentially introduce a security risk. In this case, the `fopen` function is used, which can lead to vulnerabilities such as arbitrary file overwrite, directory traversal, or other file-based attacks if the `fname` parameter is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen` that provide better control over file access and permissions. Also, always validate and sanitize input that will be used as a filename or a part of a filename. Avoid using user input to construct a filename if possible.\n\n## Source Code Fix Recommendation\n\nInstead of using `fopen`, consider using `fopen_s` which is a safer alternative. Here is an example of how to use it:\n\n```cpp\nerrno_t err;\nFILE* f;\nerr = fopen_s(&f, fname, \"wb\");\nif (err != 0) {\n    // Handle error\n}\n```\n\nIn this example, `fopen_s` returns an error code that can be checked to ensure the file was opened successfully.\n\n## Library Dependencies\n\nThe code example requires the `stdio.h` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f1085e7a-6da6-353b-a098-66c1595c91fb",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are both pointers, and dataflow analysis suggests that the destination may alias the source, which can cause undefined behavior with functions like memcpy. Additionally, the source pointer may be null at this call site, which further increases the risk of runtime errors. There are no explicit checks or guards in the code to prevent these issues, and the size argument is not derived from the destination's capacity, making it difficult to guarantee safety. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions, such as `memmove`. This function handles overlapping memory correctly and avoids undefined behavior. For example, change the code to:\n\n```cpp\nmemmove(c, ScopedCodes(il, list_no).get(), sz);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. You can add checks like:\n\n```cpp\nif (c != nullptr && ScopedCodes(il, list_no).get() != nullptr) {\n    memmove(c, ScopedCodes(il, list_no).get(), sz);\n}\n```\n\nThis approach eliminates the risk of undefined behavior due to overlapping memory and null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0ccc6549-8f3d-3762-9d7b-1ead0627e652",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory areas, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent the source pointer from being null, which further increases the risk. The classification explicitly states a risk of undefined behavior, and the verdict confirms this is a genuine issue. The absence of a destination buffer capacity check and the use of a generic count expression (not directly tied to the destination's size) further support the assessment that this is a real vulnerability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap before calling the memory copy function. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove`, instead of `memcpy`. For example, replace the original call with:\n\n```cpp\nmemmove(&data[o], ptr, size * nitems);\n```\n\nAlternatively, add logic to check for overlap and handle accordingly. Always validate that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2c46a065-6a91-3b2c-ade3-26242e1cf925",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that overlap is feasible based on data flow from the destination to the source, which can cause undefined behavior with functions like memcpy. Additionally, the source pointer may be null at this call site, further increasing the risk. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not known, making it difficult to ensure safe copying. These factors indicate a high likelihood of a real vulnerability that could lead to memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, replace the memory copy function with one that is safe for overlapping regions, such as `memmove`. This ensures that the copy operation is performed correctly even if the memory areas overlap.\n\n```cpp\nmemmove(ptr, &data[rp], size * nitems);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. You can add checks like:\n\n```cpp\nif (ptr != nullptr && &data[rp] != nullptr) {\n    memmove(ptr, &data[rp], size * nitems);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9a5a4676-a65d-31e5-8720-f6ad309db9ae",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is no evidence of a guard to prevent this, and the source may also be null, which could lead to a crash or further undefined behavior. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent potential memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the source and destination overlap.\n\n```cpp\nmemmove(&codes[list_no][offset * code_size], codes_in, code_size * n_entry);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy to avoid potential crashes:\n\n```cpp\nif (codes_in != nullptr) {\n    memmove(&codes[list_no][offset * code_size], codes_in, code_size * n_entry);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5ab4dc3a-fe8e-3ae3-b7b1-11d623dc9d74",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null, which could lead to a crash. The classification explicitly states a risk of undefined behavior, and the verdict confirms this is a genuine issue. These factors indicate a real risk of memory corruption or program instability if the overlap occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(&codes[list_no][o * code_size], code, code_size * n_entry);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy to avoid potential crashes:\n\n```cpp\nif (code != nullptr) {\n    memmove(&codes[list_no][o * code_size], code, code_size * n_entry);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "08e7519f-ba1e-3f4b-8464-a45e96c0bb35",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory. This is a well-known source of undefined behavior in C/C++ when using functions like memcpy. Additionally, the analysis could not rule out the possibility that the source pointer is null, which further increases the risk. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly defined or checked. As a result, this is a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. `memmove` is specifically designed to handle overlapping memory areas, whereas `memcpy` is not. \n\n**Remediation example:**\n\n```cpp\nmemmove(c, ScopedIds(il, list_no).get(), sz * sizeof(idx_t));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. You can add explicit checks:\n\n```cpp\nif (c != nullptr && ScopedIds(il, list_no).get() != nullptr) {\n    memmove(c, ScopedIds(il, list_no).get(), sz * sizeof(idx_t));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "43f97c64-ba69-3c56-b489-21773aca1453",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null, which could lead to a crash or further undefined behavior. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent potential memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the regions overlap.\n\n```cpp\nmemmove(&ids[list_no][offset], ids_in, sizeof(ids_in[0]) * n_entry);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy to avoid potential crashes:\n\n```cpp\nif (ids_in != nullptr) {\n    memmove(&ids[list_no][offset], ids_in, sizeof(ids_in[0]) * n_entry);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-415: Double Free](https://cwe.mitre.org/data/definitions/415.html)\n- [CWE-416: Use After Free](https://cwe.mitre.org/data/definitions/416.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5733ed89-3957-3ebd-8a12-dc6f11e3f2b9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from similar base pointers with index arithmetic, and dataflow analysis indicates that overlap is feasible. Additionally, there are no explicit checks to ensure that the source and destination do not overlap, and both pointers may potentially be null, which further increases the risk. The operation uses a raw memory copy function, which is not safe when overlapping regions are possible, as it can lead to data corruption or crashes. The absence of explicit bounds or null checks, and the lack of a guard to prevent underflow or null dereference, further support the assessment that this is a genuine and high-risk issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with a function that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. For example:\n\n```cpp\nmemmove(best_codes.data() + i * M, codes + i * M, sizeof(int32_t) * M);\n```\n\nThis change ensures that even if the source and destination regions overlap, the data will be copied correctly without causing corruption or crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e70516d9-65a0-3c97-97bd-ed0cf7f1f4c6",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent this, and the source pointer may be null at this point, which could also lead to a crash or undefined behavior. The classification and verdict both indicate a high-confidence issue. The probability of this being a false positive is very low due to the strong evidence of overlap and lack of safety checks.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the operation:\n\n```cpp\nif (ids_in != nullptr) {\n    memmove(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "537d19a5-2f2c-355f-afa6-a3db1a93df29",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence that the source pointer is guaranteed to be non-null, which further increases the risk. The destination is a pointer, and there is no indication that its size or bounds are being checked before the copy. The operation uses a calculated size for the copy, but without explicit checks or guarantees about the relationship between the source and destination, this can lead to undefined behavior if they overlap. This type of issue can result in unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original memory copy operation with the following:\n\n```cpp\nmemmove(codes, best_codes.data(), sizeof(int32_t) * n * M);\n```\n\nThis change ensures that the copy will be performed correctly even if the source and destination regions overlap. Additionally, consider adding explicit checks to ensure that both pointers are non-null before performing the copy to avoid null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3ce35f57-9bc2-3827-bb78-1cb8337ddb40",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. This can lead to unpredictable program behavior, data corruption, or crashes. There are no explicit checks or guards in the code to prevent this overlap, and the function used (`memcpy`) does not handle overlapping memory safely. The source and destination are both confirmed to be non-null at this point, so the main risk is the potential for memory overlap. This type of issue is a well-known source of subtle and dangerous bugs in C/C++ code.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping memory. This change ensures that the copy operation will not result in data corruption or unpredictable behavior if the source and destination regions overlap.\n\n```cpp\nmemmove(xi, c, sizeof(*x) * q->d);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "af03e58b-f774-367e-94e8-f95f1ff8b59e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, there is no evidence of a guard to prevent null pointers for the source, increasing the risk of a crash or further undefined behavior. The destination is unlikely to be null, but the source may be. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C/C++, use `memmove` instead of `memcpy` for this purpose. This change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n```cpp\n// Replace:\n// memcpy(xi, c, sizeof(*x) * q->d);\n\n// With:\nmemmove(xi, c, sizeof(*x) * q->d);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation to avoid crashes or further undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ef78a412-d7eb-3021-8343-4edb683d13ac",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis suggests that the source and destination may refer to overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, there are no explicit checks to ensure that the source and destination pointers are not null, which further increases the risk. The absence of bounds checks or guards, and the lack of evidence that the length is derived from the destination's capacity, all contribute to the severity of this issue. The classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with a function that safely handles overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. \n\n**Remediation example:**\n\n```cpp\nmemmove(xsub.data() + i * q->d, x + i * d + offset_d, q->d * sizeof(float));\n```\n\nThis change ensures that even if the source and destination regions overlap, the memory will be copied correctly without causing undefined behavior.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e072c7fe-67ca-3a7a-9545-684762dd0b88",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The destination is a pointer, and there is no information about its capacity or bounds checking. These factors together indicate a real risk of memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(cb, q->codebooks.data(), sub_codebook_size * sizeof(float));\n```\n\nAdditionally, consider adding explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy:\n\n```cpp\nif (cb != nullptr && q->codebooks.data() != nullptr) {\n    memmove(cb, q->codebooks.data(), sub_codebook_size * sizeof(float));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "870414e2-ee65-3b68-8f12-e5d65c184d74",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from related data pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there are no explicit checks or guards in the code to prevent null pointers or overlapping regions, which increases the risk of undefined behavior. The verdict is supported by the classification and the automated assessment, which both indicate a high-confidence issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. Additionally, ensure that both the source and destination pointers are not null before performing the operation. For example:\n\n```cpp\nif (xt.data() != nullptr && x != nullptr) {\n    memmove(xt.data() + i * q->d, x + i * d + offset_d, q->d * sizeof(*x));\n}\n```\nThis change ensures that the copy is safe even if the source and destination regions overlap, and it avoids dereferencing null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1697bdaa-81e2-3606-8217-9dcee7c6a69d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from related pointer arithmetic, and dataflow analysis indicates that the destination may overlap with the source. Additionally, the source pointer may be null at this call site, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function used (memcpy) does not handle overlapping memory regions safely. This combination of factors makes the finding a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping source and destination regions safely. This change ensures that the copy operation will not corrupt data or cause crashes if the regions overlap.\n\n```cpp\nmemmove(xslice + (i - i0) * dsub, x + i * d + m * dsub, dsub * sizeof(float));\n```\n\nAdditionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy operation to avoid null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "04dd7141-420f-30a5-92eb-a0da6be48a16",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `memmove`, you can use `std::copy` or `std::copy_backward` from `<algorithm>` which are safer and less prone to errors.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy_backward`:\n\n```cpp\n#include <algorithm>\n\nstd::copy_backward(&addr[right], &addr[right] + (size - right), &addr[right + 1] + (size - right));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memmove`\n- `<algorithm>` for `std::copy_backward`\n\n## OWASP Resources\n\n- [OWASP Proactive Controls](https://owasp.org/www-project-proactive-controls/)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4fc94590-ccbf-3da5-bcd0-3627e5a6a1c4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This can cause unpredictable results or program crashes, as the standard memory copy function does not handle overlapping regions safely. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null, which would further increase the risk of undefined behavior. The destination is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use a memory move function that is designed to handle overlapping regions safely. In C and C++, replace the memory copy function with a memory move function, such as `memmove`, which guarantees correct behavior even if the regions overlap. For example:\n\n```cpp\nmemmove(x + m * pq.dsub, pq.get_centroids(m, c), sizeof(float) * pq.dsub);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the operation to avoid null pointer dereference:\n\n```cpp\nconst void* src = pq.get_centroids(m, c);\nif (src != nullptr) {\n    memmove(x + m * pq.dsub, src, sizeof(float) * pq.dsub);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "89b28d0d-efda-3074-87b0-7f58c40385e3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, integer overflow, etc. These functions are often prohibited in secure coding standards. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `memmove`, you can use `std::copy` or `std::copy_backward` from the `<algorithm>` library in C++, which are safer as they work with C++ containers and iterators.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `std::copy_backward`:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy_backward(&addr[left], &addr[left + size], &addr[left + size + 1]);\n```\n\n## Library Dependencies\n\nThe original code requires the `<cstring>` library for `memmove`. The fixed code requires the `<algorithm>` library for `std::copy_backward`.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c7ec45dd-3e5f-3145-abc9-3d1f90a92516",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, both the source and destination pointers may be null at this call site, and there are no explicit checks to prevent this. The operation does not use a guard to ensure the pointers are valid or non-overlapping, and the count argument is not derived from the destination's capacity. These factors increase the risk of undefined behavior, such as memory corruption or crashes, if the overlap or null pointer dereference occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation. For example:\n\n```cpp\nif (clus.centroids.data() != nullptr && get_centroids(m, 0) != nullptr) {\n    memmove(clus.centroids.data(), get_centroids(m, 0), dsub * ksub * sizeof(float));\n}\n```\n\nThis change ensures that the copy is safe even if the memory regions overlap and avoids dereferencing null pointers.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8ee942d6-d2af-381d-8f9c-678c505933f2",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior with functions like memcpy. Additionally, the source may be null, which further increases the risk. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's capacity is not clearly defined or enforced. These factors together make this a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(xslice + j * dsub, x + j * d + m * dsub, dsub * sizeof(float));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "64a16ac3-1fc5-354c-9c7d-32ccab564618",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from the same base data structure, and dataflow analysis suggests that the destination could overlap with the source. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. The absence of a null-termination step and the lack of evidence that the copy length is derived from the destination's capacity further increase the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(c + i * subdim, &cache[codes[i] * subdim], sizeof(*c) * subdim);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5ea9d47f-64dd-3f55-aa04-e7203db2b072",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis indicates that they may refer to overlapping memory areas. This can lead to unpredictable results or program crashes, as the standard memory copy function does not guarantee correct behavior when regions overlap. There are no explicit checks or guards in the code to prevent this situation, and the function verdict confirms the issue as genuine. The source and destination are both non-null at this point, so the main risk is the potential for overlapping memory regions.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas correctly. \n\n**Remediation example:**\n\n```cpp\nmemmove(vmax, x, sizeof(*x) * d);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3bbec019-e182-3e3a-8884-924dd7f0bf62",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. This can lead to unpredictable program behavior, data corruption, or crashes. The function used for copying does not guarantee correct behavior when the source and destination overlap. There are no explicit checks or guards in the code to prevent this overlap, and the destination and source are not null at the call site, which means the operation will proceed if overlap occurs. This is a well-known class of issues in C/C++ buffer operations.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is specifically designed to handle overlapping memory areas safely. For example, change the code to:\n\n```cpp\nmemmove(vmin, x, sizeof(*x) * d);\n```\n\nThis ensures that the copy operation will work correctly even if the source and destination regions overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "152d10cc-34aa-3e85-ad1a-e1b6d9704173",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This can cause unpredictable results or crashes, as the standard memory copy function does not handle overlapping regions safely. Additionally, there is no evidence of a guard to prevent the source from being null, which further increases the risk. The destination is likely a local or field array, reducing the risk of it being null, but the overlap and null source risks are sufficient to consider this a real issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a memory-safe function that handles overlapping regions, such as `memmove`, instead of `memcpy`. This ensures that the copy operation is performed correctly even if the source and destination overlap.\n\n```cpp\n// Replace memcpy with memmove to safely handle overlapping regions\nmemmove(&cache[i * dimsub], c.data() + dim - dimsub, dimsub * sizeof(*c.data()));\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy:\n\n```cpp\nif (c.data() != nullptr) {\n    memmove(&cache[i * dimsub], c.data() + dim - dimsub, dimsub * sizeof(*c.data()));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7805de82-ccb9-3258-8dba-b1999b6d2f0f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. This can cause unpredictable results or program crashes, since the standard memory copy function does not support overlapping regions. Additionally, there is a risk that the destination pointer could be null, as there is no clear check ensuring it is valid before the operation. The source pointer is guarded and considered non-null, but the destination is not. These factors make this a high-confidence, actionable issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. \n\n```cpp\nmemmove(x_copy.data(), x, n * sizeof(*x));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (x_copy.data() != nullptr && x != nullptr) {\n    memmove(x_copy.data(), x, n * sizeof(*x));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "aeca8cbe-7a71-3eb5-a36b-c90a749d7f6b",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The count argument used for the copy operation is not derived from the destination's capacity, and there is no explicit null-termination or bounds check. These factors all increase the likelihood of a real issue that could result in memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that the source pointer is not null before performing the copy operation. For example:\n\n```cpp\nif (block != nullptr && flat_codes != nullptr) {\n    memmove(flat_codes, block, code_size);\n}\n```\n\nIf you know that the regions never overlap, document this assumption clearly and consider adding assertions to enforce it at runtime:\n\n```cpp\nassert(flat_codes != block);\nmemcpy(flat_codes, block, code_size);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0470a315-ab4a-3a76-95d4-ba955ab8ab05",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, indicating that they may refer to overlapping memory. Additionally, the source pointer may be null at this point, as there is no prior check ensuring it is valid. The destination is less likely to be null, but the main concern is the potential for overlapping memory regions, which can cause undefined behavior with functions like memcpy. No explicit bounds or null-termination handling is present, and the count argument is not derived from the destination's capacity. These factors all contribute to the high confidence in this being a real issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the regions overlap.\n\n```cpp\nmemmove(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (dest_dis != nullptr && buf.dis != nullptr) {\n    memmove(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "58f4d292-5aa8-3e07-9472-356e50bff644",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent potential memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that the source pointer is not null before performing the copy operation.\n\n**Remediation Example:**\n\n```cpp\nif (flat_codes != nullptr && block != nullptr) {\n    // Use memmove instead of memcpy to safely handle possible overlap\n    memmove(block, flat_codes, code_size);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5f984b00-e9dd-388f-b5fe-40f9fe14d1c5",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the operation involves copying memory between regions that may overlap, which is undefined behavior for the function used. The analysis detected that the source and destination memory regions could overlap due to their relationship in the data flow, and this is confirmed by the explicit note that overlap is feasible. Additionally, there is no evidence of a guard to prevent this, and the function used does not handle overlapping memory safely. The source pointer may also be null, which could lead to a crash. These factors indicate a real risk of undefined behavior and potential security or correctness issues.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping memory areas safely.\n\n**Remediation example:**\n\n```cpp\nmemmove(centroids + perm[i] * dsub, centroids_copy.data() + i * dsub, dsub * sizeof(centroids[0]));\n```\n\nThis change ensures that even if the source and destination regions overlap, the operation will be performed safely and predictably.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "811d38f3-c76e-39ac-be38-c0ba5fe748cd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fprintf` function is used, which can lead to format string vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `fprintf`, consider using `fputs` or `fwrite` which do not interpret the format string. Always validate and sanitize input data before using it in such functions.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code:\n\n```cpp\nfputs(\"read_InvertedLists: WARN! inverted lists not stored with IVF object\\n\", stderr);\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `stdio.h`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "51c9f610-24b4-3eed-a8b8-2ceab3119963",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, there is a possibility that the source pointer could be null at this point, as there is no prior check ensuring it is non-null. The destination is less likely to be null, but the main concern is the potential for overlapping memory regions, which is a well-known source of subtle and dangerous bugs in C/C++ code. No explicit bounds or null-termination protections are present, and the count argument is not derived from the destination's capacity, increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping regions, such as `memmove` instead of `memcpy`. Replace the original memory copy operation with `memmove` to ensure correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. Add explicit checks if necessary to avoid null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1d70bb79-65c8-3ed4-a529-0bda9dbc1673",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which further increases the risk of undefined behavior. The absence of explicit bounds or capacity checks, as well as the lack of a guard to prevent null pointers, reinforces the severity of this issue. The verdict is supported by the fact that the tool's dataflow analysis found a feasible path where the destination and source may overlap, and both pointers may be null.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap before calling memcpy. If there is any possibility of overlap, use memmove instead, which is safe for overlapping regions. Additionally, check that both source and destination pointers are not null before performing the copy operation.\n\nExample remediation:\n\n```cpp\nif (ail && vec.data() && ail->codes[i].data() && ail->codes[i].data() != vec.data()) {\n    // If overlap is possible, use memmove instead of memcpy\n    memmove(ail->codes[i].data(), vec.data(), ail->codes[i].size());\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly and add runtime assertions to enforce it:\n\n```cpp\nassert(ail->codes[i].data() != vec.data());\nassert(ail->codes[i].data() != nullptr);\nassert(vec.data() != nullptr);\nmemcpy(ail->codes[i].data(), vec.data(), ail->codes[i].size());\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f0dd8a5c-b513-35c7-a2ee-91d90b4163be",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"quantizer_\")` is used to determine the length of a constant string. This is not a vulnerability per se, but it's a bad practice because the length of a constant string can be determined at compile time, making the use of `strlen` unnecessary and inefficient.\n\n## Mitigation Advice\n\nAvoid using `strlen` to determine the length of constant strings. Instead, use the `sizeof` operator, which can determine the length at compile time, or simply hard-code the length if it's known.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(\"quantizer_\")` with `sizeof(\"quantizer_\") - 1` or `10` (the actual length of the string \"quantizer_\").\n\n```cpp\nsub_name = name.substr(sizeof(\"quantizer_\") - 1);\n```\n\nor\n\n```cpp\nsub_name = name.substr(10);\n```\n\n## Library Dependencies\n\nThe code snippet requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "e28b967e-a65a-3db9-ab26-e014990fba94",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a program uses insecure or deprecated C library functions. In this case, the `fopen` function is used, which can lead to various security risks such as buffer overflows or format string vulnerabilities. \n\nThe `fopen` function is used to open a file, but it does not perform any checks on the validity of the filename. This can lead to vulnerabilities if the filename is in any way influenced by user input, as it could lead to opening of unintended files or even execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen`. In C++, the `fstream` library provides the `ofstream` and `ifstream` classes which can be used to open files for writing and reading respectively. These classes provide more robust error checking and are less prone to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ofstream` class from the `fstream` library. The fixed code would look like this:\n\n```cpp\n#include <fstream>\n\nstd::ofstream optim_logfile(fname);\nif (!optim_logfile) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstdio` for the `fopen` function\n\nThe fixed code requires the following library:\n\n- `fstream` for the `ofstream` class\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "50c00415-ff37-3c87-b1b5-00c467c2ab27",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string is not controlled by the programmer or if user-supplied data is used as part of the format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `printf` such as `fprintf`, `sprintf`, or `snprintf` with a maximum buffer size specified. Additionally, always control the format string and never use user-supplied data as part of the format string.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `snprintf`:\n\n```cpp\nchar buffer[100];\nsnprintf(buffer, sizeof(buffer), \"   m=%d, nq=%zd, nb=%zd, initialize RankingScore \"\n                   \"in %.3f ms\\n\",\n                   m,\n                   nq,\n                   nb,\n                   getmillisecs() - t0);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for `printf` or `snprintf`\n- `<ctime>` or `<sys/time.h>` for `getmillisecs()`, depending on how this function is implemented\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a27a49a3-24ca-3339-b76d-940a9c0aff8f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a program uses insecure or deprecated C library functions. In this case, the `fopen` function is used, which can lead to various security risks such as buffer overflows or format string vulnerabilities. \n\nThe `fopen` function is used to open a file, but it does not perform any checks on the validity of the filename. This can lead to vulnerabilities if the filename is in any way influenced by user input, as it could lead to opening of unintended files or even execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen`. In C++, the `fstream` library provides the `ofstream` and `ifstream` classes which can be used to open files for writing and reading respectively. These classes provide more robust error checking and are less prone to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ofstream` class from the `fstream` library. The fixed code would look like this:\n\n```cpp\n#include <fstream>\n\nstd::ofstream optim_logfile(fname);\nif (!optim_logfile) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstdio` for the `fopen` function\n\nThe fixed code requires the following library:\n\n- `fstream` for the `ofstream` class\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "92936ba7-557c-3fa7-acd2-7fd793592b88",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the destination and source may overlap through data flow, which can cause unpredictable results with memcpy. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may be null at this point, further increasing the risk. The destination is not likely to be null, but the main concern is the potential for overlapping memory regions, which is not handled by memcpy and can lead to data corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping regions. This change ensures that the memory copy operation will not result in data corruption or crashes, even if the regions overlap.\n\n```cpp\nmemmove(centroids + perm[i] * dsub, centroids_copy.data() + i * dsub, dsub * sizeof(centroids[0]));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "021f3c2c-16c9-3c36-adda-160d4c1eb053",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there are no explicit checks ensuring that either the source or destination pointers are non-null before the operation, which increases the risk of null pointer dereference. The absence of any guard conditions or explicit null checks further supports the assessment that this is a real and actionable issue. The classification specifically highlights the undefined behavior risk associated with overlapping memory regions, which can lead to unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(gt_distances.data(), pq.sdc_table.data() + m * nq * nb, sizeof(float) * nq * nb);\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (gt_distances.data() != nullptr && pq.sdc_table.data() != nullptr) {\n    memmove(gt_distances.data(), pq.sdc_table.data() + m * nq * nb, sizeof(float) * nq * nb);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e2ef8c39-994c-35ec-aa93-bb11c6c2dea4",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the `printf` function is used, which can lead to format string vulnerabilities if user-controlled input is passed as the format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using unsafe C functions. Instead, use safer alternatives provided by the C++ standard library. For example, instead of `printf`, you can use `std::cout` for output. If you need to format strings, consider using `std::format` (C++20) or `sprintf` with a fixed format string.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <iostream>\n\nstd::cout << \"cloning MultiIndexQuantizer: will be valid only for search k=1\\n\";\n```\n\n## Library Dependencies\n\nThe original code requires the C standard library, which is included by default in most C++ environments. The fixed code requires the C++ standard library, specifically the `<iostream>` header.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "86f5e54b-3cc3-3c62-8b5b-41cf5c703a74",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string contains user-supplied data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `printf` such as `fprintf`, `sprintf`, or `snprintf` with a maximum length specified. Also, avoid using format strings that contain user-supplied data.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `snprintf`:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"  IndexIVFPQ size %ld -> GpuIndexIVFPQ \"\n                   \"indicesOptions=%d \"\n                   \"usePrecomputed=%d useFloat16=%d reserveVecs=%ld\\n\",\n                   ipq->ntotal,\n                   indicesOptions,\n                   usePrecomputed,\n                   useFloat16,\n                   reserveVecs);\n```\n\n## Library Dependencies\n\nThe code example does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d86b9265-3668-3194-a301-08a8961b7e47",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of memory corruption. In this case, the `printf` function is used, which can lead to format string vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, you can use `fprintf` or `snprintf` which are safer as they limit the number of characters to be printed, thus preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdio>\n\n// ...\n\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"      iteration %d cost %g temp %g n_swap %d \"\n                   \"(%d hot)     \\r\",\n                   it,\n                   cost,\n                   temperature,\n                   n_swap,\n                   n_hot);\nfputs(buffer, stdout);\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`: This library provides functions for performing input and output operations.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and may not be available in the future."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6f66c3aa-50ec-3d84-9e94-00c1e4cb4790",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis suggests that the destination and source pointers may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there is no evidence of checks to ensure that the source and destination are non-null or non-overlapping, and the analysis could not confirm that the pointers are always valid. The absence of explicit bounds or capacity checks further increases the risk. The verdict is supported by the classification and the high-confidence 'GENUINE' label from the analysis.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(xtrain.data() + i * dsub, x + i * pq.d + m * dsub, sizeof(float) * dsub);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. If possible, add explicit checks or assertions to guarantee pointer validity and correct bounds.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "aa176703-4dad-37ad-a8ae-7052aed91d0f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent this, and the source pointer may be null at this point, which further increases the risk. The destination is a pointer, and its capacity is not explicitly known, making it harder to guarantee safe copying. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(best_perm, perm.data(), sizeof(perm[0]) * n);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. For example:\n\n```cpp\nif (best_perm != nullptr && perm.data() != nullptr) {\n    memmove(best_perm, perm.data(), sizeof(perm[0]) * n);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0228618e-67ca-3c8c-9643-cfbd42b6b5dc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent the source pointer from being null, which further increases the risk. The destination pointer is not likely to be null, but the source pointer could be. The function used for copying does not handle overlapping memory regions safely, and this can lead to unpredictable program behavior or data corruption. These factors make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, `memmove` is designed for this purpose. Change the code to use `memmove` instead of `memcpy`:\n\n```cpp\nmemmove(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr));\n```\n\nThis ensures that the copy operation is performed safely, even if the source and destination regions overlap. Always verify that both pointers are valid and not null before performing the operation to avoid null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1d749b2c-cff0-3421-bd7e-48d9f545b0ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, and integer overflows. In the provided code snippet, the `printf` function is used, which can lead to format string vulnerabilities if the format string contains user-supplied data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, one can use `fprintf` or `snprintf` which are safer as they limit the number of characters to be printed, thus preventing buffer overflow attacks.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s] encode stage %d, %d bits, \"\n                   \"total error %g, beam_size %d\\n\",\n                   (getmillisecs() - t0) / 1000,\n                   m,\n                   int(rq.nbits[m]),\n                   sum_distances,\n                   beam_size);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for `printf`, `snprintf`, and `puts` functions.\n- `<time.h>` if `getmillisecs` function is implemented using standard C time functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f2668f77-7e12-3200-ac08-27afd13e71ea",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the following factors:\n\n- The classification explicitly states there is a risk of undefined behavior due to possible overlap between source and destination.\n- The analysis determined, via data flow, that the source and destination may refer to overlapping memory regions, which is not allowed for the standard memory copy function used here.\n- There is no evidence of a guard or check to prevent this overlap.\n- The source pointer may also be null at this point, which could lead to a crash or further undefined behavior.\n- The destination is not likely to be null, but this does not mitigate the overlap risk.\n\nBecause of these factors, this is a high-confidence, actionable issue that could lead to memory corruption or program crashes if not addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C/C++, use the memory move function, which is designed for this purpose. For example, replace the original call with:\n\n```cpp\nmemmove(out_distances, distances_ptr, distances_size * sizeof(*distances_ptr));\n```\n\nThis change ensures that the memory is copied correctly even if the source and destination regions overlap, preventing potential memory corruption or crashes.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "de532ab1-48fe-3c6d-a6a8-4978d74c1876",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to execution of arbitrary code, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the data being copied is greater than the size of the destination buffer, then the program should handle this condition appropriately, such as by truncating the data or by allocating a larger buffer.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (N * K * sizeof(node_t) <= sizeof(data)) {\n    memcpy(data, g.data, N * K * sizeof(node_t));\n} else {\n    // Handle error condition, such as by truncating data or allocating a larger buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "94eec2ea-7cd8-3ba9-a1c7-32fdc0c7ee9d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of memory corruption. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `memmove`, you can use `std::copy` or `std::copy_backward` from the `<algorithm>` library in C++, which are safer as they work with C++ containers and iterators.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy_backward`:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy_backward(&addr[right], &addr[K], &addr[K + 1]);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memmove`\n- `<algorithm>` for `std::copy_backward`\n\n## OWASP and CWE Resources\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "aa1cab7a-5cd8-3292-9346-03252528663a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as 'GENUINE', and the classification explicitly states there is a risk of undefined behavior. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with standard memory copy functions. Additionally, the source may be null, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's capacity is not clearly defined. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the regions overlap.\n\n```cpp\nmemmove(new_codes_i, codes_i + js * m, sizeof(*codes) * m);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. If the size or bounds of the buffers are not clear, add explicit checks to validate them before copying.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8ff697c7-556b-3e15-9f70-d7165241ec51",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Found\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflow, format string, or integer overflow vulnerabilities. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\nBuffer overflow vulnerabilities occur when a program writes more data to a buffer than it can hold, causing the excess data to overflow into adjacent memory. This can lead to unpredictable program behavior, including memory access errors, incorrect results, a crash, or a breach of system security.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `memmove`, you can use `memcpy_s` or `memmove_s` which are safer as they include the size of the destination buffer as a parameter, helping to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the code:\n\n```cpp\n#include <string.h>\n#include <stdlib.h>\n\n// Assuming Neighbor is a defined structure\nstruct Neighbor {\n    // structure members\n};\n\n// Assuming K and left are defined and valid\nsize_t K = 10;\nsize_t left = 5;\n\n// Assuming addr is a defined and valid array of Neighbor\nNeighbor addr[15];\n\n// Fix: Use memmove_s instead of memmove\nerrno_t err = memmove_s(&addr[left + 1], (K - left - 1) * sizeof(Neighbor), &addr[left], K * sizeof(Neighbor));\nif (err) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string.h>` for `memmove`\n- `<stdlib.h>` for `errno_t` and error handling\n\n## OWASP and CWE Links\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "037da8d4-ba58-3c16-8d0a-bdd979bceca8",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no explicit check to ensure that the source pointer is not null, which could also lead to undefined behavior. The destination pointer is not likely to be null, but the absence of overlap and null checks increases the risk. The operation does not use a guard to prevent underflow or overflow, and the count argument is not derived from the destination's capacity, making it more likely that this is a real issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(out_residuals, residuals_ptr, residuals_size * sizeof(*residuals_ptr));\n```\n\nAdditionally, ensure that both `out_residuals` and `residuals_ptr` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (out_residuals != nullptr && residuals_ptr != nullptr) {\n    memmove(out_residuals, residuals_ptr, residuals_size * sizeof(*residuals_ptr));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3b6fa39f-d4af-3e28-8249-5e81081edac8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, and integer overflows. In the provided code snippet, the `printf` function is used, which can lead to format string vulnerabilities if not used properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, you can use `fprintf` or `snprintf` which are safer as they limit the amount of output.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```cpp\n#include <cstdio>\n\nint main() {\n    int iter = 10;\n    fprintf(stdout, \"re-estimating the codebooks to minimize \"\n                    \"quantization errors (iter %d).\\n\",\n                    iter);\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdio` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Format_string_attack)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8aeb9193-400a-3370-a64f-b5589fdb407e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string is not controlled completely by the program, or if the arguments do not match the directives in the format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `printf` such as `snprintf` or `fprintf`. These functions allow for the specification of a maximum length of the output string, which can prevent buffer overflows. Additionally, it is important to ensure that the format string is not user-controlled and that the arguments match the directives in the format string.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `snprintf`:\n\n```cpp\nchar buffer[200];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s, %.3f s clustering] train stage %d, %d bits, kmeans objective %g, \"\n                   \"total distance %g, beam_size %d->%d (batch size %zd)\\n\",\n                   (getmillisecs() - t0) / 1000,\n                   clustering_time,\n                   m,\n                   int(nbits[m]),\n                   obj,\n                   sum_distances,\n                   cur_beam_size,\n                   new_beam_size,\n                   bs);\n```\n\n## Library Dependencies\n\nThe code example does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3213c710-6b62-300e-8aa2-9c9a98155fa3",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected, through data flow, that the destination and source may refer to overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, there is a risk that the source pointer may be null at this point, as there is no prior check ensuring it is valid. The destination is less likely to be null, but the primary concern is the potential for overlapping memory regions, which can lead to unpredictable program behavior, data corruption, or crashes. No explicit size or bounds checks are present, and the count argument is not derived from the destination's capacity, further increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C and C++, use the memory move function, which is designed for this purpose. For example, replace the original call with:\n\n```cpp\nmemmove(out_distances, pool.distances.data(), distances_size * sizeof(pool.distances[0]));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap. Additionally, consider adding checks to ensure that the source pointer is not null before performing the operation to avoid potential null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5fbba3c0-4c4c-35ec-86db-b14ca14cb6bc",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, and integer overflows. In the provided code snippet, the `printf` function is used, which can lead to format string vulnerabilities if the format string is not controlled by the programmer or if user-supplied data is used as a format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, one can use `fprintf` or `snprintf` which are safer as they limit the amount of data that can be written, thus preventing buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s] encode stage %d, %d bits, \"\n                   \"total error %g, beam_size %d\\n\",\n                   (getmillisecs() - t0) / 1000,\n                   m,\n                   int(rq.nbits[m]),\n                   sum_distances,\n                   cur_beam_size);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<stdio.h>` for `printf`, `snprintf`, and `puts` functions.\n- `<time.h>` if `getmillisecs` function is used to get the current time in milliseconds.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "689c600e-ae99-3a4e-a3e5-c898414bc490",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to the possibility that either the source or destination pointer in the memory copy operation may be null. There are no visible checks in the code to ensure that these pointers are valid before the memory operation is performed. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The absence of null pointer guards for both the source and destination increases the likelihood of a real issue. The memory copy operation uses pointer arithmetic and dynamic data, which further increases the risk if not properly validated.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that both the source and destination pointers are not null. Add explicit checks to validate the pointers and handle error conditions appropriately. For example:\n\n```cpp\nif (this->codebooks.data() != nullptr && codebooks.data() != nullptr) {\n    memcpy(this->codebooks.data() + codebook_offsets[m] * d, codebooks.data(), codebooks.size() * sizeof(codebooks[0]));\n} else {\n    // Handle error: one or both pointers are null\n    // For example, log an error or throw an exception\n}\n```\nThis prevents undefined behavior due to null pointer dereference and ensures the memory operation is only performed when both pointers are valid.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c09f8625-1aec-3f91-afc6-96755c3547fc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the source and destination may refer to overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, there is no evidence of a guard to prevent null pointers for the source, further increasing the risk. The destination is not likely to be null, but the source may be, and there is no explicit check for this. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` is specifically designed to handle overlapping memory safely. For example:\n\n```cpp\nmemmove(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr));\n```\n\nThis change ensures that the copy operation is well-defined even if the source and destination regions overlap. Additionally, consider adding explicit checks to ensure that neither pointer is null before performing the operation to avoid null pointer dereference vulnerabilities.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "796bc0f1-54c8-3ab2-8ad8-2b8d2364f7bd",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. This can cause unpredictable results when using memory copy functions that do not support overlapping regions. Additionally, the source pointer may be null in some cases, which could also lead to a crash or undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the source and destination are distinct or valid. The destination is a pointer type, and there is no evidence that the length argument is derived from the actual buffer capacity, increasing the risk of memory safety issues.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, `memmove` is designed for this purpose. Change the code to use `memmove` instead of `memcpy`:\n\n```cpp\nmemmove(new_codes_i, codes_i + js * m, sizeof(*codes) * m);\n```\n\nThis ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e95e1201-8c57-31fa-abb0-725ef3106ca9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the destination and source may overlap based on data flow, which can cause unpredictable results with standard memory copy functions. Additionally, the source pointer may be null at this location, which further increases the risk. There are no explicit guards or checks to prevent these issues, and the destination buffer's size is not clearly defined, making it difficult to guarantee safe operation. These factors indicate a high likelihood of a real issue that could lead to memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely.\n\n**Remediation example:**\n\n```cpp\nmemmove(new_codes_i, codes_i + js * m, sizeof(*codes) * m);\n```\n\nThis change ensures that even if the source and destination regions overlap, the copy will be performed correctly without causing undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e370e54a-532f-3817-b473-6d750b5cfcbb",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with standard memory copy functions. Additionally, there is a possibility that the source pointer could be null at this point, as there is no prior check ensuring it is valid. The destination is considered safe from being null due to a previous guard. These factors indicate a real risk of memory corruption or program crashes if the overlap or null pointer scenarios occur.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. Additionally, ensure that the source pointer is not null before performing the copy to avoid null pointer dereference. For example:\n\n```cpp\nif (other.codebooks.data() != nullptr) {\n    memmove(codebooks.data(), other.codebooks.data() + other.codebook_offsets[skip_M] * d, codebooks.size() * sizeof(codebooks[0]));\n}\n```\n\nThis change ensures that the copy is safe even if the source and destination overlap, and avoids undefined behavior due to null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "98f2fc2f-9d60-3167-a4ca-f0520e7e341d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured URL Vulnerability in C++ is a security flaw that occurs when a program does not validate or incorrectly validates the URL before it's used in a network operation. This can lead to various attacks such as phishing, URL redirection to untrusted sites, and remote code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n- Always validate URLs before using them in network operations.\n- Use secure functions that perform URL validation.\n- Avoid using user-supplied data in URLs without proper validation and sanitization.\n- Use libraries that support URL encoding and decoding.\n\n## Source Code Fix Recommendation\n\nThe following is a simple example of how to validate a URL using the `Poco` library in C++:\n\n```cpp\n#include <Poco/URI.h>\n\nint main() {\n    std::string url = \"http://www.netlib.org\";\n    Poco::URI uri;\n    try {\n        uri = Poco::URI(url);\n    } catch (Poco::Exception& ex) {\n        std::cerr << \"Invalid URL: \" << ex.displayText() << std::endl;\n        return -1;\n    }\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the `Poco` library. You can install it using the following command:\n\n```bash\nsudo apt-get install libpoco-dev\n```\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n- [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "7de317c0-460f-3b18-acca-8bda9c60e47e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to the possibility that either the source or destination pointer in the memory copy operation may be null. There are no visible checks in the surrounding code to ensure that the memory addresses used for copying are valid and non-null. The risk is further increased because both the source and destination pointers are derived from dynamic data structures, and there is no evidence of bounds or null checks before the operation. The absence of overlap between source and destination reduces the risk of data corruption, but the potential for null pointer dereference remains a critical issue. The classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that both the source and destination pointers are valid and not null. Add explicit checks to verify that `residuals1.data()` and `residuals.data()` return non-null pointers before using them in the copy. For example:\n\n```cpp\nif (residuals1.data() != nullptr && residuals.data() != nullptr) {\n    memcpy(residuals1.data() + j * d, residuals.data() + j * d * cur_beam_size, sizeof(residuals[0]) * d);\n} else {\n    // Handle error: one or both pointers are null\n    // e.g., throw exception, return error code, or log the issue\n}\n```\n\nThis prevents undefined behavior due to null pointer dereference. Always validate pointers before using them in low-level memory operations.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c1cfd870-7d7e-355e-8de6-cd877a1c7d23",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to a variety of security issues.\n\nThe specific vulnerability sink in question is `(double)rand() / (double)RAND_MAX`. The `rand()` function in C++ is a weak random number generator that is not suitable for cryptographic purposes. It generates a pseudo-random number that can be easily predicted, especially if the seed is known or can be guessed.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use the `<random>` library, which provides a variety of random number generators that are more suitable for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nReplace the use of `rand()` with a cryptographic random number generator. Here is an example using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\ndouble random = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "c1cfd870-7d7e-355e-8de6-cd877a1c7d23"
                ]
              }
            },
            {
              "id": "becf4d46-43dd-31a3-84c1-5e0bdb43abb9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to a variety of security issues.\n\nThe specific vulnerability sink in question is `(double)rand() / (double)RAND_MAX`. The `rand()` function in C++ is a weak random number generator that is not suitable for cryptographic purposes. It generates a pseudo-random number that can be easily predicted, especially if the seed is known or can be guessed.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use the `<random>` library, which provides a variety of random number generators that are more suitable for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nReplace the use of `rand()` with a cryptographic random number generator. Here is an example using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\ndouble random = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "becf4d46-43dd-31a3-84c1-5e0bdb43abb9"
                ]
              }
            },
            {
              "id": "0b329990-7068-3021-af51-00a62557defb",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may refer to overlapping memory regions, which can cause unpredictable results with functions like memcpy. Additionally, there are no checks ensuring that the source and destination pointers are non-null, increasing the risk of null pointer dereference. No explicit bounds or capacity checks are present, and the count argument is not derived from a known safe source. These factors all contribute to the high confidence in this being a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping source and destination buffers. Replace the original call with:\n\n```cpp\nmemmove(nbits.data(), other.nbits.data() + skip_M, nbits.size() * sizeof(nbits[0]));\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the copy. For example:\n\n```cpp\nif (nbits.data() != nullptr && other.nbits.data() != nullptr) {\n    memmove(nbits.data(), other.nbits.data() + skip_M, nbits.size() * sizeof(nbits[0]));\n}\n```\n\nThis change eliminates the risk of undefined behavior due to overlapping memory regions and null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "59ea5dec-cff1-38bf-a7be-e60499c1b3be",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The code copies data from one buffer to another using a memory copy function, but dataflow analysis indicates that the source and destination may refer to overlapping memory regions. This can result in unpredictable behavior, data corruption, or crashes. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which further increases the risk of runtime errors. The absence of explicit bounds or capacity checks, and the lack of a guard to prevent null pointer dereferencing, reinforce the severity of this issue. Developers should ensure that the source and destination do not overlap and are valid before performing the copy operation.\n\n## In Context Remediation\nTo remediate the undefined behavior risk caused by possible overlapping memory regions, ensure that the source and destination buffers do not overlap before performing the memory copy. If overlap is possible, use a memory move function that safely handles overlapping regions. Additionally, add checks to ensure that neither the source nor the destination pointers are null before the operation.\n\nExample fix:\n\n```cpp\nif (ptrs.data() != nullptr && lims != nullptr) {\n    // If overlap is possible, use memmove instead of memcpy\n    memmove(ptrs.data(), lims, sizeof(lims[0]) * nbucket);\n}\n```\n\nThis change replaces the memory copy function with a memory move function, which is safe for overlapping regions, and adds null pointer checks to prevent dereferencing null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c55fdf17-d59e-3219-a616-723a70d9d6b7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The code copies data from one region to another using a standard memory copy function, but dataflow analysis suggests that the source and destination may overlap, which is not allowed for this function and can result in unpredictable behavior. Additionally, the analysis could not rule out the possibility that the source pointer is null, which could also lead to a crash. There are no explicit checks or guards in the code to prevent these issues, and the classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the standard memory copy function with a memory move function that safely handles overlapping regions. For example, change the code to use `memmove` instead of `memcpy`:\n\n```cpp\nmemmove(permB + segs[s].i0, permA + segs[s].i0, segs[s].len() * sizeof(size_t));\n```\n\nThis ensures that the data is copied correctly even if the source and destination regions overlap. Always verify that both source and destination pointers are valid and not null before performing the operation.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bfb0cb03-6333-3e9c-854e-dc3d71c2f5a9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code that can lead to various security issues such as buffer overflows, format string vulnerabilities, and integer overflows. In this case, the `printf` function is used, which can lead to format string vulnerabilities if user-controlled input is passed as the format string argument.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `printf`, use `cout` for output. Always validate and sanitize user input before processing it.\n\n## Source Code Fix Recommendation\n\nReplace the `printf` function with `cout` as follows:\n\n```cpp\n#include <iostream>\n\nint main() {\n    std::cout << \"note that the nearest neighbor is not at \"\n              << \"distance 0 due to quantization errors\\n\";\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- iostream\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1312d87a-dcf7-3c60-bd21-7c52db2a9a82",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string is not controlled by the programmer or if user-supplied data is used as a format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For the `printf` function, consider using `fprintf` or `snprintf` instead, which are safer as they allow you to specify the maximum number of characters to be written to the buffer, thus preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s] Searching the %d nearest neighbors \"\n               \"of %ld vectors in the index\\n\",\n               elapsed() - t0,\n               k,\n               nq);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for the `snprintf` function.\n- Any libraries required by the `elapsed` function, which is not shown in the code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6f516fa6-906a-3890-8278-c668a4a7c528",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string is not controlled by the programmer or if user-supplied data is used as a format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For the `printf` function, consider using `fprintf` or `snprintf` instead, which are safer as they allow you to specify the maximum number of characters to be written to the buffer, thus preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s] Searching the %d nearest neighbors \"\n               \"of %ld vectors in the index\\n\",\n               elapsed() - t0,\n               k,\n               nq);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for the `snprintf` function.\n- Any libraries required by the `elapsed` function, which is not shown in the code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "657350d1-8bc0-322f-a67e-df7d33a003dd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of potentially dangerous C functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `printf` function is used, which can lead to format string vulnerabilities if not used properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `printf` such as `cout` in C++. If `printf` must be used, ensure that the format string does not contain any user-supplied input to prevent format string vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `cout`:\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cinttypes>\n\nint64_t n_add;\nint64_t n;\n\n// ...\n\nstd::cout << \"IndexBinaryIVF::add_with_ids: added \" << n_add << \" / \" << n << \" vectors\\n\";\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<iostream>` for `std::cout`\n- `<cstdint>` for `int64_t`\n- `<cinttypes>` for `PRId64`\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c4b8cb65-7040-32ca-8b1f-b269c41a31fd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which is a prohibited function because it does not perform any error checking and can lead to integer overflow.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform error checking. For example, instead of `atoi()`, you can use `strtol()` which allows you to check for errors.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for strtol and errno\n#include <cerrno> // for errno\n#include <climits> // for LONG_MAX and LONG_MIN\n\nchar *end;\nlong the_with_weights = strtol(argv[2], &end, 10);\n\nif (end == argv[2] || *end != '\\0' || errno == ERANGE || the_with_weights > INT_MAX || the_with_weights < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()` and `errno`\n- `<cerrno>`: for `errno`\n- `<climits>`: for `LONG_MAX` and `LONG_MIN`\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)\n- [CWE-807: Reliance on Untrusted Inputs in a Security Decision](https://cwe.mitre.org/data/definitions/807.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4ab8e6b3-9cfd-37c5-9f7c-8fb7ef5eb6f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\nThe `atoi()` function converts a string to an integer. It does not check for overflow or underflow, and it does not report errors. This can lead to unexpected behavior if the string cannot be represented as an integer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `atoi()` and instead use functions that perform error checking, such as `strtol()`. You should also validate all input to ensure it is within the expected range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`, which allows for error checking. Here is an example of how you can do this:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong the_index_num = strtol(argv[1], &endptr, 10);\n\nif (errno == ERANGE) {\n    // handle overflow or underflow\n} else if (endptr == argv[1]) {\n    // handle no digits were found\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This header file is needed for the `strtol()` function.\n- `<cerrno>`: This header file is needed to check for overflow or underflow errors.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c2989b22-2162-30cd-9e07-b331bcf4ca56",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as 'GENUINE', and the classification explicitly states there is a risk of undefined behavior. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, the source pointer may be null, which further increases the risk of runtime errors. There are no explicit guards or checks to prevent these issues, and the destination buffer's capacity is not clearly defined or enforced. These factors indicate a real and actionable security or correctness issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. For example, change the code to:\n\n```cpp\nmemmove(dst + sw.i0, src + s1t.i0, s1t.len() * sizeof(dst[0]));\n```\n\nThis ensures that the copy operation works correctly even if the source and destination ranges overlap. Additionally, consider adding checks to ensure that the source pointer is not null before performing the operation to avoid potential null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d1ef891d-f844-3b7e-86e8-9d5d3cf2e658",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the source and destination may reference overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, the analysis could not rule out the possibility that the source pointer is null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the source and destination are distinct or that the source is non-null. These factors make this a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with a function that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy` for this purpose. `memmove` is designed to correctly handle overlapping memory areas.\n\n**Remediation Example:**\n\n```cpp\nmemmove(dst + sw.i0, src + s2t.i0, s2t.len() * sizeof(dst[0]));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a9b0252b-ddfc-3031-92bd-7812e523b672",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of memory corruption. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string is not controlled by the programmer or if user-supplied data is used as a format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, you can use `fprintf` or `snprintf` which are safer as they limit the number of characters to be written to the string, thus preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdio>\n#include <ctime>\n\nlong k = 10;\nlong nq = 20;\ndouble t0 = static_cast<double>(std::clock()) / CLOCKS_PER_SEC;\n\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s] Preparing auto-tune criterion 1-recall at 1 \"\n               \"criterion, with k=%ld nq=%ld\\n\",\n               static_cast<double>(std::clock()) / CLOCKS_PER_SEC - t0,\n               k,\n               nq);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdio>`: For the `snprintf` function.\n- `<ctime>`: For the `std::clock` function and `CLOCKS_PER_SEC` constant.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5889f598-58ef-3ece-885c-6d0bc4695919",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In C++, the Standard Template Library (STL) provides many safe alternatives. For example, instead of `memmove`, you can use `std::copy` or `std::copy_backward` from `<algorithm>` library.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy` or `std::copy_backward`. Here is how you can do it:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy_backward(x + 1 + i * (d + 1), x + 1 + i * (d + 1) + d, x + i * d + d);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for `memmove` function and `<algorithm>` library for `std::copy_backward` function.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2879a931-9b2f-3f6b-a5d0-17b50a483c90",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if the `fname` parameter is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation and sanitization. In the case of `fopen`, it is important to ensure that the `fname` parameter does not contain any malicious input that could lead to a file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::string fname;\n// ... (set fname to the desired file name)\nstd::ifstream f(fname);\nif (!f.is_open()) {\n    // handle error\n}\n```\n\nIn this fixed code, the C++ `std::ifstream` class is used instead of the C `fopen` function. This class automatically handles many of the potential issues with `fopen`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n* `<fstream>`\n\n## References\n\n* [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/CPlusPlus_Security_Cheat_Sheet.html)\n* [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fb490795-5ea5-3a80-8315-114ea79edf3c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858",
                  "fb490795-5ea5-3a80-8315-114ea79edf3c"
                ]
              }
            },
            {
              "id": "1970ef80-8756-33cd-8edd-1ae8241e91e6",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0c693dc4-3161-3484-bee7-077f9c8d07a8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858",
                  "0c693dc4-3161-3484-bee7-077f9c8d07a8"
                ]
              }
            },
            {
              "id": "c2320358-484a-331b-afc2-ac578f490ddd",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions. Additionally, there is a possibility that the source pointer could be null at this point, as there is no prior check ensuring it is non-null. The destination is not likely to be null, as it appears to be a local or field array. No explicit bounds or capacity checks are present, and the size of the copy is not derived from the destination's capacity. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the regions overlap. Additionally, ensure that the source pointer is not null before performing the copy to avoid a potential null pointer dereference.\n\n```cpp\nif (invlists->get_single_code(list_no, offset) != nullptr) {\n    memmove(recons, invlists->get_single_code(list_no, offset), code_size);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a340474d-4cbb-3602-b42e-9482dca16374",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "040a2dc1-0572-38e0-a7cd-8d1bfc044606",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string is not controlled by the programmer or if user-supplied data is used as a format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For the `printf` function, consider using `fprintf` or `snprintf` instead, which are safer as they allow you to specify the maximum number of characters to be written to the buffer, thus preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s] Searching the %d nearest neighbors \"\n               \"of %ld vectors in the index\\n\",\n               elapsed() - t0,\n               k,\n               nq);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for the `snprintf` function.\n- Any libraries required by the `elapsed` function, which is not shown in the code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c37089a3-d4fa-388a-b284-3f3adfd9c8ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "66658faa-f663-3164-9e71-c05a30fb45a9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858",
                  "66658faa-f663-3164-9e71-c05a30fb45a9"
                ]
              }
            },
            {
              "id": "336fe975-41e7-3c03-9422-77e7974c1cef",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "52838f58-5738-3242-8fe2-dc5141665f38",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858",
                  "52838f58-5738-3242-8fe2-dc5141665f38"
                ]
              }
            },
            {
              "id": "61adee8f-d8bc-3e74-ba11-3a9f38a0c2a6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "bc801d8b-5090-34e4-925c-5caf855470e8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "5f8dfa34-d2c8-3925-84da-d3765f5e0e3c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "65683616-7ceb-3963-b010-176378ea4876",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ef9ecb8b-a49d-3647-9324-be5d800db9ea",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are both pointers, and dataflow analysis suggests that the destination may be derived from the source, which can lead to overlapping memory regions. The use of a memory copy function in such a scenario can result in unpredictable program behavior. Additionally, there is no evidence of a guard to ensure the source is non-null, further increasing the risk. The destination is not likely to be null, but the source may be, which could also cause a crash. The count argument is not directly tied to the destination's capacity, and there are no explicit checks or null-terminations present. All these factors indicate a high-confidence, actionable issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between regions that may overlap, use a memory move function that is designed to handle overlapping regions safely. Replace the memory copy function with a memory move function, such as `memmove`, which guarantees correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(centroids, clus.centroids.data(), sizeof(*centroids) * d * k);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation:\n\n```cpp\nif (centroids != nullptr && clus.centroids.data() != nullptr) {\n    memmove(centroids, clus.centroids.data(), sizeof(*centroids) * d * k);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "40d8f07d-9fa3-3702-ba13-453d9d3b27ff",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858",
                  "40d8f07d-9fa3-3702-ba13-453d9d3b27ff"
                ]
              }
            },
            {
              "id": "f86b4bde-76b5-330e-be4b-e1df472f521f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858",
                  "f86b4bde-76b5-330e-be4b-e1df472f521f"
                ]
              }
            },
            {
              "id": "eb1ea63a-f4fc-30e3-8032-82abe2e5c37b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "be0b4abd-1d50-3a46-86a3-f73ec90e7a02",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "cd3bf0fc-8fcb-3aa3-921f-78b2185cfb52",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "61c3fa46-0a81-3ded-a1e7-0cbf4f360faf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858",
                  "61c3fa46-0a81-3ded-a1e7-0cbf4f360faf"
                ]
              }
            },
            {
              "id": "9299837b-e3e7-3f4e-b6db-acec9e402046",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "93440079-6472-3e06-aab5-b8afa921cff8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c255e29d-9751-3eb3-96bf-6aeff6b800bd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858",
                  "c255e29d-9751-3eb3-96bf-6aeff6b800bd"
                ]
              }
            },
            {
              "id": "48692864-6b2a-3762-a426-6c10a066f033",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "68bb3da6-434b-3763-af41-748812862ed2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "b4a529b3-74d5-3f92-b052-d4f62e311ee0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "42d0c4a1-f202-3829-8c20-68f480447cfb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "da45c7af-ae85-35dd-bdeb-6b2c7389070a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code example `memcpy(u8, ptr, 32)`, if the size of `u8` is less than 32 bytes, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code example:\n\n```cpp\nif (sizeof(u8) >= 32) {\n    memcpy(u8, ptr, 32);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if the size of `u8` is at least 32 bytes before calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ea226d7f-9b3a-3538-996d-a71b2c675547",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fprintf` function is used, which can lead to format string vulnerabilities if user-controlled input is passed as the format string parameter.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `fprintf`, you can use `std::cerr` for error output in C++. \n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <iostream>\n\nstd::cerr << \"WARNING: NNDescent does not support dynamic insertions, multiple insertions would lead to re-building the index\" << std::endl;\n```\n\n## Library Dependencies\n\nThe original code requires the following library:\n\n- `stdio.h`\n\nThe fixed code requires the following library:\n\n- `iostream`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "314035f7-9649-302b-a63d-a5c21b54c13e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Found\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if not used carefully.\n\nFormat string vulnerabilities occur when the format string passed to `printf` (or similar functions) is not a constant, but is instead constructed from user input. This can allow an attacker to perform arbitrary code execution, crash the program, or read from arbitrary memory locations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not interpret their input as a format string, such as `puts` or `fputs`.\n\nIf you must use `printf`, ensure that the format string is a constant and does not contain any user-supplied data. If you need to include user-supplied data in the output, use `%s` and pass the data as an argument, which will ensure it is properly sanitized.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdio>\n\n// ...\n\nstd::printf(\"hnsw_add_vertices: adding %zd elements on top of %zd (preset_levels=%d)\\n\", n, n0, static_cast<int>(preset_levels));\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`: This library provides facilities for performing input and output, including the `printf` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "76a2213e-9de5-39cb-96b8-ade4f56ef25a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "377f7004-546d-3dd9-a52f-8f4208f6e90a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "b9e0180f-0caa-33a3-9dda-38e223b7465a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code example `memcpy(u8, x, 32)`, if the size of `x` is larger than the size of `u8`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code, potentially gaining unauthorized access to the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code example:\n\n```cpp\nif(sizeof(u8) >= 32) {\n    memcpy(u8, x, 32);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if the size of `u8` is at least 32 before calling `memcpy`. If `u8` is not large enough, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code example.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "33738c62-12bb-3d8a-8fff-b56aa81a315f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "966568b5-d63b-3190-a055-a35507bef0d4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "0b79b6d8-127b-303a-adad-eb079c883444",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "62a53627-6b59-3f69-9d5e-87a3e13c3e38",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "62d96ae8-9ad6-3890-9544-8435b41852e2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4f9f6ccf-6eaf-31de-b069-e5a191a99b7b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "66085b83-2001-397a-a1fd-229a1b75ab05",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "57102ed5-1506-320a-8c40-e4297169239d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code example `memcpy(ptr, u8, 32)`, if the size of `ptr` is less than 32 bytes, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAlso, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11) which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `strncpy`:\n\n```cpp\nchar ptr[32];\nstrncpy(ptr, u8, sizeof(ptr));\nptr[sizeof(ptr) - 1] = '\\0'; // Ensure null-termination\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "53eec251-26af-3b31-a2e9-c9dcbec57443",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory areas, as indicated by the data flow analysis. Additionally, there is a possibility that either the source or destination pointer could be null, and there are no explicit checks or guards in place to prevent this. The operation does not use a count or length derived from the destination's capacity, and the function call is not protected by any guard conditions. All these factors increase the likelihood of a real issue that could lead to memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the source and destination overlap.\n\n```cpp\nmemmove(tmp2.get() + i * cs2, bytes + i * (cs1 + cs2), cs2);\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the operation:\n\n```cpp\nif (tmp2.get() && bytes) {\n    memmove(tmp2.get() + i * cs2, bytes + i * (cs1 + cs2), cs2);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "758a599d-efc8-3474-9a29-7fa5b4bdb1bf",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from potentially overlapping regions, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The classification specifically highlights undefined behavior risk, and the verdict confirms this is a high-confidence issue. These factors indicate a real and actionable problem that should be addressed to ensure memory safety and program correctness.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(b + cs1, tmp2.get() + cs2 * i, cs2);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. If there is any chance that `tmp2.get()` could be null, add a check before the copy:\n\n```cpp\nif (tmp2.get() != nullptr) {\n    memmove(b + cs1, tmp2.get() + cs2 * i, cs2);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "65ce472d-9ffe-31f2-9bc9-28a6b3b1930d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the data being copied is not checked before the `memcpy` operation, which can lead to a buffer overflow if the size of `ds` is larger than the size of `bytes`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data before the `memcpy` operation. If the size of the data is larger than the size of the destination buffer, do not perform the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <cstring> // for memcpy\n#include <cstdlib> // for malloc\n\nchar* bytes = (char*) malloc(sizeof(char) * 10); // allocate memory for bytes\nchar* ds = \"1234567890\"; // data to be copied\n\nif (sizeof(ds) <= sizeof(bytes)) {\n    memcpy(bytes, ds, sizeof(char) * 10); // copy data\n} else {\n    // handle error\n}\n```\n\nIn this fixed code, we first check if the size of `ds` is less than or equal to the size of `bytes` before performing the `memcpy` operation.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n- `<cstdlib>`: This library is required for the `malloc` function.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "388b1ae6-fc83-33d6-80a7-9c5729ee0295",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This is further supported by the explicit note that overlap is feasible, and this was determined through data flow analysis. Additionally, there is a risk that the source pointer may be null at this point in the code, as there is no prior check ensuring it is non-null. The destination pointer is less likely to be null, but the main concern is the undefined behavior from overlapping memory regions. The function used for copying does not handle overlapping memory safely, which can lead to unpredictable results or security vulnerabilities. These factors indicate a high likelihood that this is a real and actionable issue.\n\n## In Context Remediation 0\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, `memmove` is designed for this purpose. Change the code to use `memmove` instead of `memcpy`:\n\n```cpp\nmemmove(b, tmp1.get() + cs1 * i, cs1);\n```\n\nThis ensures that the copy operation is performed correctly even if the source and destination regions overlap, eliminating the risk of undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## In Context Remediation 1\nAdditionally, ensure that the source pointer is not null before performing the memory copy. Add a check before the operation:\n\n```cpp\nif (tmp1.get() != nullptr) {\n    memmove(b, tmp1.get() + cs1 * i, cs1);\n}\n```\n\nThis prevents dereferencing a null pointer, which could otherwise lead to a crash or further undefined behavior.\n\n## References\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "69efe4ac-5a9c-310b-a92a-26c514b32635",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, you can use `fprintf` or `snprintf` which are safer as they limit the number of characters to be printed, thus preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdio>\n#include <cinttypes>\n\n// ...\n\nfprintf(stdout, \"MultiIndexQuantizer::search: %\" PRId64 \":%\" PRId64\n                       \" / %\" PRId64 \"\\n\",\n                       i0,\n                       i1,\n                       n);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdio>`: Provides the `fprintf` function.\n- `<cinttypes>`: Provides the `PRId64` macro for printing `int64_t` values.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8ff0a4bd-2348-3885-ba75-821957064ecf",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The use of a raw memory copy function without explicit checks for overlap or null pointers increases the risk of subtle bugs or security issues. These factors indicate a high-confidence, actionable issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with a function that safely handles overlapping regions, such as `memmove`. Additionally, ensure that the source pointer is not null before performing the copy to avoid potential crashes.\n\n```cpp\nif (xsrc != nullptr) {\n    memmove(xdest, xsrc, dsub * sizeof(xdest[0]));\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap, and it avoids dereferencing a null pointer. For further information, see the following resources:\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "52613f04-ff2b-3e97-8c27-2429f8f1bc0c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer, and the source is obtained from a function call, with dataflow analysis indicating that the source and destination may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent null pointers for the source, increasing the risk of undefined behavior. The verdict is supported by the high-confidence classification and the explicit 'GENUINE' verdict from the analysis. These factors indicate a real risk of memory corruption or program crashes if the overlap or null pointer conditions occur.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer returned by `pq.get_centroids(m, n)` is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (recons != nullptr && pq.get_centroids(m, n) != nullptr) {\n    memmove(recons, pq.get_centroids(m, n), sizeof(recons[0]) * pq.dsub);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e7edc16f-c9d6-3a44-9323-61691bc8fa6b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Found\" vulnerability refers to the use of insecure C functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, and integer overflows. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string contains user-supplied data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to the `printf` function that do not interpret the format string. For example, you can use the `puts` or `fputs` function for printing strings, or the `snprintf` function for formatted output.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdio>\n#include <cinttypes>\n\n// ...\n\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"training %zdx%zd 2nd level PQ quantizer on %\" PRId64 \" %dD-vectors\\n\",\n         refine_pq.M,\n         refine_pq.ksub,\n         n,\n         d);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdio>`: for the `snprintf` and `puts` functions.\n- `<cinttypes>`: for the `PRId64` macro.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a2a5ae12-f543-30b4-8e62-78cc0c802cae",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string contains user-supplied data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using unsafe C functions like `printf`. Instead, use safer alternatives that perform bounds checking or do not interpret format strings. For example, consider using `snprintf` or `fprintf` instead of `printf`. Also, never include user-supplied data in the format string of a `printf`-like function.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `snprintf`:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"PQ training on %\" PRId64 \" points, remains %\" PRId64\n                   \" points: \"\n                   \"training polysemous on %s\\n\",\n                   n - ntrain_perm,\n                   ntrain_perm,\n                   ntrain_perm == 0 ? \"centroids\" : \"these\");\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdio.h` for `printf` or `snprintf`\n- `inttypes.h` for `PRId64`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a3158f47-333d-37fb-9664-b492fd9ec4e4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to ensure that the source pointer is not null, which further increases the risk. The destination is a pointer type, and there is no information about its capacity or bounds checking. These factors together indicate a high likelihood of a real issue that could lead to undefined behavior, memory corruption, or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(bytes, x, sizeof(float) * d * n);\n```\n\nAdditionally, add checks to ensure that the source pointer is not null before performing the copy:\n\n```cpp\nif (x != nullptr) {\n    memmove(bytes, x, sizeof(float) * d * n);\n}\n```\n\nThis approach eliminates the risk of undefined behavior due to overlapping memory and null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "67227c77-9f64-32d0-8505-d3f16f997747",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior when using memory copy functions like memcpy. Additionally, there is no evidence of a guard to prevent null pointers for the source, increasing the risk of a crash or further undefined behavior. The destination is a pointer, and there is no information about its capacity or bounds checking. These factors together make this a high-confidence, actionable issue that should be addressed to ensure memory safety.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(x, bytes, sizeof(float) * d * n);\n```\n\nAdditionally, ensure that both `x` and `bytes` are not null before the call to avoid null pointer dereference:\n\n```cpp\nif (x != nullptr && bytes != nullptr) {\n    memmove(x, bytes, sizeof(float) * d * n);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d7ed3af0-f9f8-3a38-80fb-0bbcd1144b49",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be risky due to their potential to cause buffer overflow, format string vulnerabilities, or other issues. These functions often do not perform bounds checking or input validation, which can lead to serious security vulnerabilities if not handled properly. In this case, the `memmove` function is used, which can lead to buffer overflow if the size of the destination buffer is smaller than the size of the source buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these risky C functions. For instance, instead of using `memmove`, you can use `std::copy` or `std::copy_n` from the `<algorithm>` library in C++, which are safer as they work with iterators rather than raw pointers.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `std::copy_n`:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy_n(&A[i * d], d_in, &A[i * d_in]);\n```\n\n## Library Dependencies\n\nThe code example requires the `<algorithm>` library for `std::copy_n`.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest and most reliable resources for secure coding practices."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "152df44a-3397-37bd-963d-7e6c0390c27c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. In the provided code, the `printf` function is used, which can lead to format string vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, you can use `fprintf` or `snprintf` which are safer as they limit the number of characters to be printed, thus preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"    Iteration %d (%d PQ iterations): %.3f s, obj=%g\\n\", iter, pq_regular.cp.niter, (getmillisecs() - t0) / 1000.0, pq_err);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for `printf`, `snprintf`, and `puts`\n- `<time.h>` if `getmillisecs` is a function that gets the current time in milliseconds\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "65b46005-159e-3c4b-9c0f-6b1c0ddee979",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `printf` such as `snprintf` or `fprintf`. These functions provide the same functionality but include additional parameters to specify the size of the output buffer, reducing the risk of buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `snprintf`:\n\n```cpp\n#include <cstdio>\n#include <cinttypes>\n\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"OPQMatrix::train: training an OPQ rotation matrix \"\n               \"for M=%d from %\" PRId64 \" vectors in %dD -> %dD\\n\",\n               M,\n               n,\n               d_in,\n               d_out);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<cstdio>`: Provides the `snprintf` function.\n- `<cinttypes>`: Provides the `PRId64` macro for printing `int64_t` values.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "26bda864-deb0-3fe7-9bbb-413c237fc3d1",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7b1488f8-4a99-356b-9729-ad6a88078f11",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected, through data flow, that the destination and source may refer to overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, the source pointer may be null at this call site, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly defined or checked. These factors all contribute to the assessment that this is a real and actionable issue that could lead to program crashes or unpredictable behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. \n\n**Remediation example:**\n\n```cpp\nmemmove(recons, &(codes[key * code_size]), code_size);\n```\n\nThis change ensures that even if the source and destination regions overlap, the copy will be performed correctly without causing undefined behavior.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6421bb04-abd0-3cb4-af94-dbf5cb46b341",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the operation copies memory from one location to another using a function that is not safe when the source and destination memory regions overlap. The analysis detected that the source and destination may refer to overlapping memory regions due to data flow between them, which can result in undefined behavior. Additionally, there is a risk that the source pointer may be null at this point in the code, as there is no prior check ensuring it is valid. The destination is less likely to be null, but the primary concern is the potential for undefined behavior due to overlapping memory regions. No explicit bounds or null-termination protections are present, and the function used does not handle overlap safely.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, `memmove` is designed for this purpose. Replace the original memory copy call with `memmove` to ensure correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(x, xt, sizeof(xt[0]) * n * d_in);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid (not null) before performing the operation. For example:\n\n```cpp\nif (x != nullptr && xt != nullptr) {\n    memmove(x, xt, sizeof(xt[0]) * n * d_in);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b9437365-b71d-3619-85cd-9755c3d6e132",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard to prevent null pointers for the source, which increases the risk of undefined behavior. The classification explicitly states a risk of undefined behavior due to possible overlap, and the verdict confirms this as a genuine issue. Developers should be aware that using memory copy functions like memcpy with overlapping regions can lead to unpredictable results, and that null pointer dereference is also possible in this context.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original memory copy call with the following:\n\n```cpp\nmemmove(xt, x, sizeof(x[0]) * n * d_in);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (x != nullptr) {\n    memmove(xt, x, sizeof(x[0]) * n * d_in);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1ec83b91-c85f-3c39-98bb-7bb2af23d59f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "853e9c18-a99f-30e2-96db-c506dfa67d79",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may refer to overlapping memory areas, which is not allowed for the standard memory copy function used here. The risk is further supported by the fact that the verdict is marked as genuine. There are no explicit checks or guards in the code to prevent this overlap, and the dataflow analysis confirms the possibility of overlap. While both the source and destination are confirmed to be non-null before the call, the main concern is the potential for undefined behavior if the memory regions overlap.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C and C++, use the memory move function instead of the memory copy function. This ensures correct behavior even if the source and destination regions overlap.\n\n```cpp\n// Replace memcpy with memmove to safely handle overlapping regions\nmemmove(rotation.data(), init_rotation.data(), d * d * sizeof(rotation[0]));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b68dfac8-504e-30c8-a6bf-804008e22e38",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"quantizer_\")` is used to determine the length of a constant string. This is not a vulnerability per se, but it's a bad practice because the length of a constant string can be determined at compile time, making the use of `strlen` unnecessary and inefficient.\n\n## Mitigation Advice\n\nAvoid using `strlen` to determine the length of constant strings. Instead, use the `sizeof` operator, which can determine the length at compile time, or simply hard-code the length if it's known.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(\"quantizer_\")` with `sizeof(\"quantizer_\") - 1` or `10` (the actual length of the string \"quantizer_\").\n\n```cpp\nsub_name = name.substr(sizeof(\"quantizer_\") - 1);\n```\n\nor\n\n```cpp\nsub_name = name.substr(10);\n```\n\n## Library Dependencies\n\nThe code snippet requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "7e5e844a-37e5-3172-958c-ab9d50f7c36a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `fopen` is used, which can lead to vulnerabilities if the `fname` parameter is not properly validated or sanitized. An attacker could potentially manipulate the `fname` to overwrite files or to access sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation and sanitization. In the case of `fopen`, it is important to ensure that the `fname` parameter is a valid and safe file name. This can be done by checking that the file name does not contain any special characters or sequences that could be used to traverse directories, such as \"../\".\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::string fname = \"filename.txt\";\nstd::ofstream f(fname);\nif (!f) {\n    // Handle error\n}\n```\n\nIn this fixed code, the C++ `ofstream` class is used instead of `fopen`. This class automatically handles many of the potential issues with `fopen`, making it a safer alternative.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n* `<fstream>`\n\n## References\n\n* [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n* [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "44c1fe05-e811-32ae-a18a-295bd46cb975",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `fopen` is used, which can lead to vulnerabilities if the `fname` parameter is not properly validated or sanitized. An attacker could potentially manipulate the `fname` to overwrite files or to access sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation and sanitization. In the case of `fopen`, it is important to ensure that the `fname` parameter is a valid and safe file name. This can be done by checking that the file name does not contain any special characters or sequences that could be used to traverse directories, such as \"../\".\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::string fname = \"filename.txt\";\nstd::ofstream f(fname);\nif (!f) {\n    // Handle error\n}\n```\n\nIn this fixed code, the C++ `ofstream` class is used instead of `fopen`. This class automatically handles many of the potential issues with `fopen`, making it a safer alternative.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n* `<fstream>`\n\n## References\n\n* [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n* [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9d00d977-abf5-3258-a265-b819af69b4d7",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fprintf` function is used, which can lead to format string vulnerabilities if the format string is not controlled or if user-supplied data is used as a format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `fprintf`, consider using `fputs` or `fwrite`. If `fprintf` must be used, ensure that the format string is a constant and does not contain any user-supplied data.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code:\n\n```cpp\nint info = /* some value */;\nconst char* message = \"WARN ssyev info returns %d, a very bad PCA matrix is learnt\\n\";\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), message, info);\nfputs(buffer, stderr);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for `fprintf` and `stderr`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2a911b2a-91cc-3b8f-8da6-c0c27c8e93c2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from potentially overlapping regions of the same or related arrays, as indicated by the dataflow analysis. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. The risk is further increased because the operation does not use a function that is safe for overlapping memory regions, such as memmove.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that is safe for overlapping regions, such as `memmove`. This ensures correct behavior even if the regions overlap.\n\n```cpp\nmemmove(&A[row_dst * d_in], &Ain[i * d_in], d_in * sizeof(A[0]));\n```\n\nAdditionally, ensure that the source pointer is not null before performing the operation:\n\n```cpp\nif (&Ain[i * d_in] != nullptr) {\n    memmove(&A[row_dst * d_in], &Ain[i * d_in], d_in * sizeof(A[0]));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3fe1bef2-9c7b-395b-84b4-9b822b48894d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"quantizer_\")` is used to determine the length of a constant string. This is not a vulnerability per se, but it's a bad practice because the length of a constant string can be determined at compile time, making the use of `strlen` unnecessary and inefficient.\n\n## Mitigation Advice\n\nAvoid using `strlen` to determine the length of constant strings. Instead, use the `sizeof` operator, which can determine the length at compile time, or simply hard-code the length if it's known.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(\"quantizer_\")` with `sizeof(\"quantizer_\") - 1` or `10` (the actual length of the string \"quantizer_\").\n\n```cpp\nsub_name = name.substr(sizeof(\"quantizer_\") - 1);\n```\n\nor\n\n```cpp\nsub_name = name.substr(10);\n```\n\n## Library Dependencies\n\nThe code snippet requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "23bbf271-a5c1-384a-a122-ab4cae62c798",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination pointers are non-null before the operation, increasing the risk of null pointer dereference. The count argument is calculated dynamically and is not directly tied to the capacity of the destination buffer, which further increases the risk. All these factors indicate a real and actionable issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Additionally, add explicit checks to ensure that both the source and destination pointers are not null before performing the copy operation.\n\n```cpp\nif (gt_I.data() != nullptr && gt_I_in != nullptr) {\n    memmove(gt_I.data(), gt_I_in, sizeof(gt_I[0]) * nq * gt_nnn);\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap, and it avoids null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "457753e3-3a9a-35f4-88ae-6b17fa8d6672",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the `memmove` function is used, which can lead to buffer overflow if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions whenever possible. For instance, instead of `memmove`, consider using `std::copy` from the C++ Standard Library, which is type-safe and less prone to errors.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy`. Here is how you can do it:\n\n```cpp\n#include <algorithm> // for std::copy\n\n// ...\n\nstd::copy(codes + i * code_size, codes + i * code_size + code_size, code + coarse_size);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memmove`\n- `<algorithm>` for `std::copy`\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9129d0a7-d49f-3420-9126-8858befd8dd8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if not used carefully.\n\nFormat string vulnerabilities occur when the format string passed to `printf` (or similar functions) is not a constant, but is instead constructed from user input. This can allow an attacker to perform arbitrary code execution, read the stack, or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use functions that do not interpret the format string, such as `puts` or `fputs`.\n\nIf `printf` or similar functions must be used, ensure that the format string is a constant and does not contain any user-supplied data. Additionally, always specify the correct format specifiers for the arguments.\n\n## Source Code Fix Recommendation\n\nThe provided code can be fixed by replacing the `printf` function with `puts` or `fputs`. However, since the format of the output is complex, it may be more practical to ensure that the format string is a constant and that the correct format specifiers are used.\n\n```cpp\nprintf(\"training %zdx%zd product quantizer on %\" PRId64 \" vectors in %dD\\n\", pq.M, pq.ksub, n, d);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cinttypes>`: for the `PRId64` macro.\n- `<cstdio>`: for the `printf` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "07d44a22-be0d-3b9e-bba8-bd681389267a",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may overlap based on data flow analysis, which can lead to unpredictable results or program crashes when using functions like memcpy that do not support overlapping regions. There are no explicit checks or guards in the code to prevent this overlap, and neither the source nor the destination is null at the call site, which means the operation will proceed and potentially trigger undefined behavior. The risk is further confirmed by the verdict marking this as a genuine issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not result in unpredictable behavior if the regions overlap.\n\n```cpp\nmemmove(gt_D.data(), gt_D_in, sizeof(gt_D[0]) * nq * gt_nnn);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "829d1dd4-e357-3254-a241-891b8e5a8158",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 765,
                  "startColumn": 61,
                  "endLine": 765,
                  "endColumn": 69,
                  "charOffset": 21647,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1d886a41-cf71-3977-abb2-58039de5f671",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 730,
                  "startColumn": 12,
                  "endLine": 730,
                  "endColumn": 18,
                  "charOffset": 20492,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bd247ac0-9838-3c52-b1d8-36a7df58ed5d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/BlockInvertedLists.cpp"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 4,
                  "endLine": 52,
                  "endColumn": 54,
                  "charOffset": 1419,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])",
                    "rendered": {
                      "text": "memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])",
                      "markdown": "`memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/BlockInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1419,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ids[list_no][o], <size of &ids[list_no][o]>,  ids_in,  sizeof(ids_in[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "11784b33-ea2d-3411-b7a4-9b55e3fb520c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 648,
                  "startColumn": 4,
                  "endLine": 648,
                  "endColumn": 50,
                  "charOffset": 17839,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(new_lists.data(), &lists[l0], (l1 - l0)",
                    "rendered": {
                      "text": "memcpy(new_lists.data(), &lists[l0], (l1 - l0)",
                      "markdown": "`memcpy(new_lists.data(), &lists[l0], (l1 - l0)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17839,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_lists.data(), <size of new_lists.data()>,  &lists[l0],  (l1 - l0)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8c89d273-2481-32bb-836a-44ffb7f16096",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/BlockInvertedLists.cpp"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 8,
                  "endLine": 57,
                  "endColumn": 74,
                  "charOffset": 1667,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&codes[list_no][o * code_size], code, n_block * block_size)",
                    "rendered": {
                      "text": "memcpy(&codes[list_no][o * code_size], code, n_block * block_size)",
                      "markdown": "`memcpy(&codes[list_no][o * code_size], code, n_block * block_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/BlockInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1667,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&codes[list_no][o * code_size], <size of &codes[list_no][o * code_size]>,  code,  n_block * block_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "146d6b8d-9500-30e4-acbf-b793742fe9fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 471,
                  "startColumn": 12,
                  "endLine": 473,
                  "endColumn": 36,
                  "charOffset": 13270,
                  "charLength": 129,
                  "snippet": {
                    "text": "memcpy(ptr + new_l.offset + new_l.capacity * code_size,\n                   get_ids(list_no),\n                   n * sizeof(idx_t)",
                    "rendered": {
                      "text": "memcpy(ptr + new_l.offset + new_l.capacity * code_size,\n                   get_ids(list_no),\n                   n * sizeof(idx_t)",
                      "markdown": "`memcpy(ptr + new_l.offset + new_l.capacity * code_size,\n                   get_ids(list_no),\n                   n * sizeof(idx_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13270,
                        "charLength": 129
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr + new_l.offset + new_l.capacity * code_size, <size of ptr + new_l.offset + new_l.capacity * code_size>, \n                   get_ids(list_no), \n                   n * sizeof(idx_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9fdb8f84-49f3-3364-9160-2e20b247a0f9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 4,
                  "endLine": 415,
                  "endColumn": 69,
                  "charOffset": 11721,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(codes + offset * code_size, codes_in, code_size * n_entry)",
                    "rendered": {
                      "text": "memcpy(codes + offset * code_size, codes_in, code_size * n_entry)",
                      "markdown": "`memcpy(codes + offset * code_size, codes_in, code_size * n_entry)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11721,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codes + offset * code_size, <size of codes + offset * code_size>,  codes_in,  code_size * n_entry)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fd9b7f22-eff3-399a-94da-50a1c2e20523",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 18,
                  "endLine": 299,
                  "endColumn": 23,
                  "charOffset": 8547,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "886f4aac-e5fe-3289-a467-e133d81a4541",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 61,
                  "endLine": 295,
                  "endColumn": 69,
                  "charOffset": 8432,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f1869165-b929-3ebf-ab27-b2097321677a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 470,
                  "startColumn": 12,
                  "endLine": 470,
                  "endColumn": 73,
                  "charOffset": 13195,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(ptr + new_l.offset, get_codes(list_no), n * code_size)",
                    "rendered": {
                      "text": "memcpy(ptr + new_l.offset, get_codes(list_no), n * code_size)",
                      "markdown": "`memcpy(ptr + new_l.offset, get_codes(list_no), n * code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13195,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr + new_l.offset, <size of ptr + new_l.offset>,  get_codes(list_no),  n * code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ad1af128-cc77-3257-b9a5-1957e66c1d2f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 270,
                  "startColumn": 14,
                  "endLine": 270,
                  "endColumn": 19,
                  "charOffset": 7727,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "17c9bad1-4dfb-3ab8-be94-9df7f03d028d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 413,
                  "startColumn": 4,
                  "endLine": 413,
                  "endColumn": 50,
                  "charOffset": 11595,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(ids + offset, ids_in, sizeof(ids_in[0])",
                    "rendered": {
                      "text": "memcpy(ids + offset, ids_in, sizeof(ids_in[0])",
                      "markdown": "`memcpy(ids + offset, ids_in, sizeof(ids_in[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11595,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ids + offset, <size of ids + offset>,  ids_in,  sizeof(ids_in[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "114fa345-18d9-309b-91c9-2db23400ed96",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 278,
                  "startColumn": 12,
                  "endLine": 280,
                  "endColumn": 22,
                  "charOffset": 7937,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + qi) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + qi) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + qi) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7937,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + qi) * 32, <size of dest + (sq / 2 * nq + qi) * 32>, \n                   src + (q * nsq + sq) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b0d3fda1-07f6-33a5-9e10-70ab8481fc6d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 246,
                  "startColumn": 12,
                  "endLine": 248,
                  "endColumn": 22,
                  "charOffset": 7182,
                  "charLength": 115,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + q) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + q) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + q) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7182,
                        "charLength": 115
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + q) * 32 + 16, <size of dest + (sq / 2 * nq + q) * 32 + 16>, \n                   src + (q * nsq + sq + 1) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "730b0633-00ea-332d-881a-74012922eecc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 281,
                  "startColumn": 12,
                  "endLine": 283,
                  "endColumn": 22,
                  "charOffset": 8058,
                  "charLength": 116,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + qi) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + qi) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + qi) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8058,
                        "charLength": 116
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + qi) * 32 + 16, <size of dest + (sq / 2 * nq + qi) * 32 + 16>, \n                   src + (q * nsq + sq + 1) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "578c55e4-4d0f-3c8f-aefc-e39096208a50",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 243,
                  "startColumn": 12,
                  "endLine": 245,
                  "endColumn": 22,
                  "charOffset": 7062,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + q) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + q) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + q) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7062,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + q) * 32, <size of dest + (sq / 2 * nq + q) * 32>, \n                   src + (q * nsq + sq) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "64180376-1b1c-3b46-a98a-a43d6eacfdcc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/kmeans1d.cpp"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 8,
                  "endLine": 197,
                  "endColumn": 43,
                  "charOffset": 5261,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(centroids, x, n * sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(centroids, x, n * sizeof(*x)",
                      "markdown": "`memcpy(centroids, x, n * sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/kmeans1d.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5261,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids, <size of centroids>,  x,  n * sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fa6777c6-3a7b-3661-b932-8ef4d4b1aeac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 513,
                  "startColumn": 4,
                  "endLine": 513,
                  "endColumn": 30,
                  "charOffset": 14757,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(&norm2, &norm_i, 4)",
                    "rendered": {
                      "text": "memcpy(&norm2, &norm_i, 4)",
                      "markdown": "`memcpy(&norm2, &norm_i, 4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14757,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&norm2, <size of &norm2>,  &norm_i,  4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a2c11e15-4514-3a7c-be79-bcb17aa257ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 16,
                  "endLine": 301,
                  "endColumn": 40,
                  "charOffset": 8549,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8549,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "30394aae-25d1-396e-acb7-3a7ad1986dca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 384,
                  "startColumn": 12,
                  "endLine": 384,
                  "endColumn": 41,
                  "charOffset": 10698,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(ips, LUT, sizeof(*ips)",
                    "rendered": {
                      "text": "memcpy(ips, LUT, sizeof(*ips)",
                      "markdown": "`memcpy(ips, LUT, sizeof(*ips)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10698,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ips, <size of ips>,  LUT,  sizeof(*ips)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4f1fd3bf-2b1f-3163-b6a9-a44a10046044",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 12,
                  "endLine": 335,
                  "endColumn": 37,
                  "charOffset": 9620,
                  "charLength": 25,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*xi)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*xi)",
                      "markdown": "`memcpy(xi, c, sizeof(*xi)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9620,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*xi)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "58a11958-a1cc-3655-87a0-99e4648597d1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 28,
                  "endLine": 230,
                  "endColumn": 38,
                  "charOffset": 6047,
                  "charLength": 10,
                  "snippet": {
                    "text": "strlen(sx)",
                    "rendered": {
                      "text": "strlen(sx)",
                      "markdown": "`strlen(sx)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6047,
                        "charLength": 10
                      },
                      "insertedContent": {
                        "text": "strlen_s(sx, <size of sx>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6047,
                        "charLength": 10
                      },
                      "insertedContent": {
                        "text": "strnlen(sx, <size of sx>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b168ac0e-b0a7-3d56-8ff8-764ce3c43096",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 272,
                  "startColumn": 16,
                  "endLine": 272,
                  "endColumn": 40,
                  "charOffset": 7730,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7730,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a5d2717d-e878-33d4-bc4a-8062b34a3bbf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 8,
                  "endLine": 209,
                  "endColumn": 39,
                  "charOffset": 5537,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(buffer.data(), src, nb1)",
                    "rendered": {
                      "text": "memcpy(buffer.data(), src, nb1)",
                      "markdown": "`memcpy(buffer.data(), src, nb1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5537,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer.data(), <size of buffer.data()>,  src,  nb1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2dc4f657-1f96-3c4a-b264-85598cc8d15a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 8,
                  "endLine": 191,
                  "endColumn": 43,
                  "charOffset": 5005,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(buffer.data() + b0, src, nb)",
                    "rendered": {
                      "text": "memcpy(buffer.data() + b0, src, nb)",
                      "markdown": "`memcpy(buffer.data() + b0, src, nb)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5005,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer.data() + b0, <size of buffer.data() + b0>,  src,  nb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1836240b-80c0-30c9-ad4f-58fbb19d69a3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 198,
                  "startColumn": 12,
                  "endLine": 198,
                  "endColumn": 36,
                  "charOffset": 5148,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(&inorm, &norm, 4)",
                    "rendered": {
                      "text": "memcpy(&inorm, &norm, 4)",
                      "markdown": "`memcpy(&inorm, &norm, 4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5148,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&inorm, <size of &inorm>,  &norm,  4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9b9f1611-450e-36e8-a28d-51defe71bddc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 8,
                  "endLine": 166,
                  "endColumn": 39,
                  "charOffset": 4371,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(dst, buffer.data(), nb2)",
                    "rendered": {
                      "text": "memcpy(dst, buffer.data(), nb2)",
                      "markdown": "`memcpy(dst, buffer.data(), nb2)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4371,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  buffer.data(),  nb2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6786065e-61c7-3c7b-aca0-8deed6ba7411",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 8,
                  "endLine": 66,
                  "endColumn": 13,
                  "charOffset": 1769,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "649b1afd-bf2b-3fb8-ba10-4d6aa27fd77e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 8,
                  "endLine": 145,
                  "endColumn": 43,
                  "charOffset": 3855,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(dst, buffer.data() + b0, nb)",
                    "rendered": {
                      "text": "memcpy(dst, buffer.data() + b0, nb)",
                      "markdown": "`memcpy(dst, buffer.data() + b0, nb)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3855,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  buffer.data() + b0,  nb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dba21b98-c748-3a27-b3dd-15474d13c799",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 8,
                  "endLine": 96,
                  "endColumn": 13,
                  "charOffset": 2539,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f1085e7a-6da6-353b-a098-66c1595c91fb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 347,
                  "startColumn": 12,
                  "endLine": 347,
                  "endColumn": 46,
                  "charOffset": 10324,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(c, ScopedCodes(il, list_no)",
                    "rendered": {
                      "text": "memcpy(c, ScopedCodes(il, list_no)",
                      "markdown": "`memcpy(c, ScopedCodes(il, list_no)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10324,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c, <size of c>,  ScopedCodes(il,  list_no)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0ccc6549-8f3d-3762-9d7b-1ead0627e652",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 8,
                  "endLine": 40,
                  "endColumn": 44,
                  "charOffset": 1068,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&data[o], ptr, size * nitems)",
                    "rendered": {
                      "text": "memcpy(&data[o], ptr, size * nitems)",
                      "markdown": "`memcpy(&data[o], ptr, size * nitems)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1068,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&data[o], <size of &data[o]>,  ptr,  size * nitems)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2c46a065-6a91-3b2c-ade3-26242e1cf925",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 8,
                  "endLine": 52,
                  "endColumn": 45,
                  "charOffset": 1391,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(ptr, &data[rp], size * nitems)",
                    "rendered": {
                      "text": "memcpy(ptr, &data[rp], size * nitems)",
                      "markdown": "`memcpy(ptr, &data[rp], size * nitems)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1391,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr, <size of ptr>,  &data[rp],  size * nitems)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9a5a4676-a65d-31e5-8720-f6ad309db9ae",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 285,
                  "startColumn": 4,
                  "endLine": 285,
                  "endColumn": 78,
                  "charOffset": 8461,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(&codes[list_no][offset * code_size], codes_in, code_size * n_entry)",
                    "rendered": {
                      "text": "memcpy(&codes[list_no][offset * code_size], codes_in, code_size * n_entry)",
                      "markdown": "`memcpy(&codes[list_no][offset * code_size], codes_in, code_size * n_entry)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8461,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&codes[list_no][offset * code_size], <size of &codes[list_no][offset * code_size]>,  codes_in,  code_size * n_entry)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5ab4dc3a-fe8e-3ae3-b7b1-11d623dc9d74",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 252,
                  "startColumn": 4,
                  "endLine": 252,
                  "endColumn": 69,
                  "charOffset": 7500,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(&codes[list_no][o * code_size], code, code_size * n_entry)",
                    "rendered": {
                      "text": "memcpy(&codes[list_no][o * code_size], code, code_size * n_entry)",
                      "markdown": "`memcpy(&codes[list_no][o * code_size], code, code_size * n_entry)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7500,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&codes[list_no][o * code_size], <size of &codes[list_no][o * code_size]>,  code,  code_size * n_entry)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "08e7519f-ba1e-3f4b-8464-a45e96c0bb35",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 382,
                  "startColumn": 12,
                  "endLine": 382,
                  "endColumn": 44,
                  "charOffset": 11409,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(c, ScopedIds(il, list_no)",
                    "rendered": {
                      "text": "memcpy(c, ScopedIds(il, list_no)",
                      "markdown": "`memcpy(c, ScopedIds(il, list_no)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11409,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c, <size of c>,  ScopedIds(il,  list_no)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "43f97c64-ba69-3c56-b489-21773aca1453",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 4,
                  "endLine": 284,
                  "endColumn": 59,
                  "charOffset": 8389,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(&ids[list_no][offset], ids_in, sizeof(ids_in[0])",
                    "rendered": {
                      "text": "memcpy(&ids[list_no][offset], ids_in, sizeof(ids_in[0])",
                      "markdown": "`memcpy(&ids[list_no][offset], ids_in, sizeof(ids_in[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8389,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ids[list_no][offset], <size of &ids[list_no][offset]>,  ids_in,  sizeof(ids_in[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5733ed89-3957-3ebd-8a12-dc6f11e3f2b9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                },
                "region": {
                  "startLine": 570,
                  "startColumn": 16,
                  "endLine": 572,
                  "endColumn": 38,
                  "charOffset": 16108,
                  "charLength": 110,
                  "snippet": {
                    "text": "memcpy(best_codes.data() + i * M,\n                       codes + i * M,\n                       sizeof(int32_t)",
                    "rendered": {
                      "text": "memcpy(best_codes.data() + i * M,\n                       codes + i * M,\n                       sizeof(int32_t)",
                      "markdown": "`memcpy(best_codes.data() + i * M,\n                       codes + i * M,\n                       sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16108,
                        "charLength": 110
                      },
                      "insertedContent": {
                        "text": "memcpy_s(best_codes.data() + i * M, <size of best_codes.data() + i * M>, \n                       codes + i * M, \n                       sizeof(int32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e70516d9-65a0-3c97-97bd-ed0cf7f1f4c6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 250,
                  "startColumn": 4,
                  "endLine": 250,
                  "endColumn": 54,
                  "charOffset": 7379,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])",
                    "rendered": {
                      "text": "memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])",
                      "markdown": "`memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7379,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ids[list_no][o], <size of &ids[list_no][o]>,  ids_in,  sizeof(ids_in[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "537d19a5-2f2c-355f-afa6-a3db1a93df29",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                },
                "region": {
                  "startLine": 579,
                  "startColumn": 8,
                  "endLine": 579,
                  "endColumn": 56,
                  "charOffset": 16351,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(codes, best_codes.data(), sizeof(int32_t)",
                    "rendered": {
                      "text": "memcpy(codes, best_codes.data(), sizeof(int32_t)",
                      "markdown": "`memcpy(codes, best_codes.data(), sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16351,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codes, <size of codes>,  best_codes.data(),  sizeof(int32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3ce35f57-9bc2-3827-bb78-1cb8337ddb40",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 20,
                  "endLine": 222,
                  "endColumn": 44,
                  "charOffset": 6173,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6173,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "af03e58b-f774-367e-94e8-f95f1ff8b59e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 20,
                  "endLine": 253,
                  "endColumn": 44,
                  "charOffset": 7182,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7182,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ef78a412-d7eb-3021-8343-4edb683d13ac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 12,
                  "endLine": 173,
                  "endColumn": 39,
                  "charOffset": 4583,
                  "charLength": 111,
                  "snippet": {
                    "text": "memcpy(xsub.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xsub.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(float)",
                      "markdown": "`memcpy(xsub.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4583,
                        "charLength": 111
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xsub.data() + i * q->d, <size of xsub.data() + i * q->d>, \n                   x + i * d + offset_d, \n                   q->d * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e072c7fe-67ca-3a7a-9545-684762dd0b88",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 8,
                  "endLine": 125,
                  "endColumn": 73,
                  "charOffset": 3152,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(cb, q->codebooks.data(), sub_codebook_size * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(cb, q->codebooks.data(), sub_codebook_size * sizeof(float)",
                      "markdown": "`memcpy(cb, q->codebooks.data(), sub_codebook_size * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3152,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(cb, <size of cb>,  q->codebooks.data(),  sub_codebook_size * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "870414e2-ee65-3b68-8f12-e5d65c184d74",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 12,
                  "endLine": 106,
                  "endColumn": 36,
                  "charOffset": 2520,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(xt.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xt.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(*x)",
                      "markdown": "`memcpy(xt.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2520,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xt.data() + i * q->d, <size of xt.data() + i * q->d>, \n                   x + i * d + offset_d, \n                   q->d * sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1697bdaa-81e2-3606-8217-9dcee7c6a69d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 354,
                  "startColumn": 16,
                  "endLine": 356,
                  "endColumn": 43,
                  "charOffset": 10541,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(xslice + (i - i0) * dsub,\n                       x + i * d + m * dsub,\n                       dsub * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xslice + (i - i0) * dsub,\n                       x + i * d + m * dsub,\n                       dsub * sizeof(float)",
                      "markdown": "`memcpy(xslice + (i - i0) * dsub,\n                       x + i * d + m * dsub,\n                       dsub * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10541,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xslice + (i - i0) * dsub, <size of xslice + (i - i0) * dsub>, \n                       x + i * d + m * dsub, \n                       dsub * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "04dd7141-420f-30a5-92eb-a0da6be48a16",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NNDescent.cpp"
                },
                "region": {
                  "startLine": 137,
                  "startColumn": 4,
                  "endLine": 137,
                  "endColumn": 11,
                  "charOffset": 3609,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4fc94590-ccbf-3da5-bcd0-3627e5a6a1c4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 8,
                  "endLine": 287,
                  "endColumn": 37,
                  "charOffset": 8690,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(x + m * pq.dsub,\n               pq.get_centroids(m, c)",
                    "rendered": {
                      "text": "memcpy(x + m * pq.dsub,\n               pq.get_centroids(m, c)",
                      "markdown": "`memcpy(x + m * pq.dsub,\n               pq.get_centroids(m, c)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8690,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x + m * pq.dsub, <size of x + m * pq.dsub>, \n               pq.get_centroids(m,  c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "89b28d0d-efda-3074-87b0-7f58c40385e3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NNDescent.cpp"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 8,
                  "endLine": 111,
                  "endColumn": 15,
                  "charOffset": 2918,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c7ec45dd-3e5f-3145-abc9-3d1f90a92516",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 20,
                  "endLine": 164,
                  "endColumn": 46,
                  "charOffset": 4588,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(clus.centroids.data(),\n                           get_centroids(m, 0)",
                    "rendered": {
                      "text": "memcpy(clus.centroids.data(),\n                           get_centroids(m, 0)",
                      "markdown": "`memcpy(clus.centroids.data(),\n                           get_centroids(m, 0)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4588,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clus.centroids.data(), <size of clus.centroids.data()>, \n                           get_centroids(m,  0)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8ee942d6-d2af-381d-8f9c-678c505933f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 16,
                  "endLine": 144,
                  "endColumn": 43,
                  "charOffset": 3783,
                  "charLength": 114,
                  "snippet": {
                    "text": "memcpy(xslice + j * dsub,\n                       x + j * d + m * dsub,\n                       dsub * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xslice + j * dsub,\n                       x + j * d + m * dsub,\n                       dsub * sizeof(float)",
                      "markdown": "`memcpy(xslice + j * dsub,\n                       x + j * d + m * dsub,\n                       dsub * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3783,
                        "charLength": 114
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xslice + j * dsub, <size of xslice + j * dsub>, \n                       x + j * d + m * dsub, \n                       dsub * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "64a16ac3-1fc5-354c-9c7d-32ccab564618",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/lattice_Zn.cpp"
                },
                "region": {
                  "startLine": 632,
                  "startColumn": 12,
                  "endLine": 634,
                  "endColumn": 29,
                  "charOffset": 17273,
                  "charLength": 98,
                  "snippet": {
                    "text": "memcpy(c + i * subdim,\n                   &cache[codes[i] * subdim],\n                   sizeof(*c)",
                    "rendered": {
                      "text": "memcpy(c + i * subdim,\n                   &cache[codes[i] * subdim],\n                   sizeof(*c)",
                      "markdown": "`memcpy(c + i * subdim,\n                   &cache[codes[i] * subdim],\n                   sizeof(*c)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/lattice_Zn.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17273,
                        "charLength": 98
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c + i * subdim, <size of c + i * subdim>, \n                   &cache[codes[i] * subdim], \n                   sizeof(*c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5ea9d47f-64dd-3f55-aa04-e7203db2b072",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ScalarQuantizer.cpp"
                },
                "region": {
                  "startLine": 577,
                  "startColumn": 8,
                  "endLine": 577,
                  "endColumn": 34,
                  "charOffset": 17333,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(vmax, x, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(vmax, x, sizeof(*x)",
                      "markdown": "`memcpy(vmax, x, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ScalarQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17333,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vmax, <size of vmax>,  x,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3bbec019-e182-3e3a-8884-924dd7f0bf62",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ScalarQuantizer.cpp"
                },
                "region": {
                  "startLine": 576,
                  "startColumn": 8,
                  "endLine": 576,
                  "endColumn": 34,
                  "charOffset": 17292,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(vmin, x, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(vmin, x, sizeof(*x)",
                      "markdown": "`memcpy(vmin, x, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ScalarQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17292,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vmin, <size of vmin>,  x,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "152d10cc-34aa-3e85-ad1a-e1b6d9704173",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/lattice_Zn.cpp"
                },
                "region": {
                  "startLine": 537,
                  "startColumn": 12,
                  "endLine": 539,
                  "endColumn": 44,
                  "charOffset": 14439,
                  "charLength": 115,
                  "snippet": {
                    "text": "memcpy(&cache[i * dimsub],\n                   c.data() + dim - dimsub,\n                   dimsub * sizeof(*c.data()",
                    "rendered": {
                      "text": "memcpy(&cache[i * dimsub],\n                   c.data() + dim - dimsub,\n                   dimsub * sizeof(*c.data()",
                      "markdown": "`memcpy(&cache[i * dimsub],\n                   c.data() + dim - dimsub,\n                   dimsub * sizeof(*c.data()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/lattice_Zn.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14439,
                        "charLength": 115
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&cache[i * dimsub], <size of &cache[i * dimsub]>, \n                   c.data() + dim - dimsub, \n                   dimsub * sizeof(*c.data()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7805de82-ccb9-3258-8dba-b1999b6d2f0f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ScalarQuantizer.cpp"
                },
                "region": {
                  "startLine": 488,
                  "startColumn": 8,
                  "endLine": 488,
                  "endColumn": 47,
                  "charOffset": 14897,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(x_copy.data(), x, n * sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(x_copy.data(), x, n * sizeof(*x)",
                      "markdown": "`memcpy(x_copy.data(), x, n * sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ScalarQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14897,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x_copy.data(), <size of x_copy.data()>,  x,  n * sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "aeca8cbe-7a71-3eb5-a36b-c90a749d7f6b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/CodePacker.cpp"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 4,
                  "endLine": 48,
                  "endColumn": 40,
                  "charOffset": 1197,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(flat_codes, block, code_size)",
                    "rendered": {
                      "text": "memcpy(flat_codes, block, code_size)",
                      "markdown": "`memcpy(flat_codes, block, code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/CodePacker.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1197,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(flat_codes, <size of flat_codes>,  block,  code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0470a315-ab4a-3a76-95d4-ba955ab8ab05",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AuxIndexStructures.cpp"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 8,
                  "endLine": 102,
                  "endColumn": 65,
                  "charOffset": 2671,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis)",
                    "rendered": {
                      "text": "memcpy(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis)",
                      "markdown": "`memcpy(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AuxIndexStructures.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2671,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest_dis, <size of dest_dis>,  buf.dis + ofs,  ncopy * sizeof(*dest_dis)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "58f4d292-5aa8-3e07-9472-356e50bff644",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/CodePacker.cpp"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 4,
                  "endLine": 43,
                  "endColumn": 40,
                  "charOffset": 1061,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(block, flat_codes, code_size)",
                    "rendered": {
                      "text": "memcpy(block, flat_codes, code_size)",
                      "markdown": "`memcpy(block, flat_codes, code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/CodePacker.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1061,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(block, <size of block>,  flat_codes,  code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5f984b00-e9dd-388f-b5fe-40f9fe14d1c5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 932,
                  "startColumn": 12,
                  "endLine": 934,
                  "endColumn": 46,
                  "charOffset": 29263,
                  "charLength": 134,
                  "snippet": {
                    "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                    "rendered": {
                      "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                      "markdown": "`memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29263,
                        "charLength": 134
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids + perm[i] * dsub, <size of centroids + perm[i] * dsub>, \n                   centroids_copy.data() + i * dsub, \n                   dsub * sizeof(centroids[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "811d38f3-c76e-39ac-be38-c0ba5fe748cd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/index_read.cpp"
                },
                "region": {
                  "startLine": 192,
                  "startColumn": 8,
                  "endLine": 192,
                  "endColumn": 15,
                  "charOffset": 5794,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "51c9f610-24b4-3eed-a8b8-2ceab3119963",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AuxIndexStructures.cpp"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 8,
                  "endLine": 101,
                  "endColumn": 65,
                  "charOffset": 2603,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids)",
                    "rendered": {
                      "text": "memcpy(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids)",
                      "markdown": "`memcpy(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AuxIndexStructures.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2603,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest_ids, <size of dest_ids>,  buf.ids + ofs,  ncopy * sizeof(*dest_ids)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1d70bb79-65c8-3ed4-a529-0bda9dbc1673",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/index_read.cpp"
                },
                "region": {
                  "startLine": 750,
                  "startColumn": 16,
                  "endLine": 750,
                  "endColumn": 77,
                  "charOffset": 24070,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(ail->codes[i].data(), vec.data(), ail->codes[i].size()",
                    "rendered": {
                      "text": "memcpy(ail->codes[i].data(), vec.data(), ail->codes[i].size()",
                      "markdown": "`memcpy(ail->codes[i].data(), vec.data(), ail->codes[i].size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/index_read.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24070,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ail->codes[i].data(), <size of ail->codes[i].data()>,  vec.data(),  ail->codes[i].size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f0dd8a5c-b513-35c7-a2ee-91d90b4163be",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/gpu/GpuAutoTune.cpp"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 47,
                  "endLine": 103,
                  "endColumn": 67,
                  "charOffset": 2867,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(\"quantizer_\")",
                    "rendered": {
                      "text": "strlen(\"quantizer_\")",
                      "markdown": "`strlen(\"quantizer_\")`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/gpu/GpuAutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2867,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/gpu/GpuAutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2867,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e28b967e-a65a-3db9-ab26-e014990fba94",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 909,
                  "startColumn": 28,
                  "endLine": 909,
                  "endColumn": 33,
                  "charOffset": 28554,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "50c00415-ff37-3c87-b1b5-00c467c2ab27",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 895,
                  "startColumn": 12,
                  "endLine": 895,
                  "endColumn": 18,
                  "charOffset": 28083,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a27a49a3-24ca-3339-b76d-940a9c0aff8f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 802,
                  "startColumn": 28,
                  "endLine": 802,
                  "endColumn": 33,
                  "charOffset": 25355,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "92936ba7-557c-3fa7-acd2-7fd793592b88",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 822,
                  "startColumn": 12,
                  "endLine": 824,
                  "endColumn": 46,
                  "charOffset": 25981,
                  "charLength": 134,
                  "snippet": {
                    "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                    "rendered": {
                      "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                      "markdown": "`memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25981,
                        "charLength": 134
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids + perm[i] * dsub, <size of centroids + perm[i] * dsub>, \n                   centroids_copy.data() + i * dsub, \n                   dsub * sizeof(centroids[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "021f3c2c-16c9-3c36-adda-160d4c1eb053",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 878,
                  "startColumn": 12,
                  "endLine": 880,
                  "endColumn": 32,
                  "charOffset": 27593,
                  "charLength": 114,
                  "snippet": {
                    "text": "memcpy(gt_distances.data(),\n                   pq.sdc_table.data() + m * nq * nb,\n                   sizeof(float)",
                    "rendered": {
                      "text": "memcpy(gt_distances.data(),\n                   pq.sdc_table.data() + m * nq * nb,\n                   sizeof(float)",
                      "markdown": "`memcpy(gt_distances.data(),\n                   pq.sdc_table.data() + m * nq * nb,\n                   sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27593,
                        "charLength": 114
                      },
                      "insertedContent": {
                        "text": "memcpy_s(gt_distances.data(), <size of gt_distances.data()>, \n                   pq.sdc_table.data() + m * nq * nb, \n                   sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e2ef8c39-994c-35ec-aa93-bb11c6c2dea4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/gpu/GpuCloner.cpp"
                },
                "region": {
                  "startLine": 413,
                  "startColumn": 12,
                  "endLine": 413,
                  "endColumn": 18,
                  "charOffset": 15518,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "86f5e54b-3cc3-3c62-8b5b-41cf5c703a74",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/gpu/GpuCloner.cpp"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 12,
                  "endLine": 182,
                  "endColumn": 18,
                  "charOffset": 6703,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d86b9265-3668-3194-a301-08a8961b7e47",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 131,
                  "startColumn": 12,
                  "endLine": 131,
                  "endColumn": 18,
                  "charOffset": 3830,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6f66c3aa-50ec-3d84-9e94-00c1e4cb4790",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 854,
                  "startColumn": 16,
                  "endLine": 856,
                  "endColumn": 36,
                  "charOffset": 26855,
                  "charLength": 117,
                  "snippet": {
                    "text": "memcpy(xtrain.data() + i * dsub,\n                       x + i * pq.d + m * dsub,\n                       sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xtrain.data() + i * dsub,\n                       x + i * pq.d + m * dsub,\n                       sizeof(float)",
                      "markdown": "`memcpy(xtrain.data() + i * dsub,\n                       x + i * pq.d + m * dsub,\n                       sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26855,
                        "charLength": 117
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xtrain.data() + i * dsub, <size of xtrain.data() + i * dsub>, \n                       x + i * pq.d + m * dsub, \n                       sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "aa176703-4dad-37ad-a8ae-7052aed91d0f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 12,
                  "endLine": 94,
                  "endColumn": 58,
                  "charOffset": 2619,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(best_perm, perm.data(), sizeof(perm[0])",
                    "rendered": {
                      "text": "memcpy(best_perm, perm.data(), sizeof(perm[0])",
                      "markdown": "`memcpy(best_perm, perm.data(), sizeof(perm[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2619,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(best_perm, <size of best_perm>,  perm.data(),  sizeof(perm[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0228618e-67ca-3c8c-9643-cfbd42b6b5dc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1505,
                  "startColumn": 8,
                  "endLine": 1505,
                  "endColumn": 68,
                  "charOffset": 48492,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                    "rendered": {
                      "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                      "markdown": "`memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48492,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_codes, <size of out_codes>,  codes_ptr,  codes_size * sizeof(*codes_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1d749b2c-cff0-3421-bd7e-48d9f545b0ec",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1493,
                  "startColumn": 12,
                  "endLine": 1493,
                  "endColumn": 18,
                  "charOffset": 48098,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f2668f77-7e12-3200-ac08-27afd13e71ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1511,
                  "startColumn": 8,
                  "endLine": 1513,
                  "endColumn": 54,
                  "charOffset": 48723,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(out_distances,\n               distances_ptr,\n               distances_size * sizeof(*distances_ptr)",
                    "rendered": {
                      "text": "memcpy(out_distances,\n               distances_ptr,\n               distances_size * sizeof(*distances_ptr)",
                      "markdown": "`memcpy(out_distances,\n               distances_ptr,\n               distances_size * sizeof(*distances_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48723,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_distances, <size of out_distances>, \n               distances_ptr, \n               distances_size * sizeof(*distances_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "de532ab1-48fe-3c6d-a6a8-4978d74c1876",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NSG.h"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 8,
                  "endLine": 74,
                  "endColumn": 51,
                  "charOffset": 2012,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(data, g.data, N * K * sizeof(node_t)",
                    "rendered": {
                      "text": "memcpy(data, g.data, N * K * sizeof(node_t)",
                      "markdown": "`memcpy(data, g.data, N * K * sizeof(node_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/NSG.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2012,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data, <size of data>,  g.data,  N * K * sizeof(node_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "94eec2ea-7cd8-3ba9-a1c7-32fdc0c7ee9d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NSG.cpp"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 4,
                  "endLine": 133,
                  "endColumn": 11,
                  "charOffset": 3070,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "aa1cab7a-5cd8-3292-9346-03252528663a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1385,
                  "startColumn": 16,
                  "endLine": 1385,
                  "endColumn": 68,
                  "charOffset": 44706,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                    "rendered": {
                      "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                      "markdown": "`memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44706,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_codes_i, <size of new_codes_i>,  codes_i + js * m,  sizeof(*codes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8ff697c7-556b-3e15-9f70-d7165241ec51",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NSG.cpp"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 8,
                  "endLine": 103,
                  "endColumn": 15,
                  "charOffset": 2353,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "037da8d4-ba58-3c16-8d0a-bdd979bceca8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 924,
                  "startColumn": 8,
                  "endLine": 926,
                  "endColumn": 54,
                  "charOffset": 28793,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(out_residuals,\n               residuals_ptr,\n               residuals_size * sizeof(*residuals_ptr)",
                    "rendered": {
                      "text": "memcpy(out_residuals,\n               residuals_ptr,\n               residuals_size * sizeof(*residuals_ptr)",
                      "markdown": "`memcpy(out_residuals,\n               residuals_ptr,\n               residuals_size * sizeof(*residuals_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28793,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_residuals, <size of out_residuals>, \n               residuals_ptr, \n               residuals_size * sizeof(*residuals_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3b6fa39f-d4af-3e28-8249-5e81081edac8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 419,
                  "startColumn": 16,
                  "endLine": 419,
                  "endColumn": 22,
                  "charOffset": 13780,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8aeb9193-400a-3370-a64f-b5589fdb407e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 399,
                  "startColumn": 12,
                  "endLine": 399,
                  "endColumn": 18,
                  "charOffset": 13092,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3213c710-6b62-300e-8aa2-9c9a98155fa3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 932,
                  "startColumn": 8,
                  "endLine": 934,
                  "endColumn": 57,
                  "charOffset": 29070,
                  "charLength": 117,
                  "snippet": {
                    "text": "memcpy(out_distances,\n               pool.distances.data(),\n               distances_size * sizeof(pool.distances[0])",
                    "rendered": {
                      "text": "memcpy(out_distances,\n               pool.distances.data(),\n               distances_size * sizeof(pool.distances[0])",
                      "markdown": "`memcpy(out_distances,\n               pool.distances.data(),\n               distances_size * sizeof(pool.distances[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29070,
                        "charLength": 117
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_distances, <size of out_distances>, \n               pool.distances.data(), \n               distances_size * sizeof(pool.distances[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5fbba3c0-4c4c-35ec-86db-b14ca14cb6bc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 906,
                  "startColumn": 12,
                  "endLine": 906,
                  "endColumn": 18,
                  "charOffset": 28164,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "689c600e-ae99-3a4e-a3e5-c898414bc490",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 345,
                  "startColumn": 8,
                  "endLine": 347,
                  "endColumn": 31,
                  "charOffset": 11121,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(this->codebooks.data() + codebook_offsets[m] * d,\n               codebooks.data(),\n               codebooks.size()",
                    "rendered": {
                      "text": "memcpy(this->codebooks.data() + codebook_offsets[m] * d,\n               codebooks.data(),\n               codebooks.size()",
                      "markdown": "`memcpy(this->codebooks.data() + codebook_offsets[m] * d,\n               codebooks.data(),\n               codebooks.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11121,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(this->codebooks.data() + codebook_offsets[m] * d, <size of this->codebooks.data() + codebook_offsets[m] * d>, \n               codebooks.data(), \n               codebooks.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c09f8625-1aec-3f91-afc6-96755c3547fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 918,
                  "startColumn": 8,
                  "endLine": 918,
                  "endColumn": 68,
                  "charOffset": 28562,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                    "rendered": {
                      "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                      "markdown": "`memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28562,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_codes, <size of out_codes>,  codes_ptr,  codes_size * sizeof(*codes_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "796bc0f1-54c8-3ab2-8ad8-2b8d2364f7bd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 265,
                  "startColumn": 20,
                  "endLine": 265,
                  "endColumn": 72,
                  "charOffset": 8434,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                    "rendered": {
                      "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                      "markdown": "`memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8434,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_codes_i, <size of new_codes_i>,  codes_i + js * m,  sizeof(*codes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e95e1201-8c57-31fa-abb0-725ef3106ca9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 20,
                  "endLine": 211,
                  "endColumn": 72,
                  "charOffset": 6304,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                    "rendered": {
                      "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                      "markdown": "`memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6304,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_codes_i, <size of new_codes_i>,  codes_i + js * m,  sizeof(*codes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e370e54a-532f-3817-b473-6d750b5cfcbb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 121,
                  "startColumn": 8,
                  "endLine": 123,
                  "endColumn": 31,
                  "charOffset": 2857,
                  "charLength": 132,
                  "snippet": {
                    "text": "memcpy(codebooks.data(),\n               other.codebooks.data() + other.codebook_offsets[skip_M] * d,\n               codebooks.size()",
                    "rendered": {
                      "text": "memcpy(codebooks.data(),\n               other.codebooks.data() + other.codebook_offsets[skip_M] * d,\n               codebooks.size()",
                      "markdown": "`memcpy(codebooks.data(),\n               other.codebooks.data() + other.codebook_offsets[skip_M] * d,\n               codebooks.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2857,
                        "charLength": 132
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codebooks.data(), <size of codebooks.data()>, \n               other.codebooks.data() + other.codebook_offsets[skip_M] * d, \n               codebooks.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "98f2fc2f-9d60-3167-a4ca-f0520e7e341d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured URL Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 3,
                  "endLine": 48,
                  "endColumn": 24,
                  "charOffset": 1070,
                  "charLength": 21,
                  "snippet": {
                    "text": "http://www.netlib.org",
                    "rendered": {
                      "text": "http://www.netlib.org",
                      "markdown": "`http://www.netlib.org`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1070,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "https://www.netlib.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "7de317c0-460f-3b18-acca-8bda9c60e47e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 306,
                  "startColumn": 16,
                  "endLine": 308,
                  "endColumn": 43,
                  "charOffset": 9668,
                  "charLength": 142,
                  "snippet": {
                    "text": "memcpy(residuals1.data() + j * d,\n                       residuals.data() + j * d * cur_beam_size,\n                       sizeof(residuals[0])",
                    "rendered": {
                      "text": "memcpy(residuals1.data() + j * d,\n                       residuals.data() + j * d * cur_beam_size,\n                       sizeof(residuals[0])",
                      "markdown": "`memcpy(residuals1.data() + j * d,\n                       residuals.data() + j * d * cur_beam_size,\n                       sizeof(residuals[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9668,
                        "charLength": 142
                      },
                      "insertedContent": {
                        "text": "memcpy_s(residuals1.data() + j * d, <size of residuals1.data() + j * d>, \n                       residuals.data() + j * d * cur_beam_size, \n                       sizeof(residuals[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0b329990-7068-3021-af51-00a62557defb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 4,
                  "endLine": 113,
                  "endColumn": 23,
                  "charOffset": 2518,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(nbits.data(),\n           other.nbits.data() + skip_M,\n           nbits.size()",
                    "rendered": {
                      "text": "memcpy(nbits.data(),\n           other.nbits.data() + skip_M,\n           nbits.size()",
                      "markdown": "`memcpy(nbits.data(),\n           other.nbits.data() + skip_M,\n           nbits.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2518,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(nbits.data(), <size of nbits.data()>, \n           other.nbits.data() + skip_M, \n           nbits.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "59ea5dec-cff1-38bf-a7be-e60499c1b3be",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/sorting.cpp"
                },
                "region": {
                  "startLine": 519,
                  "startColumn": 12,
                  "endLine": 519,
                  "endColumn": 53,
                  "charOffset": 15120,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(ptrs.data(), lims, sizeof(lims[0])",
                    "rendered": {
                      "text": "memcpy(ptrs.data(), lims, sizeof(lims[0])",
                      "markdown": "`memcpy(ptrs.data(), lims, sizeof(lims[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/sorting.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15120,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs.data(), <size of ptrs.data()>,  lims,  sizeof(lims[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c55fdf17-d59e-3219-a616-723a70d9d6b7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/sorting.cpp"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 16,
                  "endLine": 183,
                  "endColumn": 36,
                  "charOffset": 5052,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(permB + segs[s].i0,\n                       permA + segs[s].i0,\n                       segs[s].len()",
                    "rendered": {
                      "text": "memcpy(permB + segs[s].i0,\n                       permA + segs[s].i0,\n                       segs[s].len()",
                      "markdown": "`memcpy(permB + segs[s].i0,\n                       permA + segs[s].i0,\n                       segs[s].len()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/sorting.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5052,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(permB + segs[s].i0, <size of permB + segs[s].i0>, \n                       permA + segs[s].i0, \n                       segs[s].len()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bfb0cb03-6333-3e9c-854e-dc3d71c2f5a9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_ivfpq_indexing.cpp"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 8,
                  "endLine": 141,
                  "endColumn": 14,
                  "charOffset": 3864,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1312d87a-dcf7-3c60-bd21-7c52db2a9a82",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_ivfpq_indexing.cpp"
                },
                "region": {
                  "startLine": 115,
                  "startColumn": 8,
                  "endLine": 115,
                  "endColumn": 14,
                  "charOffset": 3061,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6f516fa6-906a-3890-8278-c668a4a7c528",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_imi_flat.cpp"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 8,
                  "endLine": 129,
                  "endColumn": 14,
                  "charOffset": 4084,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "657350d1-8bc0-322f-a67e-df7d33a003dd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexBinaryIVF.cpp"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 8,
                  "endLine": 103,
                  "endColumn": 14,
                  "charOffset": 2525,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c4b8cb65-7040-32ca-8b1f-b269c41a31fd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_weighted_kmeans.cpp"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 27,
                  "endLine": 128,
                  "endColumn": 31,
                  "charOffset": 3182,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4ab8e6b3-9cfd-37c5-9f7c-8fb7ef5eb6f8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_weighted_kmeans.cpp"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 24,
                  "endLine": 127,
                  "endColumn": 28,
                  "charOffset": 3140,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c2989b22-2162-30cd-9e07-b331bcf4ca56",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/sorting.cpp"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 12,
                  "endLine": 118,
                  "endColumn": 55,
                  "charOffset": 3285,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(dst + sw.i0, src + s1t.i0, s1t.len()",
                    "rendered": {
                      "text": "memcpy(dst + sw.i0, src + s1t.i0, s1t.len()",
                      "markdown": "`memcpy(dst + sw.i0, src + s1t.i0, s1t.len()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/sorting.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3285,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst + sw.i0, <size of dst + sw.i0>,  src + s1t.i0,  s1t.len()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d1ef891d-f844-3b7e-86e8-9d5d3cf2e658",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/sorting.cpp"
                },
                "region": {
                  "startLine": 121,
                  "startColumn": 12,
                  "endLine": 121,
                  "endColumn": 55,
                  "charOffset": 3439,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(dst + sw.i0, src + s2t.i0, s2t.len()",
                    "rendered": {
                      "text": "memcpy(dst + sw.i0, src + s2t.i0, s2t.len()",
                      "markdown": "`memcpy(dst + sw.i0, src + s2t.i0, s2t.len()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/sorting.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3439,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst + sw.i0, <size of dst + sw.i0>,  src + s2t.i0,  s2t.len()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a9b0252b-ddfc-3031-92bd-7812e523b672",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_sift1M.cpp"
                },
                "region": {
                  "startLine": 168,
                  "startColumn": 8,
                  "endLine": 168,
                  "endColumn": 14,
                  "charOffset": 4432,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5889f598-58ef-3ece-885c-6d0bc4695919",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_sift1M.cpp"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 8,
                  "endLine": 60,
                  "endColumn": 15,
                  "charOffset": 1540,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2879a931-9b2f-3f6b-a5d0-17b50a483c90",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_sift1M.cpp"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 14,
                  "endLine": 36,
                  "endColumn": 19,
                  "charOffset": 826,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1970ef80-8756-33cd-8edd-1ae8241e91e6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 607,
                  "startColumn": 19,
                  "endLine": 607,
                  "endColumn": 26,
                  "charOffset": 14993,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c2320358-484a-331b-afc2-ac578f490ddd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexBinaryIVF.cpp"
                },
                "region": {
                  "startLine": 232,
                  "startColumn": 4,
                  "endLine": 232,
                  "endColumn": 61,
                  "charOffset": 6617,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(recons, invlists->get_single_code(list_no, offset)",
                    "rendered": {
                      "text": "memcpy(recons, invlists->get_single_code(list_no, offset)",
                      "markdown": "`memcpy(recons, invlists->get_single_code(list_no, offset)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexBinaryIVF.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6617,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(recons, <size of recons>,  invlists->get_single_code(list_no,  offset)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a340474d-4cbb-3602-b42e-9482dca16374",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 517,
                  "startColumn": 24,
                  "endLine": 517,
                  "endColumn": 27,
                  "charOffset": 12864,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12864,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12864,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "040a2dc1-0572-38e0-a7cd-8d1bfc044606",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_imi_pq.cpp"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 8,
                  "endLine": 181,
                  "endColumn": 14,
                  "charOffset": 6025,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c37089a3-d4fa-388a-b284-3f3adfd9c8ec",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 441,
                  "startColumn": 48,
                  "endLine": 441,
                  "endColumn": 51,
                  "charOffset": 11140,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11140,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11140,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "336fe975-41e7-3c03-9422-77e7974c1cef",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 495,
                  "startColumn": 19,
                  "endLine": 495,
                  "endColumn": 26,
                  "charOffset": 12446,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "61adee8f-d8bc-3e74-ba11-3a9f38a0c2a6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 432,
                  "startColumn": 23,
                  "endLine": 432,
                  "endColumn": 26,
                  "charOffset": 10930,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10930,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10930,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "bc801d8b-5090-34e4-925c-5caf855470e8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 343,
                  "startColumn": 34,
                  "endLine": 343,
                  "endColumn": 37,
                  "charOffset": 8559,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8559,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8559,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "5f8dfa34-d2c8-3925-84da-d3765f5e0e3c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 305,
                  "startColumn": 47,
                  "endLine": 305,
                  "endColumn": 50,
                  "charOffset": 7663,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7663,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7663,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "65683616-7ceb-3963-b010-176378ea4876",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 310,
                  "startColumn": 19,
                  "endLine": 310,
                  "endColumn": 26,
                  "charOffset": 7846,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ef9ecb8b-a49d-3647-9324-be5d800db9ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_weighted_kmeans.cpp"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 4,
                  "endLine": 60,
                  "endColumn": 63,
                  "charOffset": 1457,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(centroids, clus.centroids.data(), sizeof(*centroids)",
                    "rendered": {
                      "text": "memcpy(centroids, clus.centroids.data(), sizeof(*centroids)",
                      "markdown": "`memcpy(centroids, clus.centroids.data(), sizeof(*centroids)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "demos/demo_weighted_kmeans.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1457,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids, <size of centroids>,  clus.centroids.data(),  sizeof(*centroids)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "eb1ea63a-f4fc-30e3-8032-82abe2e5c37b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 292,
                  "startColumn": 23,
                  "endLine": 292,
                  "endColumn": 26,
                  "charOffset": 7397,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7397,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7397,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "be0b4abd-1d50-3a46-86a3-f73ec90e7a02",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 35,
                  "endLine": 158,
                  "endColumn": 38,
                  "charOffset": 3715,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3715,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3715,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "cd3bf0fc-8fcb-3aa3-921f-78b2185cfb52",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 49,
                  "endLine": 76,
                  "endColumn": 52,
                  "charOffset": 1463,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1463,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1463,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "9299837b-e3e7-3f4e-b6db-acec9e402046",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 165,
                  "startColumn": 35,
                  "endLine": 165,
                  "endColumn": 38,
                  "charOffset": 3937,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3937,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3937,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "93440079-6472-3e06-aab5-b8afa921cff8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 19,
                  "endLine": 81,
                  "endColumn": 26,
                  "charOffset": 1646,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "48692864-6b2a-3762-a426-6c10a066f033",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 24,
                  "endLine": 63,
                  "endColumn": 27,
                  "charOffset": 1190,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1190,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1190,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "68bb3da6-434b-3763-af41-748812862ed2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 15,
                  "endLine": 27,
                  "endColumn": 18,
                  "charOffset": 474,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 474,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 474,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "b4a529b3-74d5-3f92-b052-d4f62e311ee0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 6,
                  "endLine": 25,
                  "endColumn": 9,
                  "charOffset": 444,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 444,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 444,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "42d0c4a1-f202-3829-8c20-68f480447cfb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 9,
                  "endLine": 17,
                  "endColumn": 12,
                  "charOffset": 310,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 310,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 310,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "da45c7af-ae85-35dd-bdeb-6b2c7389070a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 8,
                  "endLine": 40,
                  "endColumn": 27,
                  "charOffset": 700,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(u8, ptr, 32)",
                    "rendered": {
                      "text": "memcpy(u8, ptr, 32)",
                      "markdown": "`memcpy(u8, ptr, 32)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 700,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(u8, <size of u8>,  ptr,  32)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ea226d7f-9b3a-3538-996d-a71b2c675547",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexNNDescent.cpp"
                },
                "region": {
                  "startLine": 192,
                  "startColumn": 8,
                  "endLine": 192,
                  "endColumn": 15,
                  "charOffset": 5056,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "314035f7-9649-302b-a63d-a5c21b54c13e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexBinaryHNSW.cpp"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 8,
                  "endLine": 54,
                  "endColumn": 14,
                  "charOffset": 1235,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "76a2213e-9de5-39cb-96b8-ade4f56ef25a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 772,
                  "startColumn": 42,
                  "endLine": 772,
                  "endColumn": 45,
                  "charOffset": 24541,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24541,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24541,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "377f7004-546d-3dd9-a52f-8f4208f6e90a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 42,
                  "endLine": 593,
                  "endColumn": 45,
                  "charOffset": 19140,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19140,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19140,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "b9e0180f-0caa-33a3-9dda-38e223b7465a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 8,
                  "endLine": 28,
                  "endColumn": 25,
                  "charOffset": 508,
                  "charLength": 17,
                  "snippet": {
                    "text": "memcpy(u8, x, 32)",
                    "rendered": {
                      "text": "memcpy(u8, x, 32)",
                      "markdown": "`memcpy(u8, x, 32)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 508,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "memcpy_s(u8, <size of u8>,  x,  32)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "33738c62-12bb-3d8a-8fff-b56aa81a315f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 42,
                  "endLine": 415,
                  "endColumn": 45,
                  "charOffset": 13642,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13642,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13642,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "966568b5-d63b-3190-a055-a35507bef0d4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 669,
                  "startColumn": 42,
                  "endLine": 669,
                  "endColumn": 45,
                  "charOffset": 21692,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21692,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21692,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "0b79b6d8-127b-303a-adad-eb079c883444",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 535,
                  "startColumn": 42,
                  "endLine": 535,
                  "endColumn": 45,
                  "charOffset": 17610,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17610,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17610,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "62a53627-6b59-3f69-9d5e-87a3e13c3e38",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 42,
                  "endLine": 403,
                  "endColumn": 45,
                  "charOffset": 13221,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13221,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13221,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "62d96ae8-9ad6-3890-9544-8435b41852e2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 140,
                  "startColumn": 15,
                  "endLine": 140,
                  "endColumn": 22,
                  "charOffset": 4005,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4f9f6ccf-6eaf-31de-b069-e5a191a99b7b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 215,
                  "startColumn": 42,
                  "endLine": 215,
                  "endColumn": 45,
                  "charOffset": 6189,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6189,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6189,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "66085b83-2001-397a-a1fd-229a1b75ab05",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 12,
                  "endLine": 96,
                  "endColumn": 15,
                  "charOffset": 2761,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2761,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2761,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "57102ed5-1506-320a-8c40-e4297169239d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 8,
                  "endLine": 36,
                  "endColumn": 27,
                  "charOffset": 630,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(ptr, u8, 32)",
                    "rendered": {
                      "text": "memcpy(ptr, u8, 32)",
                      "markdown": "`memcpy(ptr, u8, 32)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 630,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr, <size of ptr>,  u8,  32)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "53eec251-26af-3b31-a2e9-c9dcbec57443",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexRefine.cpp"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 8,
                  "endLine": 182,
                  "endColumn": 66,
                  "charOffset": 5618,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(tmp2.get() + i * cs2, bytes + i * (cs1 + cs2), cs2)",
                    "rendered": {
                      "text": "memcpy(tmp2.get() + i * cs2, bytes + i * (cs1 + cs2), cs2)",
                      "markdown": "`memcpy(tmp2.get() + i * cs2, bytes + i * (cs1 + cs2), cs2)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexRefine.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5618,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tmp2.get() + i * cs2, <size of tmp2.get() + i * cs2>,  bytes + i * (cs1 + cs2),  cs2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "758a599d-efc8-3474-9a29-7fa5b4bdb1bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexRefine.cpp"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 8,
                  "endLine": 173,
                  "endColumn": 50,
                  "charOffset": 5265,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(b + cs1, tmp2.get() + cs2 * i, cs2)",
                    "rendered": {
                      "text": "memcpy(b + cs1, tmp2.get() + cs2 * i, cs2)",
                      "markdown": "`memcpy(b + cs1, tmp2.get() + cs2 * i, cs2)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexRefine.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5265,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(b + cs1, <size of b + cs1>,  tmp2.get() + cs2 * i,  cs2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "65ce472d-9ffe-31f2-9bc9-28a6b3b1930d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 9,
                  "endLine": 113,
                  "endColumn": 39,
                  "charOffset": 3278,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(bytes, ds, sizeof(char)",
                    "rendered": {
                      "text": "memcpy(bytes, ds, sizeof(char)",
                      "markdown": "`memcpy(bytes, ds, sizeof(char)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3278,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes, <size of bytes>,  ds,  sizeof(char)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "388b1ae6-fc83-33d6-80a7-9c5729ee0295",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexRefine.cpp"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 8,
                  "endLine": 172,
                  "endColumn": 44,
                  "charOffset": 5219,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(b, tmp1.get() + cs1 * i, cs1)",
                    "rendered": {
                      "text": "memcpy(b, tmp1.get() + cs1 * i, cs1)",
                      "markdown": "`memcpy(b, tmp1.get() + cs1 * i, cs1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexRefine.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5219,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(b, <size of b>,  tmp1.get() + cs1 * i,  cs1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "69efe4ac-5a9c-310b-a92a-26c514b32635",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexPQ.cpp"
                },
                "region": {
                  "startLine": 915,
                  "startColumn": 16,
                  "endLine": 915,
                  "endColumn": 22,
                  "charOffset": 26319,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8ff0a4bd-2348-3885-ba75-821957064ecf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexPQ.cpp"
                },
                "region": {
                  "startLine": 1069,
                  "startColumn": 12,
                  "endLine": 1069,
                  "endColumn": 55,
                  "charOffset": 30730,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(xdest, xsrc, dsub * sizeof(xdest[0])",
                    "rendered": {
                      "text": "memcpy(xdest, xsrc, dsub * sizeof(xdest[0])",
                      "markdown": "`memcpy(xdest, xsrc, dsub * sizeof(xdest[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexPQ.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30730,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xdest, <size of xdest>,  xsrc,  dsub * sizeof(xdest[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "52613f04-ff2b-3e97-8c27-2429f8f1bc0c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexPQ.cpp"
                },
                "region": {
                  "startLine": 980,
                  "startColumn": 8,
                  "endLine": 980,
                  "endColumn": 45,
                  "charOffset": 28240,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(recons, pq.get_centroids(m, n)",
                    "rendered": {
                      "text": "memcpy(recons, pq.get_centroids(m, n)",
                      "markdown": "`memcpy(recons, pq.get_centroids(m, n)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexPQ.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28240,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(recons, <size of recons>,  pq.get_centroids(m,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e7edc16f-c9d6-3a44-9323-61691bc8fa6b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFPQR.cpp"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 8,
                  "endLine": 56,
                  "endColumn": 14,
                  "charOffset": 1264,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a2a5ae12-f543-30b4-8e62-78cc0c802cae",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexPQ.cpp"
                },
                "region": {
                  "startLine": 58,
                  "startColumn": 12,
                  "endLine": 58,
                  "endColumn": 18,
                  "charOffset": 1482,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a3158f47-333d-37fb-9664-b492fd9ec4e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexFlat.cpp"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 8,
                  "endLine": 173,
                  "endColumn": 38,
                  "charOffset": 4925,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(bytes, x, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(bytes, x, sizeof(float)",
                      "markdown": "`memcpy(bytes, x, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4925,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes, <size of bytes>,  x,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "67227c77-9f64-32d0-8505-d3f16f997747",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexFlat.cpp"
                },
                "region": {
                  "startLine": 179,
                  "startColumn": 8,
                  "endLine": 179,
                  "endColumn": 38,
                  "charOffset": 5075,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(x, bytes, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(x, bytes, sizeof(float)",
                      "markdown": "`memcpy(x, bytes, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5075,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x, <size of x>,  bytes,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d7ed3af0-f9f8-3a38-80fb-0bbcd1144b49",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1211,
                  "startColumn": 12,
                  "endLine": 1211,
                  "endColumn": 19,
                  "charOffset": 33075,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "152df44a-3397-37bd-963d-7e6c0390c27c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1124,
                  "startColumn": 12,
                  "endLine": 1124,
                  "endColumn": 18,
                  "charOffset": 30669,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "65b46005-159e-3c4b-9c0f-6b1c0ddee979",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1033,
                  "startColumn": 8,
                  "endLine": 1033,
                  "endColumn": 14,
                  "charOffset": 27882,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "26bda864-deb0-3fe7-9bbb-413c237fc3d1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1026,
                  "startColumn": 8,
                  "endLine": 1026,
                  "endColumn": 14,
                  "charOffset": 27744,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7b1488f8-4a99-356b-9729-ad6a88078f11",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexFlat.cpp"
                },
                "region": {
                  "startLine": 168,
                  "startColumn": 4,
                  "endLine": 168,
                  "endColumn": 56,
                  "charOffset": 4768,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(recons, &(codes[key * code_size]), code_size)",
                    "rendered": {
                      "text": "memcpy(recons, &(codes[key * code_size]), code_size)",
                      "markdown": "`memcpy(recons, &(codes[key * code_size]), code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4768,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(recons, <size of recons>,  &(codes[key * code_size]),  code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6421bb04-abd0-3cb4-af94-dbf5cb46b341",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1243,
                  "startColumn": 4,
                  "endLine": 1243,
                  "endColumn": 31,
                  "charOffset": 33944,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(x, xt, sizeof(xt[0])",
                    "rendered": {
                      "text": "memcpy(x, xt, sizeof(xt[0])",
                      "markdown": "`memcpy(x, xt, sizeof(xt[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/VectorTransform.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33944,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x, <size of x>,  xt,  sizeof(xt[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b9437365-b71d-3619-85cd-9755c3d6e132",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1232,
                  "startColumn": 8,
                  "endLine": 1232,
                  "endColumn": 34,
                  "charOffset": 33681,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(xt, x, sizeof(x[0])",
                    "rendered": {
                      "text": "memcpy(xt, x, sizeof(x[0])",
                      "markdown": "`memcpy(xt, x, sizeof(x[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/VectorTransform.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33681,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xt, <size of xt>,  x,  sizeof(x[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1ec83b91-c85f-3c39-98bb-7bb2af23d59f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1023,
                  "startColumn": 8,
                  "endLine": 1023,
                  "endColumn": 14,
                  "charOffset": 27619,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "853e9c18-a99f-30e2-96db-c506dfa67d79",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 740,
                  "startColumn": 8,
                  "endLine": 742,
                  "endColumn": 42,
                  "charOffset": 19533,
                  "charLength": 103,
                  "snippet": {
                    "text": "memcpy(rotation.data(),\n               init_rotation.data(),\n               d * d * sizeof(rotation[0])",
                    "rendered": {
                      "text": "memcpy(rotation.data(),\n               init_rotation.data(),\n               d * d * sizeof(rotation[0])",
                      "markdown": "`memcpy(rotation.data(),\n               init_rotation.data(),\n               d * d * sizeof(rotation[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/VectorTransform.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19533,
                        "charLength": 103
                      },
                      "insertedContent": {
                        "text": "memcpy_s(rotation.data(), <size of rotation.data()>, \n               init_rotation.data(), \n               d * d * sizeof(rotation[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b68dfac8-504e-30c8-a6bf-804008e22e38",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 470,
                  "startColumn": 47,
                  "endLine": 470,
                  "endColumn": 67,
                  "charOffset": 13649,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(\"quantizer_\")",
                    "rendered": {
                      "text": "strlen(\"quantizer_\")",
                      "markdown": "`strlen(\"quantizer_\")`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13649,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13649,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7e5e844a-37e5-3172-958c-ab9d50f7c36a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 14,
                  "endLine": 209,
                  "endColumn": 19,
                  "charOffset": 5790,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "44c1fe05-e811-32ae-a18a-295bd46cb975",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 14,
                  "endLine": 195,
                  "endColumn": 19,
                  "charOffset": 5399,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9d00d977-abf5-3258-a265-b819af69b4d7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 408,
                  "startColumn": 12,
                  "endLine": 408,
                  "endColumn": 19,
                  "charOffset": 10011,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2a911b2a-91cc-3b8f-8da6-c0c27c8e93c2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 664,
                  "startColumn": 16,
                  "endLine": 664,
                  "endColumn": 78,
                  "charOffset": 17437,
                  "charLength": 62,
                  "snippet": {
                    "text": "memcpy(&A[row_dst * d_in], &Ain[i * d_in], d_in * sizeof(A[0])",
                    "rendered": {
                      "text": "memcpy(&A[row_dst * d_in], &Ain[i * d_in], d_in * sizeof(A[0])",
                      "markdown": "`memcpy(&A[row_dst * d_in], &Ain[i * d_in], d_in * sizeof(A[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/VectorTransform.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17437,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&A[row_dst * d_in], <size of &A[row_dst * d_in]>,  &Ain[i * d_in],  d_in * sizeof(A[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3fe1bef2-9c7b-395b-84b4-9b822b48894d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 565,
                  "startColumn": 47,
                  "endLine": 565,
                  "endColumn": 67,
                  "charOffset": 16173,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(\"quantizer_\")",
                    "rendered": {
                      "text": "strlen(\"quantizer_\")",
                      "markdown": "`strlen(\"quantizer_\")`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16173,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16173,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "23bbf271-a5c1-384a-a122-ab4cae62c798",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 58,
                  "startColumn": 4,
                  "endLine": 58,
                  "endColumn": 48,
                  "charOffset": 1478,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(gt_I.data(), gt_I_in, sizeof(gt_I[0])",
                    "rendered": {
                      "text": "memcpy(gt_I.data(), gt_I_in, sizeof(gt_I[0])",
                      "markdown": "`memcpy(gt_I.data(), gt_I_in, sizeof(gt_I[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1478,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(gt_I.data(), <size of gt_I.data()>,  gt_I_in,  sizeof(gt_I[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "457753e3-3a9a-35f4-88ae-6b17fa8d6672",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFPQFastScan.cpp"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 12,
                  "endLine": 196,
                  "endColumn": 19,
                  "charOffset": 5320,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9129d0a7-d49f-3420-9126-8858befd8dd8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFPQFastScan.cpp"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 8,
                  "endLine": 142,
                  "endColumn": 14,
                  "charOffset": 3728,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "07d44a22-be0d-3b9e-bba8-bd681389267a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 8,
                  "endLine": 55,
                  "endColumn": 52,
                  "charOffset": 1377,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(gt_D.data(), gt_D_in, sizeof(gt_D[0])",
                    "rendered": {
                      "text": "memcpy(gt_D.data(), gt_D_in, sizeof(gt_D[0])",
                      "markdown": "`memcpy(gt_D.data(), gt_D_in, sizeof(gt_D[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1377,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(gt_D.data(), <size of gt_D.data()>,  gt_D_in,  sizeof(gt_D[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}