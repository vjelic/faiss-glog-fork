{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "578c55e4-4d0f-3c8f-aefc-e39096208a50",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The overlap was determined through data flow analysis, indicating that the destination and source pointers may reference overlapping memory areas. This can lead to unpredictable results or program crashes, as the standard memory copy function does not guarantee correct behavior when source and destination overlap. Additionally, there is no evidence of explicit checks or guards to prevent this scenario, and the source pointer may also be null, which further increases the risk of undefined behavior. The destination buffer's capacity is not known, and there is no indication that the length argument is derived from the destination's size, which could otherwise mitigate some risks. The source kind is not a string literal or C string, so the risk of overlap is not reduced by the nature of the source. All these factors contribute to the high confidence in this being a genuine issue that requires remediation.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions, such as `memmove`. This function is specifically designed to handle overlapping source and destination buffers safely. For example, change the code to:\n\n```cpp\nmemmove(dest + (sq / 2 * nq + q) * 32, src + (q * nsq + sq) * 16, 16);\n```\n\nThis ensures that even if the source and destination regions overlap, the data will be copied correctly without causing undefined behavior. Always verify that the source and destination pointers are valid and that the size argument does not exceed the bounds of either buffer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "114fa345-18d9-309b-91c9-2db23400ed96",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination may be derived from the source, which can lead to overlapping regions. The use of memcpy in such cases is unsafe, as memcpy does not guarantee correct behavior when source and destination overlap. Additionally, there are no explicit checks or guards in the code to prevent this overlap, and the source pointer could potentially be null, further increasing the risk. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. This change ensures that the memory copy operation will not result in data corruption or unpredictable behavior, even if the regions overlap.\n\n```cpp\n// Replace memcpy with memmove to safely handle possible overlap\nmemmove(dest + (sq / 2 * nq + qi) * 32, src + (q * nsq + sq) * 16, 16);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b0d3fda1-07f6-33a5-9e10-70ab8481fc6d",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the code performs a memory copy operation where the source and destination memory regions may overlap. The analysis detected a data flow relationship between the destination and source expressions, indicating that they could refer to overlapping memory areas. This can lead to undefined behavior in C/C++ when using functions like memcpy, which do not support overlapping regions. Additionally, there is no evidence of explicit checks or guards to prevent this overlap, and the source pointer could potentially be null, further increasing the risk. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not result in data corruption or unpredictable behavior if the source and destination regions overlap.\n\n```cpp\nmemmove(dest + (sq / 2 * nq + q) * 32 + 16, src + (q * nsq + sq + 1) * 16, 16);\n```\n\nAlternatively, if you can guarantee that the source and destination regions never overlap, document this assumption clearly in the code and add assertions to enforce it at runtime:\n\n```cpp\nassert(abs((dest + (sq / 2 * nq + q) * 32 + 16) - (src + (q * nsq + sq + 1) * 16)) >= 16);\nmemcpy(dest + (sq / 2 * nq + q) * 32 + 16, src + (q * nsq + sq + 1) * 16, 16);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "64180376-1b1c-3b46-a98a-a43d6eacfdcc",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the code copies memory from one buffer to another using a standard memory copy function, but there is a risk that the source and destination buffers may overlap. Overlapping memory regions with this function can result in undefined behavior, which may lead to data corruption or unpredictable program behavior. The analysis detected that the source and destination may be related through data flow, increasing the likelihood of overlap. Additionally, there is no evidence of explicit checks or guards to prevent this situation, and the source pointer may also be null, which further increases the risk of undefined behavior. The destination buffer is a pointer, and its capacity is not known, so there is no guarantee that the copy operation is safe. These factors all contribute to the assessment that this is a genuine and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between buffers that may overlap, use a function that is designed to handle overlapping regions. Replace the memory copy function with a memory move function, which safely handles overlapping memory:\n\n```cpp\nmemmove(centroids, x, n * sizeof(*x));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination buffers overlap. Additionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy to avoid null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "730b0633-00ea-332d-881a-74012922eecc",
              "help": {
                "text": "",
                "markdown": "This finding highlights a genuine risk of undefined behavior due to possible overlapping memory regions in a memory copy operation. The analysis detected that the source and destination pointers may overlap based on data flow analysis, which can cause unpredictable results when using functions like memcpy. Additionally, there is no explicit check or guard to prevent this overlap, and the source pointer could potentially be null, further increasing the risk. The destination buffer's capacity is not known, and the count is a fixed literal, which does not mitigate the overlap risk. This situation should be addressed to ensure memory safety and program correctness.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. This change ensures that the copy operation will not result in data corruption or unpredictable behavior if the regions overlap.\n\n```cpp\nmemmove(dest + (sq / 2 * nq + qi) * 32 + 16, src + (q * nsq + sq + 1) * 16, 16);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "58a11958-a1cc-3655-87a0-99e4648597d1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts characters until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to a buffer overflow. This can result in undefined behavior, including program crashes, incorrect results, or even code execution.\n\nIn the provided code snippet, the `strlen` function is used to check if the length of the string `sx` is equal to 4. If `sx` is not null-terminated, this could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen` on strings that may not be null-terminated. Instead, consider using functions that take the length of the string as an argument, such as `strnlen`, which will not read past the specified length.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` and add a maximum length to prevent buffer overflow:\n\n```cpp\nFAISS_THROW_IF_NOT(4 == strnlen(sx, MAX_LENGTH))\n```\n\nReplace `MAX_LENGTH` with the maximum length of the string `sx`.\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- `cstring` or `string.h` for `strlen` or `strnlen`\n- `faiss/impl/FaissAssert.h` for `FAISS_THROW_IF_NOT`\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "a5d2717d-e878-33d4-bc4a-8062b34a3bbf",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The code uses a memory copy function where the source and destination may overlap, as indicated by the dataflow analysis. This can lead to unpredictable results or program crashes. Additionally, there are no checks to ensure that the source and destination are not null, which could also result in undefined behavior. The source and destination are both identified as potentially overlapping and possibly null, and there are no guards or capacity checks present. The source is a general identifier, not a string literal or constant, so the risk of overlap is not reduced. Therefore, this is a high-confidence, actionable issue that should be addressed to prevent undefined behavior.\n\n## In Context Remediation 0\nTo prevent undefined behavior when copying memory, ensure that the source and destination buffers do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit null checks for both the source and destination pointers before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (buffer.data() != nullptr && src != nullptr) {\n    memmove(buffer.data(), src, nb1);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## In Context Remediation 1\nIf you are certain that the source and destination do not overlap, document this assumption clearly and add runtime assertions to enforce it. This can help prevent accidental misuse in the future.\n\n```cpp\nassert(buffer.data() != nullptr && src != nullptr);\nassert((buffer.data() + nb1 <= src) || (src + nb1 <= buffer.data())); // Ensure no overlap\nmemcpy(buffer.data(), src, nb1);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2dc4f657-1f96-3c4a-b264-85598cc8d15a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination buffers may overlap, which can lead to undefined behavior. The analysis detected that the source and destination may refer to overlapping memory regions due to data flow between them. Additionally, there are no explicit checks to ensure that the source and destination are non-null, increasing the risk of null pointer dereference. The absence of guards or capacity checks further increases the risk. The source is a general identifier, and the overlap was determined via data flow analysis, making this a high-confidence issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(buffer.data() + b0, src, nb);\n```\n\nAdditionally, ensure that both `src` and `buffer.data() + b0` are not null and that `nb` does not exceed the bounds of the destination buffer. Add appropriate checks before the call:\n\n```cpp\nif (src != nullptr && buffer.data() != nullptr && nb <= buffer.size() - b0) {\n    memmove(buffer.data() + b0, src, nb);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9b9f1611-450e-36e8-a28d-51defe71bddc",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination buffers in a memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory, and the use of a standard memory copy function like memcpy in such a case can result in undefined behavior. Additionally, there is no evidence of explicit checks or guards to prevent this overlap, and the source may also be null, which further increases the risk. The destination buffer is a pointer with unknown capacity, and the count argument is not proven to be safe. All these factors indicate a real risk of memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination buffers safely. Replace the original call with:\n\n```cpp\nmemmove(dst, buffer.data(), nb2);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "649b1afd-bf2b-3fb8-ba10-4d6aa27fd77e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination memory regions in a memory copy operation. The analysis detected that the destination and source may refer to overlapping memory areas, which can cause undefined behavior when using functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source may also be null at this point, further increasing the risk. The destination is a pointer with unknown capacity, and the count used for copying is not proven to be safe. All these factors indicate a real risk of memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping memory areas. Replace the original call with:\n\n```cpp\nmemmove(dst, buffer.data() + b0, nb);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6786065e-61c7-3c7b-aca0-8deed6ba7411",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file name (`fname`) is manipulated by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `fopen`, consider using `fopen_s` which is a more secure alternative. Always validate and sanitize inputs to these functions to prevent any malicious manipulation.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with `fopen_s`:\n\n```cpp\nerrno_t err;\nFILE* f;\nerr = fopen_s(&f, fname, \"rb\");\nif (err != 0) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2c46a065-6a91-3b2c-ade3-26242e1cf925",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation (`memcpy`) where the source and destination memory regions may overlap. This can lead to undefined behavior according to the C standard, as `memcpy` is not safe for overlapping memory regions. The analysis detected a feasible dataflow path indicating that the destination may alias the source, which increases the risk of undefined behavior. Additionally, there are no explicit checks or guards in the code to prevent this overlap, and the source pointer could potentially be null, further increasing the risk. The destination pointer is not proven to be null, but this does not mitigate the overlap risk. The probability of this being a false positive is low because the overlap is supported by dataflow analysis and there are no mitigating guards or capacity checks.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace `memcpy` with `memmove`, which is designed to handle overlapping regions safely. For example, change the code to:\n\n```cpp\nmemmove(ptr, &data[rp], size * nitems);\n```\n\nThis ensures that the copy operation is performed correctly even if the source and destination overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dba21b98-c748-3a27-b3dd-15474d13c799",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can potentially introduce a security risk. In this case, the `fopen` function is used, which can lead to vulnerabilities such as arbitrary file overwrite, directory traversal, or other file-based attacks if the `fname` parameter is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen` that provide better control over file access and permissions. Also, always validate and sanitize input that will be used as a filename or a part of a filename. Avoid using user input to construct a filename if possible.\n\n## Source Code Fix Recommendation\n\nInstead of using `fopen`, consider using `fopen_s` which is a safer alternative. Here is an example of how to use it:\n\n```cpp\nerrno_t err;\nFILE* f;\nerr = fopen_s(&f, fname, \"wb\");\nif (err != 0) {\n    // Handle error\n}\n```\n\nIn this example, `fopen_s` returns an error code that can be checked to ensure the file was opened successfully.\n\n## Library Dependencies\n\nThe code example requires the `stdio.h` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0ccc6549-8f3d-3762-9d7b-1ead0627e652",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory, and this is not safe with the standard memory copy function. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null, which further increases the risk of undefined behavior. The classification specifically highlights the risk of undefined behavior due to possible overlap, and the verdict confirms this is a high-confidence issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use a memory move function that is safe for overlapping regions. Replace the memory copy function with a memory move function, which handles overlapping memory correctly. For example:\n\n```cpp\nmemmove(&data[o], ptr, size * nitems);\n```\n\nThis change ensures that even if the source and destination regions overlap, the operation will not result in undefined behavior. Additionally, consider adding checks to ensure that the source pointer is not null before performing the operation to avoid null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "537d19a5-2f2c-355f-afa6-a3db1a93df29",
              "help": {
                "text": "",
                "markdown": "This finding highlights a genuine risk of undefined behavior due to possible overlap between the source and destination memory regions in a memory copy operation. The analysis detected that the destination and source may refer to overlapping memory, as indicated by data flow from the destination to the source. In C and C++, using functions like memcpy with overlapping memory regions is undefined behavior and can lead to unpredictable results or security vulnerabilities. There is no evidence of explicit checks or guards to prevent this overlap, and the source may also be null, which further increases the risk. The destination is a pointer, and its capacity is not explicitly known, which means the safety of the operation cannot be guaranteed. Therefore, this is a genuine vulnerability that should be addressed to ensure memory safety.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping memory regions safely. Replace the original call with:\n\n```cpp\nmemmove(codes, best_codes.data(), sizeof(int32_t) * n * M);\n```\n\nThis change ensures that the copy operation is well-defined even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5733ed89-3957-3ebd-8a12-dc6f11e3f2b9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions in a memory copy operation. The destination and source expressions are derived from similar base pointers with index arithmetic, and dataflow analysis suggests that overlap is feasible. Additionally, there are no explicit checks to ensure that the source and destination do not overlap, and both pointers may be null at this call site, increasing the risk of undefined behavior. The use of memcpy in such a scenario is dangerous, as memcpy does not guarantee correct behavior when source and destination regions overlap. This can lead to data corruption or crashes. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not corrupt data even if the source and destination regions overlap.\n\n```cpp\nmemmove(best_codes.data() + i * M, codes + i * M, sizeof(int32_t) * M);\n```\n\nAlternatively, if you can guarantee that the source and destination never overlap, add explicit assertions or checks before the copy to document and enforce this assumption. For example:\n\n```cpp\nassert((best_codes.data() + i * M) != (codes + i * M));\nmemcpy(best_codes.data() + i * M, codes + i * M, sizeof(int32_t) * M);\n```\n\nHowever, using `memmove` is the safest and most portable solution if overlap is possible or cannot be ruled out.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1697bdaa-81e2-3606-8217-9dcee7c6a69d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The destination and source expressions are derived from similar base pointers and index calculations, and dataflow analysis suggests that overlap is feasible. The use of memcpy in such cases can lead to unpredictable results, as memcpy does not guarantee correct behavior when source and destination regions overlap. Additionally, there are no explicit checks or guards in the code to prevent this overlap, and the source pointer could potentially be null, further increasing the risk. This type of issue can result in data corruption or crashes at runtime.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping source and destination regions safely. This change ensures that the copy operation will not result in data corruption or unpredictable behavior if the regions overlap.\n\n```cpp\nmemmove(xslice + (i - i0) * dsub, x + i * d + m * dsub, dsub * sizeof(float));\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4fc94590-ccbf-3da5-bcd0-3627e5a6a1c4",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis suggests that the destination buffer may overlap with the source, which can cause unpredictable results with functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source may also be null, which further increases the risk. The classification specifically highlights undefined behavior due to overlapping memory, which is a well-known issue with memcpy. Developers should ensure that the source and destination do not overlap, or use a function that safely handles overlapping regions if overlap is possible.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping source and destination buffers. Replace the original call with:\n\n```cpp\nmemmove(x + m * pq.dsub, pq.get_centroids(m, c), sizeof(float) * pq.dsub);\n```\n\nThis change ensures that even if the source and destination regions overlap, the copy will be performed safely without causing undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c7ec45dd-3e5f-3145-abc9-3d1f90a92516",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping or even identical memory areas. This can cause undefined behavior with functions like memcpy, which do not support overlapping regions. Additionally, both the source and destination pointers may be null at this call site, and there are no explicit checks to prevent this. There is no evidence of a guard or capacity check, and the count argument is not directly tied to the destination's capacity. These factors increase the risk of a real issue, and the classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(clus.centroids.data(), get_centroids(m, 0), dsub * ksub * sizeof(float));\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the copy:\n\n```cpp\nfloat* dst = clus.centroids.data();\nfloat* src = get_centroids(m, 0);\nif (dst != nullptr && src != nullptr) {\n    memmove(dst, src, dsub * ksub * sizeof(float));\n}\n```\n\nThis change eliminates the risk of undefined behavior due to overlapping memory and null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "64a16ac3-1fc5-354c-9c7d-32ccab564618",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination regions may overlap in memory. The analysis detected that the destination and source expressions are related through data flow, which means that, depending on the values of the indices, the memory regions could overlap. This can lead to undefined behavior according to the C standard for memcpy. There is no evidence of a guard or check to prevent overlap, and the source and destination are not simple string literals or constant pointers, which would reduce the risk. Additionally, the source may be null, which could also cause a crash or further undefined behavior. Therefore, this is a high-confidence, actionable issue that should be addressed to ensure memory safety.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. For example, change the code to:\n\n```cpp\nmemmove(c + i * subdim, &cache[codes[i] * subdim], sizeof(*c) * subdim);\n```\n\nThis ensures that even if the source and destination overlap, the data will be copied correctly without causing undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8ee942d6-d2af-381d-8f9c-678c505933f2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination regions may overlap in memory. The analysis detected that the destination and source expressions are related through data flow, which means there is a realistic risk that they could refer to overlapping memory regions. In C and C++, using `memcpy` with overlapping memory is undefined behavior and can lead to data corruption or unpredictable program behavior. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer could potentially be null, which further increases the risk. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping memory. `memmove` ensures that the copy is performed correctly even if the regions overlap.\n\n```cpp\nmemmove(xslice + j * dsub, x + j * d + m * dsub, dsub * sizeof(float));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "152d10cc-34aa-3e85-ad1a-e1b6d9704173",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code involves a memory copy operation where the source and destination buffers may overlap in memory. The analysis detected that the destination and source expressions are related by dataflow, which means they could refer to overlapping regions. This can lead to undefined behavior according to the C standard for memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null, which further increases the risk. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent potential memory corruption or unpredictable program behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(&cache[i * dimsub], c.data() + dim - dimsub, dimsub * sizeof(*c.data()));\n```\n\nThis ensures that the copy operation is performed correctly even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ef78a412-d7eb-3021-8343-4edb683d13ac",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination memory regions may overlap. The analysis detected that the destination and source expressions are related by data flow, which means there is a realistic chance that the memory regions could overlap at runtime. If this happens, the behavior of memcpy is undefined, which can lead to data corruption or crashes. Additionally, there are no explicit checks to ensure that the source and destination pointers are not null, increasing the risk of undefined behavior. No evidence was found that the length argument is derived from the destination's capacity, and there are no guards to prevent underflow or null pointer dereference. All these factors contribute to the high confidence in this being a real issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. For example, change the code to:\n\n```cpp\nmemmove(xsub.data() + i * q->d, x + i * d + offset_d, q->d * sizeof(float));\n```\n\nThis ensures that even if the source and destination overlap, the data will be copied correctly without causing corruption or crashes. Additionally, consider adding checks to ensure that neither the source nor the destination pointers are null before performing the operation.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "af03e58b-f774-367e-94e8-f95f1ff8b59e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The destination and source expressions are both identifiers, and dataflow analysis indicates that the destination may be derived from the source, which can lead to overlap. The use of memcpy in such cases is unsafe, as memcpy does not guarantee correct behavior when source and destination overlap. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null, which further increases the risk of undefined behavior. The destination is a pointer type with unknown capacity, and the count expression is not directly tied to the destination's size, making it difficult to guarantee safety. These factors together confirm the presence of a real issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping regions safely. Replace the original call with:\n\n```cpp\nmemmove(xi, c, sizeof(*x) * q->d);\n```\n\nThis change ensures that the memory copy will work correctly even if `xi` and `c` overlap. Additionally, consider adding checks to ensure that the source pointer `c` is not null before performing the copy to avoid null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "870414e2-ee65-3b68-8f12-e5d65c184d74",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The code uses a memory copy function where the source and destination pointers may refer to overlapping regions, as indicated by the dataflow analysis. This can result in unpredictable behavior, data corruption, or crashes. Additionally, there are no explicit checks to ensure that the source and destination are not null, which further increases the risk. The absence of guards or evidence that the memory regions are distinct means this issue should be addressed to prevent undefined behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy operation works correctly even if the regions overlap.\n\n```cpp\nmemmove(xt.data() + i * q->d, x + i * d + offset_d, q->d * sizeof(*x));\n```\n\nAdditionally, consider adding explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation:\n\n```cpp\nif (xt.data() && x) {\n    memmove(xt.data() + i * q->d, x + i * d + offset_d, q->d * sizeof(*x));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e072c7fe-67ca-3a7a-9545-684762dd0b88",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible risk of undefined behavior due to overlapping memory regions between the source and destination in a memory copy operation. The destination and source expressions are related by data flow, which means that under certain conditions, they could refer to overlapping memory. This can cause unpredictable results or crashes, as the standard memory copy function does not handle overlapping regions safely. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null, which further increases the risk. The destination is a pointer, and its capacity is not known, which adds to the uncertainty and risk. Therefore, this is a high-confidence, actionable issue that should be addressed to prevent undefined behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use a memory copy function that is safe for overlapping regions. In C/C++, `memmove` is designed for this purpose. Replace the original memory copy call with `memmove` to ensure correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(cb, q->codebooks.data(), sub_codebook_size * sizeof(float));\n```\n\nAlternatively, ensure by code logic or explicit checks that the source and destination do not overlap before calling `memcpy`. If overlap is not possible by design, document this assumption clearly in the code with assertions or comments.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3ce35f57-9bc2-3827-bb78-1cb8337ddb40",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior with functions like memcpy. There are no explicit checks or guards in the code to prevent this overlap, and both the source and destination are not null at the call site, so the risk is not mitigated by null checks. The use of memcpy when source and destination may overlap is unsafe and can lead to unpredictable program behavior or data corruption.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. This change ensures that the copy operation will not result in data corruption or unpredictable behavior if the regions overlap.\n\n```cpp\nmemmove(xi, c, sizeof(*x) * q->d);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1d70bb79-65c8-3ed4-a529-0bda9dbc1673",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable behavior. Additionally, there are no explicit checks to ensure that the source and destination are non-null, increasing the risk of null pointer dereference. The absence of guards or evidence that the count is derived from the destination's capacity further increases the risk. This issue should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit null pointer checks for both the source and destination before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (ail && vec.data() && ail->codes[i].data()) {\n    // Use memmove to safely handle possible overlap\n    memmove(ail->codes[i].data(), vec.data(), ail->codes[i].size());\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0470a315-ab4a-3a76-95d4-ba955ab8ab05",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The dataflow analysis indicates that the destination buffer may overlap with the source buffer, which can cause undefined behavior when using functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null at this point, further increasing the risk. The destination buffer is a pointer type with unknown capacity, and the count argument is not directly tied to the destination's size, making it difficult to guarantee safety. These factors together confirm the presence of a real issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. For example, change the code to:\n\n```cpp\nmemmove(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis));\n```\n\nThis ensures that the memory copy will work correctly even if the source and destination buffers overlap. Additionally, consider adding checks to ensure that the source pointer is not null before performing the copy to avoid null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "51c9f610-24b4-3eed-a8b8-2ceab3119963",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination buffers in a memory copy operation. The source and destination expressions are related by data flow, which increases the likelihood of overlap. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may be null at this point, further increasing the risk. The destination buffer is a pointer type, and its capacity is not known, which adds to the uncertainty. The classification specifically highlights the undefined behavior risk due to possible overlap, and the verdict is marked as genuine, indicating a high-confidence issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. `memmove` is specifically designed to handle overlapping memory areas, whereas `memcpy` is not. For example, change the code to:\n\n```cpp\nmemmove(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids));\n```\n\nThis ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "811d38f3-c76e-39ac-be38-c0ba5fe748cd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fprintf` function is used, which can lead to format string vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `fprintf`, consider using `fputs` or `fwrite` which do not interpret the format string. Always validate and sanitize input data before using it in such functions.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code:\n\n```cpp\nfputs(\"read_InvertedLists: WARN! inverted lists not stored with IVF object\\n\", stderr);\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `stdio.h`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e28b967e-a65a-3db9-ab26-e014990fba94",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a program uses insecure or deprecated C library functions. In this case, the `fopen` function is used, which can lead to various security risks such as buffer overflows or format string vulnerabilities. \n\nThe `fopen` function is used to open a file, but it does not perform any checks on the validity of the filename. This can lead to vulnerabilities if the filename is in any way influenced by user input, as it could lead to opening of unintended files or even execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen`. In C++, the `fstream` library provides the `ofstream` and `ifstream` classes which can be used to open files for writing and reading respectively. These classes provide more robust error checking and are less prone to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ofstream` class from the `fstream` library. The fixed code would look like this:\n\n```cpp\n#include <fstream>\n\nstd::ofstream optim_logfile(fname);\nif (!optim_logfile) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstdio` for the `fopen` function\n\nThe fixed code requires the following library:\n\n- `fstream` for the `ofstream` class\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "50c00415-ff37-3c87-b1b5-00c467c2ab27",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string is not controlled by the programmer or if user-supplied data is used as part of the format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `printf` such as `fprintf`, `sprintf`, or `snprintf` with a maximum buffer size specified. Additionally, always control the format string and never use user-supplied data as part of the format string.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `snprintf`:\n\n```cpp\nchar buffer[100];\nsnprintf(buffer, sizeof(buffer), \"   m=%d, nq=%zd, nb=%zd, initialize RankingScore \"\n                   \"in %.3f ms\\n\",\n                   m,\n                   nq,\n                   nb,\n                   getmillisecs() - t0);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for `printf` or `snprintf`\n- `<ctime>` or `<sys/time.h>` for `getmillisecs()`, depending on how this function is implemented\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5f984b00-e9dd-388f-b5fe-40f9fe14d1c5",
              "help": {
                "text": "",
                "markdown": "This finding highlights a real risk of undefined behavior due to possible overlapping memory regions in a memory copy operation. The analysis detected that the source and destination pointers may refer to overlapping regions of memory, as indicated by the data flow relationship between them. This is a well-known source of subtle bugs and security vulnerabilities in C/C++ code, as the standard memory copy function does not guarantee correct behavior when source and destination overlap. Additionally, there is no evidence of explicit checks or guards to prevent this overlap, and the source pointer may also be null, which further increases the risk. The classification and verdict both indicate a genuine vulnerability that should be addressed to prevent potential data corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with a function that is safe for overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is specifically designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(centroids + perm[i] * dsub, centroids_copy.data() + i * dsub, dsub * sizeof(centroids[0]));\n```\n\nThis change ensures that even if the source and destination regions overlap, the data will be copied correctly without causing undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "021f3c2c-16c9-3c36-adda-160d4c1eb053",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The dataflow analysis indicates that the destination buffer may overlap with the source buffer, which can lead to unpredictable results when using functions like memcpy. Additionally, there are no explicit checks ensuring that the source and destination are non-null, increasing the risk of null pointer dereference. No evidence of bounds checking or overlap prevention is present in the surrounding code. This combination of factors makes the issue actionable and not a likely false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(gt_distances.data(), pq.sdc_table.data() + m * nq * nb, sizeof(float) * nq * nb);\n```\n\nAdditionally, ensure that both source and destination pointers are not null before performing the copy:\n\n```cpp\nif (gt_distances.data() != nullptr && pq.sdc_table.data() != nullptr) {\n    memmove(gt_distances.data(), pq.sdc_table.data() + m * nq * nb, sizeof(float) * nq * nb);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3bbec019-e182-3e3a-8884-924dd7f0bf62",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination buffers in a memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which can cause undefined behavior with functions like memcpy. There are no explicit checks or guards in the code to prevent this overlap, and the function does not use a safer alternative that handles overlapping memory. Both the source and destination are confirmed to be non-null, so the main risk is the potential for memory overlap, which can lead to data corruption or unpredictable program behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping memory. This change ensures that the copy operation will not result in data corruption or unpredictable behavior if the regions overlap.\n\n```cpp\nmemmove(vmin, x, sizeof(*x) * d);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6f66c3aa-50ec-3d84-9e94-00c1e4cb4790",
              "help": {
                "text": "",
                "markdown": "This finding highlights a real risk of undefined behavior due to possible overlapping memory regions in a memory copy operation. The analysis detected that the source and destination pointers may refer to overlapping areas of memory, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, there are no explicit checks to ensure that the source and destination are not null, which could also lead to crashes or further undefined behavior. The risk is further supported by the dataflow analysis indicating a potential overlap, and the absence of any guards or capacity checks. Therefore, this is considered a genuine vulnerability that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of memcpy with memmove, which is designed to handle overlapping regions safely. Ensure that both the source and destination pointers are valid and not null before performing the operation.\n\n```cpp\nif (xtrain.data() && x) {\n    memmove(xtrain.data() + i * dsub, x + i * pq.d + m * dsub, sizeof(float) * dsub);\n}\n```\n\nThis change ensures that the memory copy is safe even if the regions overlap, and adds a basic null check to avoid dereferencing null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d86b9265-3668-3194-a301-08a8961b7e47",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of memory corruption. In this case, the `printf` function is used, which can lead to format string vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, you can use `fprintf` or `snprintf` which are safer as they limit the number of characters to be printed, thus preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\n#include <cstdio>\n\n// ...\n\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"      iteration %d cost %g temp %g n_swap %d \"\n                   \"(%d hot)     \\r\",\n                   it,\n                   cost,\n                   temperature,\n                   n_swap,\n                   n_hot);\nfputs(buffer, stdout);\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`: This library provides functions for performing input and output operations.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and may not be available in the future."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "92936ba7-557c-3fa7-acd2-7fd793592b88",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the code uses a memory copy operation where the source and destination memory regions may overlap. The analysis detected that the destination and source expressions are derived from the same base (likely the same array or buffer), and dataflow analysis confirms that overlap is feasible. In such cases, using memcpy can result in undefined behavior if the regions overlap, which can lead to data corruption or crashes. There is no evidence of a guard or check to prevent overlap, and the source pointer may also be null, increasing the risk. The classification explicitly states undefined behavior risk due to possible overlap, and the verdict is marked as genuine.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with `memmove`, which is designed to handle overlapping regions safely. This change ensures that the data is copied correctly even if the regions overlap.\n\n```cpp\nmemmove(centroids + perm[i] * dsub, centroids_copy.data() + i * dsub, dsub * sizeof(centroids[0]));\n```\n\nAlternatively, ensure by code logic or explicit checks that the source and destination regions never overlap before calling `memcpy`. If overlap is impossible by design, document this with comments and assertions to make the intent clear.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5ea9d47f-64dd-3f55-aa04-e7203db2b072",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible risk of undefined behavior due to overlapping memory regions between the source and destination in a memory copy operation. The code uses a memory copy function to copy data from one buffer to another, and dataflow analysis suggests that the source and destination may overlap. This can lead to unpredictable results or program crashes, as the standard memory copy function does not guarantee correct behavior when the source and destination overlap. There are no explicit checks or guards in the code to prevent this overlap, and the destination buffer's capacity is not known, increasing the risk. The source and destination are both identified as pointers, and the overlap was determined through dataflow analysis, which increases the confidence in the finding. The source is not a string literal or constant, so the risk of overlap is not reduced by the nature of the source. Both the source and destination are confirmed to be non-null, so the primary concern is the potential for overlapping memory regions.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. Replace the original memory copy call with `memmove` to ensure correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(vmax, x, sizeof(*x) * d);\n```\n\nThis change ensures that the copy operation is performed safely, regardless of whether the source and destination buffers overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a27a49a3-24ca-3339-b76d-940a9c0aff8f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a program uses insecure or deprecated C library functions. In this case, the `fopen` function is used, which can lead to various security risks such as buffer overflows or format string vulnerabilities. \n\nThe `fopen` function is used to open a file, but it does not perform any checks on the validity of the filename. This can lead to vulnerabilities if the filename is in any way influenced by user input, as it could lead to opening of unintended files or even execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen`. In C++, the `fstream` library provides the `ofstream` and `ifstream` classes which can be used to open files for writing and reading respectively. These classes provide more robust error checking and are less prone to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ofstream` class from the `fstream` library. The fixed code would look like this:\n\n```cpp\n#include <fstream>\n\nstd::ofstream optim_logfile(fname);\nif (!optim_logfile) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstdio` for the `fopen` function\n\nThe fixed code requires the following library:\n\n- `fstream` for the `ofstream` class\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "966568b5-d63b-3190-a055-a35507bef0d4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "377f7004-546d-3dd9-a52f-8f4208f6e90a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "76a2213e-9de5-39cb-96b8-ade4f56ef25a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "0b79b6d8-127b-303a-adad-eb079c883444",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "aa176703-4dad-37ad-a8ae-7052aed91d0f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The verdict is supported by the fact that the data flow analysis indicates that the destination buffer may overlap with the source buffer, which can lead to undefined behavior when using functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null at this point, further increasing the risk. The source and destination are both pointers, and the count argument is not directly tied to the destination's capacity, which means there is no guarantee that the operation is safe. The source kind is not a string literal or C string, so the overlap risk is not reduced. Therefore, this is a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(best_perm, perm.data(), sizeof(perm[0]) * n);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination buffers overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "62a53627-6b59-3f69-9d5e-87a3e13c3e38",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "7805de82-ccb9-3258-8dba-b1999b6d2f0f",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the code uses a memory copy operation where the source and destination buffers may overlap, which can result in undefined behavior according to the C standard. The analysis detected that the source and destination may refer to overlapping memory regions due to data flow between them. There is no evidence of a guard or check to prevent this overlap, and the destination pointer may also be null, increasing the risk. The source is not a string literal or a constant, so the risk of overlap is not reduced. This type of issue can lead to unpredictable program behavior, data corruption, or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(x_copy.data(), x, n * sizeof(*x));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination buffers overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bd247ac0-9838-3c52-b1d8-36a7df58ed5d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which can cause undefined behavior with functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source may also be null at this point, further increasing the risk. The destination is not a pointer-based member, suggesting it is likely a local or field array, but this does not mitigate the overlap risk. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n```\n\nAdditionally, ensure that `ids_in` is not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (ids_in != nullptr) {\n    memmove(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "33738c62-12bb-3d8a-8fff-b56aa81a315f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "4f9f6ccf-6eaf-31de-b069-e5a191a99b7b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "62d96ae8-9ad6-3890-9544-8435b41852e2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8c89d273-2481-32bb-836a-44ffb7f16096",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The destination and source expressions are related by data flow, which means that under certain conditions, they may refer to overlapping memory areas. This can cause undefined behavior with functions like memcpy, which do not support overlapping regions. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source may also be null, increasing the risk. The destination appears to be a local or field array, reducing the risk of null pointer dereference for the destination, but the overlap risk remains the primary concern.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(&codes[list_no][o * code_size], code, n_block * block_size);\n```\n\nThis change ensures that even if the source and destination regions overlap, the memory copy will be performed correctly and safely.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "65ce472d-9ffe-31f2-9bc9-28a6b3b1930d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which can cause undefined behavior with functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source may also be null at this point, further increasing the risk. The destination is not a pointer-based member, suggesting it is likely a local or field array, but this does not mitigate the overlap risk. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n```\n\nAdditionally, ensure that `ids_in` is not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (ids_in != nullptr) {\n    memmove(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "66085b83-2001-397a-a1fd-229a1b75ab05",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in C++ refers to the use of weak or broken cryptographic hash functions. These functions are susceptible to various types of attacks, such as collision attacks, preimage attacks, and second preimage attacks. \n\nIn the context of C++, the MD2 hash function is considered weak and vulnerable. It is a cryptographic hash function with a 128-bit hash value. It was widely used for securing passwords and other sensitive data. However, it is now considered to be broken and unsuitable for further use.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use stronger hash functions such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not known to have any significant vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the use of MD2 with a stronger hash function. For example, if you are using the OpenSSL library, you can replace the use of the `MD2` function with the `SHA256` function.\n\n```cpp\n// Old vulnerable code\nunsigned char digest[MD2_DIGEST_LENGTH];\nMD2((unsigned char*)&data, sizeof(data), (unsigned char*)&digest); \n\n// Recommended fix\nunsigned char digest[SHA256_DIGEST_LENGTH];\nSHA256((unsigned char*)&data, sizeof(data), (unsigned char*)&digest);\n```\n\n## Library Dependencies\n\nThe OpenSSL library is required for the code example to execute properly.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "0228618e-67ca-3c8c-9643-cfbd42b6b5dc",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination buffers in a memory copy operation. The dataflow analysis indicates that the destination buffer may be derived from the source, which can lead to overlap. The use of memcpy in such cases is unsafe, as the C standard does not define behavior for overlapping memory regions with memcpy. Additionally, there is no evidence of explicit checks or guards to prevent this overlap, and the source pointer may also be null, which further increases the risk of undefined behavior. The classification and verdict both indicate a high-confidence issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of memcpy with memmove, which is designed to handle overlapping source and destination buffers safely. For example, change the code to:\n\n```cpp\nmemmove(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr));\n```\n\nThis ensures that the copy operation is safe even if the source and destination regions overlap. Additionally, consider adding explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f2668f77-7e12-3200-ac08-27afd13e71ea",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the code copies memory from one buffer to another using a function that is not safe when the source and destination memory regions overlap. The analysis detected that the source and destination may refer to overlapping memory regions due to data flow between them. This can result in undefined behavior, which may cause data corruption or crashes. Additionally, there is no evidence of explicit checks or guards to prevent this overlap, and the source pointer may also be null, which further increases the risk. The use of a raw memory copy function without overlap protection is particularly dangerous in this context.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, `memmove` is designed for this purpose. Replace the original call with:\n\n```cpp\nmemmove(out_distances, distances_ptr, distances_size * sizeof(*distances_ptr));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination buffers overlap. Additionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "037da8d4-ba58-3c16-8d0a-bdd979bceca8",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the code copies memory from one buffer to another using a function that is not safe when the source and destination memory regions overlap. The analysis detected that the source and destination may refer to overlapping memory regions due to data flow between them. This can result in undefined behavior, which may cause data corruption or program crashes. Additionally, there is no evidence of a guard or check to ensure that the source and destination do not overlap, and the source pointer may also be null, which further increases the risk. The destination buffer's capacity is not known, and the count argument is not directly tied to the destination's size, which means buffer overflows are also possible. The use of a standard memory copy function in this context is unsafe when overlap is possible.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that is safe for overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory safely. For example:\n\n```cpp\nmemmove(out_residuals, residuals_ptr, residuals_size * sizeof(*residuals_ptr));\n```\n\nThis change ensures that the copy operation is performed correctly even if the source and destination buffers overlap, eliminating the risk of undefined behavior.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1d749b2c-cff0-3421-bd7e-48d9f545b0ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, and integer overflows. In the provided code snippet, the `printf` function is used, which can lead to format string vulnerabilities if the format string contains user-supplied data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, one can use `fprintf` or `snprintf` which are safer as they limit the number of characters to be printed, thus preventing buffer overflow attacks.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s] encode stage %d, %d bits, \"\n                   \"total error %g, beam_size %d\\n\",\n                   (getmillisecs() - t0) / 1000,\n                   m,\n                   int(rq.nbits[m]),\n                   sum_distances,\n                   beam_size);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for `printf`, `snprintf`, and `puts` functions.\n- `<time.h>` if `getmillisecs` function is implemented using standard C time functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3213c710-6b62-300e-8aa2-9c9a98155fa3",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination buffers in a memory copy operation. The dataflow analysis indicates that the destination buffer may be used as the source, which can lead to undefined behavior when using functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null, increasing the risk. The destination buffer is a pointer type with unknown capacity, and there is no indication that the length argument is derived from the destination's capacity. These factors all contribute to the high confidence in this being a real issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination buffers may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory regions safely. For example, change the code to:\n\n```cpp\nmemmove(out_distances, pool.distances.data(), distances_size * sizeof(pool.distances[0]));\n```\n\nThis ensures that even if the source and destination buffers overlap, the memory copy will be performed correctly without causing undefined behavior. Additionally, consider adding explicit checks to ensure that neither pointer is null before performing the operation.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "aa1cab7a-5cd8-3292-9346-03252528663a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination buffers may overlap. The analysis detected that the destination buffer may be derived from the source buffer, which can lead to undefined behavior according to the C standard for memcpy. The risk is further increased because there is no evidence of a guard to prevent overlap, and the source pointer could potentially be null, which would also result in undefined behavior. The destination buffer is a pointer type, and its capacity is not explicitly known, which adds to the uncertainty. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with `memmove`, which is designed to handle overlapping regions safely. This change ensures that the data is copied correctly even if the source and destination overlap.\n\n```cpp\nmemmove(new_codes_i, codes_i + js * m, sizeof(*codes) * m);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5fbba3c0-4c4c-35ec-86db-b14ca14cb6bc",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, and integer overflows. In the provided code snippet, the `printf` function is used, which can lead to format string vulnerabilities if the format string is not controlled by the programmer or if user-supplied data is used as a format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, one can use `fprintf` or `snprintf` which are safer as they limit the amount of data that can be written, thus preventing buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s] encode stage %d, %d bits, \"\n                   \"total error %g, beam_size %d\\n\",\n                   (getmillisecs() - t0) / 1000,\n                   m,\n                   int(rq.nbits[m]),\n                   sum_distances,\n                   cur_beam_size);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<stdio.h>` for `printf`, `snprintf`, and `puts` functions.\n- `<time.h>` if `getmillisecs` function is used to get the current time in milliseconds.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c09f8625-1aec-3f91-afc6-96755c3547fc",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination buffers in a memory copy operation. The code uses a direct memory copy function, and dataflow analysis suggests that the source and destination may refer to overlapping memory, which is not allowed for this function and can result in unpredictable behavior. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null, which further increases the risk. The destination buffer is a pointer type, and its capacity is not known, which means there is no guarantee that the copy size is safe. All these factors indicate a real risk of undefined behavior due to overlapping memory regions.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination buffers safely.\n\n**Remediation Example:**\n\n```cpp\nmemmove(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr));\n```\n\nThis change ensures that the memory copy will work correctly even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3b6fa39f-d4af-3e28-8249-5e81081edac8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, and integer overflows. In the provided code snippet, the `printf` function is used, which can lead to format string vulnerabilities if not used properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, you can use `fprintf` or `snprintf` which are safer as they limit the amount of output.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```cpp\n#include <cstdio>\n\nint main() {\n    int iter = 10;\n    fprintf(stdout, \"re-estimating the codebooks to minimize \"\n                    \"quantization errors (iter %d).\\n\",\n                    iter);\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdio` library.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-community/attacks/Format_string_attack)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "689c600e-ae99-3a4e-a3e5-c898414bc490",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code performs a memory copy operation without verifying that either the source or destination pointers are non-null. If either pointer is null, this will result in undefined behavior, which can lead to crashes or potential security issues. The analysis did not detect any prior checks ensuring that the source or destination are valid, and both are flagged as potentially null. The risk is not mitigated by any guards or capacity checks, and the operation is not proven safe by construction. Therefore, this is a high-confidence issue that should be addressed to prevent undefined behavior.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that both the source and destination pointers are not null. This prevents undefined behavior if either pointer is invalid. For example:\n\n```cpp\nif (this->codebooks.data() != nullptr && codebooks.data() != nullptr) {\n    memcpy(this->codebooks.data() + codebook_offsets[m] * d, codebooks.data(), codebooks.size() * sizeof(codebooks[0]));\n} else {\n    // Handle error: one or both pointers are null\n}\n```\n\nAlternatively, if you are certain by design that these pointers can never be null, document this assumption clearly and consider using assertions to catch programming errors during development:\n\n```cpp\nassert(this->codebooks.data() != nullptr);\nassert(codebooks.data() != nullptr);\nmemcpy(this->codebooks.data() + codebook_offsets[m] * d, codebooks.data(), codebooks.size() * sizeof(codebooks[0]));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8aeb9193-400a-3370-a64f-b5589fdb407e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string is not controlled completely by the program, or if the arguments do not match the directives in the format string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `printf` such as `snprintf` or `fprintf`. These functions allow for the specification of a maximum length of the output string, which can prevent buffer overflows. Additionally, it is important to ensure that the format string is not user-controlled and that the arguments match the directives in the format string.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `snprintf`:\n\n```cpp\nchar buffer[200];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s, %.3f s clustering] train stage %d, %d bits, kmeans objective %g, \"\n                   \"total distance %g, beam_size %d->%d (batch size %zd)\\n\",\n                   (getmillisecs() - t0) / 1000,\n                   clustering_time,\n                   m,\n                   int(nbits[m]),\n                   obj,\n                   sum_distances,\n                   cur_beam_size,\n                   new_beam_size,\n                   bs);\n```\n\n## Library Dependencies\n\nThe code example does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7de317c0-460f-3b18-acca-8bda9c60e47e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code performs a memory copy operation without verifying that the source and destination pointers are non-null. If either pointer is null, this can result in undefined behavior, such as a crash or potential security issue. The analysis did not detect any prior checks ensuring that the pointers are valid before the operation. The risk is further supported by the fact that both the source and destination may be null, and there are no guards or capacity checks in place. The probability of this being a false positive is moderate, as in some contexts the pointers may be guaranteed non-null by design, but this is not evident from the code at this location.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that both the source and destination pointers are not null. This prevents undefined behavior if either pointer is invalid. For example:\n\n```cpp\nif (residuals1.data() != nullptr && residuals.data() != nullptr) {\n    memcpy(residuals1.data() + j * d, residuals.data() + j * d * cur_beam_size, sizeof(residuals[0]) * d);\n} else {\n    // Handle error: one or both pointers are null\n}\n```\n\nAlternatively, if you know by design that these pointers can never be null, document this assumption clearly in the code and consider using assertions to enforce it during development:\n\n```cpp\nassert(residuals1.data() != nullptr && \"residuals1.data() must not be null\");\nassert(residuals.data() != nullptr && \"residuals.data() must not be null\");\nmemcpy(residuals1.data() + j * d, residuals.data() + j * d * cur_beam_size, sizeof(residuals[0]) * d);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0b329990-7068-3021-af51-00a62557defb",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination buffers may overlap, which can result in undefined behavior according to the C/C++ standard. The analysis detected that the source and destination may be related through data flow, increasing the risk of overlap. Additionally, there are no explicit checks to ensure that the source and destination are distinct, and there are no guards to prevent null pointer dereferences for either buffer. The source and destination are both obtained via dynamic data accessors, and the operation does not use a function that is safe for overlapping memory regions. This combination of factors makes the issue actionable and not a likely false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with `memmove`, which is designed to safely handle overlapping regions. This change ensures that the copy is performed correctly even if the buffers overlap.\n\n```cpp\nmemmove(nbits.data(), other.nbits.data() + skip_M, nbits.size() * sizeof(nbits[0]));\n```\n\nAdditionally, consider adding explicit null pointer checks for both the source and destination before performing the operation to avoid potential null pointer dereferences.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "796bc0f1-54c8-3ab2-8ad8-2b8d2364f7bd",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination buffers may overlap. The analysis detected that the destination buffer may be derived from the source buffer through data flow, which can lead to undefined behavior in C/C++ when using functions like memcpy. Additionally, there is no evidence of explicit checks or guards to prevent this overlap, and the source pointer could potentially be null, further increasing the risk. The destination buffer is a pointer type, and its capacity is not known, which adds to the uncertainty. Overlapping memory regions with memcpy is not safe and can cause unpredictable results or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with `memmove`, which is designed to handle overlapping regions safely. For example, change the code to:\n\n```cpp\nmemmove(new_codes_i, codes_i + js * m, sizeof(*codes) * m);\n```\n\nThis ensures that the data is copied correctly even if the source and destination buffers overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e95e1201-8c57-31fa-abb0-725ef3106ca9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination buffers may overlap. The analysis detected that the destination buffer may be derived from the source buffer through data flow, which can lead to undefined behavior when using memcpy. Additionally, there are no explicit checks or guards to prevent this overlap, and the source pointer could potentially be null, further increasing the risk. The destination buffer is a pointer type, and its capacity is not explicitly known, which adds to the uncertainty. Overlapping memory regions with memcpy is not safe and can cause unpredictable results or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with `memmove`, which is designed to handle overlapping regions safely. For example, change the code to:\n\n```cpp\nmemmove(new_codes_i, codes_i + js * m, sizeof(*codes) * m);\n```\n\nThis ensures that the copy will work correctly even if the source and destination buffers overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e370e54a-532f-3817-b473-6d750b5cfcbb",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The destination and source expressions are both derived from similar data structures, and dataflow analysis indicates that the destination may overlap with the source. The use of memcpy in such cases is unsafe, as memcpy does not guarantee correct behavior when source and destination regions overlap. Additionally, there is no explicit guard or check to ensure that the source and destination do not overlap, and the source pointer may also be null at this point, which could lead to a crash. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation works correctly even if the source and destination regions overlap.\n\n```cpp\nmemmove(codebooks.data(), other.codebooks.data() + other.codebook_offsets[skip_M] * d, codebooks.size() * sizeof(codebooks[0]));\n```\n\nAdditionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy to avoid potential crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "55832926-9b88-31cd-b897-314138476b4d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the code. These functions are prone to various types of security vulnerabilities such as buffer overflows, format string vulnerabilities, integer overflows, etc. The specific sink `ails->ptr != MAP_FAILED` is not a prohibited C function itself, but it's related to the use of `mmap` function which can lead to vulnerabilities if not used properly.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. If you must use them, ensure that you handle all possible error conditions. Always validate and sanitize input data. Use secure alternatives to these functions whenever possible.\n\n## Source Code Fix Recommendation\n\nThe `mmap` function is used to map files or devices into memory. It can return `MAP_FAILED` in case of an error. The correct way to use it is to always check the return value against `MAP_FAILED` before using the returned pointer.\n\n```cpp\nvoid* ptr = mmap(...);\nif (ptr == MAP_FAILED) {\n    // handle error\n} else {\n    // use ptr\n}\n```\n\n## Library Dependencies\n\nThe `mmap` function is part of the POSIX library. To use it, you need to include the `sys/mman.h` header file.\n\n```cpp\n#include <sys/mman.h>\n```\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1d886a41-cf71-3977-abb2-58039de5f671",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of potentially unsafe C standard library functions which can lead to various security issues such as buffer overflows, format string vulnerabilities, and others. In the provided code snippet, the `printf` function is used, which can lead to format string vulnerabilities if the format string contains user-supplied data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `printf`, consider using `fprintf` or `snprintf` which are safer as they allow to specify the maximum number of characters to be written to the output buffer, thus preventing buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"IO_FLAG_ONDISK_SAME_DIR: updating ondisk filename from %s to %s\\n\", od->filename.c_str(), filename.c_str());\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdio.h>` for `snprintf` and `puts` functions.\n- `<string>` for `std::string` and its `c_str` method.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "146d6b8d-9500-30e4-acbf-b793742fe9fc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The dataflow analysis indicates that the destination and source may overlap, which can cause undefined behavior with functions like memcpy. Additionally, there are no explicit checks or guards in the code to prevent this overlap, and the source pointer could potentially be null, further increasing the risk. The source is not a string literal or a constant, so the overlap risk is not mitigated by the nature of the source. The destination is not clearly a pointer-based member, but this does not eliminate the risk. Therefore, this is a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. This change ensures that the copy operation will not result in memory corruption even if the regions overlap.\n\n```cpp\nmemmove(ptr + new_l.offset + new_l.capacity * code_size, get_ids(list_no), n * sizeof(idx_t));\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "98f2fc2f-9d60-3167-a4ca-f0520e7e341d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured URL Vulnerability in C++ is a security flaw that occurs when a program does not validate or incorrectly validates the URL before it's used in a network operation. This can lead to various attacks such as phishing, URL redirection to untrusted sites, and remote code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n- Always validate URLs before using them in network operations.\n- Use secure functions that perform URL validation.\n- Avoid using user-supplied data in URLs without proper validation and sanitization.\n- Use libraries that support URL encoding and decoding.\n\n## Source Code Fix Recommendation\n\nThe following is a simple example of how to validate a URL using the `Poco` library in C++:\n\n```cpp\n#include <Poco/URI.h>\n\nint main() {\n    std::string url = \"http://www.netlib.org\";\n    Poco::URI uri;\n    try {\n        uri = Poco::URI(url);\n    } catch (Poco::Exception& ex) {\n        std::cerr << \"Invalid URL: \" << ex.displayText() << std::endl;\n        return -1;\n    }\n    return 0;\n}\n```\n\n## Library Dependencies\n\nThe above code example requires the `Poco` library. You can install it using the following command:\n\n```bash\nsudo apt-get install libpoco-dev\n```\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n- [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)"
              },
              "properties": {
                "tags": [
                  "DS137138"
                ]
              }
            },
            {
              "id": "11784b33-ea2d-3411-b7a4-9b55e3fb520c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination memory regions in a memory copy operation. The analysis detected that the destination and source may overlap based on data flow, which can lead to undefined behavior when using functions like memcpy. Additionally, there are no explicit checks to ensure that the source and destination do not overlap, and both pointers may be null at this call site, increasing the risk. No evidence was found that the length/count is derived from the destination's capacity, and there are no guards to prevent underflow or null pointer dereference. This combination of factors makes the issue actionable and not a likely false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. Ensure that both the source and destination pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (new_lists.data() != nullptr && &lists[l0] != nullptr) {\n    memmove(new_lists.data(), &lists[l0], (l1 - l0) * sizeof(List));\n}\n```\n\nThis change ensures that the copy operation is safe even if the memory regions overlap, and it avoids undefined behavior. Always validate pointers before use to prevent null pointer dereference vulnerabilities.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "829d1dd4-e357-3254-a241-891b8e5a8158",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. In the provided code snippet, the function `strerror(errno)` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `strerror(errno)`, a safer alternative would be `strerror_r(errno, buf, buflen)`, which is thread-safe.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nchar buf[1024];\nFAISS_THROW_IF_NOT_FMT(ret == 0, \"fstat failed: %s\", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<errno.h>`: for `errno`\n- `<string.h>`: for `strerror_r(errno)`\n- `<sys/stat.h>`: for `fstat`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that all the provided links are active and accessible by anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "17c9bad1-4dfb-3ab8-be94-9df7f03d028d",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which can cause undefined behavior with functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source may also be null, increasing the risk. The classification specifically highlights undefined behavior due to possible overlap, and the verdict confirms this as a genuine issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(ids + offset, ids_in, sizeof(ids_in[0]) * n_entry);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f1869165-b929-3ebf-ab27-b2097321677a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The dataflow analysis suggests that the destination and source may overlap, which can cause undefined behavior with functions like memcpy. There are no explicit checks or guards in the code to prevent this overlap, and the source and destination are not proven to be distinct. Additionally, the source may be null, which further increases the risk. Since the classification is 'UB Risk: possible src/dst overlap' and the verdict is 'GENUINE', this is considered a high-confidence issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(ptr + new_l.offset, get_codes(list_no), n * code_size);\n```\n\nThis change ensures that even if the source and destination regions overlap, the memory will be copied correctly without causing undefined behavior.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fd9b7f22-eff3-399a-94da-50a1c2e20523",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can potentially introduce a security risk. In the context of C++ programming, certain C library functions are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service.\n\nIn the provided code snippet, the function `fopen` is used, which is a standard C library function for opening a file. The vulnerability arises when the filename is manipulated in a way that it points to a location that the program should not have access to, leading to potential unauthorized file system access.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to use these functions in a way that their risks are minimized. In the case of `fopen`, it is important to ensure that the filename cannot be manipulated to point to an unintended location.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ofstream f;\nf.open(filename.c_str(), std::ios::out);\nif (!f.is_open()) {\n    // Handle error\n}\n```\n\nIn this fixed code, the C++ `std::ofstream` is used instead of the C `fopen` function. This provides better type safety and exception handling.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "886f4aac-e5fe-3289-a467-e133d81a4541",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. In the provided code snippet, the function `strerror` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using non-thread-safe functions or those that can lead to buffer overflows or other security issues. Instead, use safer alternatives provided by the language or third-party libraries. In the case of `strerror`, a thread-safe alternative `strerror_r` can be used.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with `strerror_r`:\n\n```cpp\nchar buf[1024];\nFAISS_THROW_IF_NOT_FMT(err == 0, \"munmap error: %s\", strerror_r(errno, buf, sizeof(buf)));\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- `cstring` for `strerror` function.\n- `cerrno` for `errno`.\n- `stdexcept` for `runtime_error`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9fdb8f84-49f3-3364-9160-2e20b247a0f9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which can cause undefined behavior with functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source may also be null at this point, increasing the risk. The destination buffer's capacity is not known, and the count argument is not directly tied to a known safe value. These factors all contribute to the high confidence in this being a real issue that could lead to memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace `memcpy` with `memmove`, which is designed to handle overlapping source and destination buffers safely. For example, change the code to:\n\n```cpp\nmemmove(codes + offset * code_size, codes_in, code_size * n_entry);\n```\n\nThis ensures that even if the source and destination regions overlap, the copy will be performed correctly without causing memory corruption or crashes. Always verify that the source and destination pointers are valid and that the size calculation does not exceed the bounds of either buffer.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fa6777c6-3a7b-3661-b932-8ef4d4b1aeac",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible risk of undefined behavior due to overlapping memory regions in a memory copy operation. The code copies 4 bytes from the address of one variable to another using a memory copy function. Dataflow analysis suggests that the source and destination may overlap, which is not allowed for this function and can result in unpredictable behavior. Additionally, there is no evidence of explicit checks or guards to prevent this overlap, and the source may potentially be null, increasing the risk. The classification and verdict both indicate a high-confidence issue that should be addressed to ensure program correctness and stability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. Replace the original call with:\n\n```cpp\nmemmove(&norm2, &norm_i, 4);\n```\n\nThis ensures that the copy operation is performed safely, even if the source and destination overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8ff697c7-556b-3e15-9f70-d7165241ec51",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Found\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflow, format string, or integer overflow vulnerabilities. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\nBuffer overflow vulnerabilities occur when a program writes more data to a buffer than it can hold, causing the excess data to overflow into adjacent memory. This can lead to unpredictable program behavior, including memory access errors, incorrect results, a crash, or a breach of system security.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `memmove`, you can use `memcpy_s` or `memmove_s` which are safer as they include the size of the destination buffer as a parameter, helping to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the code:\n\n```cpp\n#include <string.h>\n#include <stdlib.h>\n\n// Assuming Neighbor is a defined structure\nstruct Neighbor {\n    // structure members\n};\n\n// Assuming K and left are defined and valid\nsize_t K = 10;\nsize_t left = 5;\n\n// Assuming addr is a defined and valid array of Neighbor\nNeighbor addr[15];\n\n// Fix: Use memmove_s instead of memmove\nerrno_t err = memmove_s(&addr[left + 1], (K - left - 1) * sizeof(Neighbor), &addr[left], K * sizeof(Neighbor));\nif (err) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string.h>` for `memmove`\n- `<stdlib.h>` for `errno_t` and error handling\n\n## OWASP and CWE Links\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ad1af128-cc77-3257-b9a5-1957e66c1d2f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the filename is not properly validated or controlled, potentially leading to arbitrary file read/write operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives provided by the C++ Standard Library, which includes exception handling and type safety. In this case, you can use the `fstream` class from the `<fstream>` library to open files.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `fstream` class:\n\n```cpp\n#include <fstream>\n\nstd::fstream f;\nf.open(filename.c_str(), std::fstream::in | std::fstream::out);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: This library provides facilities for file-based input and output.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "30394aae-25d1-396e-acb7-3a7ad1986dca",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination buffers in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. No explicit checks or guards are present to ensure that the source and destination do not overlap. Additionally, there is no evidence that the source pointer is always non-null, which further increases the risk. The use of memcpy in such a scenario can lead to unpredictable results, as the behavior is undefined when the source and destination overlap. This type of issue can result in data corruption or crashes at runtime.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```cpp\nmemmove(ips, LUT, sizeof(*ips) * nc);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination buffers overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "94eec2ea-7cd8-3ba9-a1c7-32fdc0c7ee9d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of memory corruption. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `memmove`, you can use `std::copy` or `std::copy_backward` from the `<algorithm>` library in C++, which are safer as they work with C++ containers and iterators.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy_backward`:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy_backward(&addr[right], &addr[K], &addr[K + 1]);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memmove`\n- `<algorithm>` for `std::copy_backward`\n\n## OWASP and CWE Resources\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4f1fd3bf-2b1f-3163-b6a9-a44a10046044",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The code copies data from one buffer to another using a memory copy function, but dataflow analysis indicates that the source and destination may refer to overlapping memory regions. This can result in undefined behavior, which may cause data corruption or program crashes. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source may also be null, increasing the risk of a crash. The destination buffer is a pointer, and its capacity is not known, which further increases the risk. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, ensure that the source and destination do not overlap. If overlap is possible, use a memory move function that is safe for overlapping regions, such as `memmove`, instead of `memcpy`. For example, replace the original call with:\n\n```cpp\nmemmove(xi, c, sizeof(*xi) * d);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination buffers overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1836240b-80c0-30c9-ad4f-58fbb19d69a3",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible risk of undefined behavior due to overlapping memory regions in a memory copy operation. The code copies 4 bytes from the address of 'norm' to the address of 'inorm' using a memory copy function. Dataflow analysis suggests that the source and destination may overlap, which is not allowed by the standard for this function and can result in unpredictable behavior. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source may be null, further increasing the risk. The classification and verdict both indicate a high-confidence issue that should be addressed to ensure program correctness and security.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. This ensures that the copy operation is performed correctly even if the source and destination overlap.\n\n```cpp\nmemmove(&inorm, &norm, 4);\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b168ac0e-b0a7-3d56-8ff8-764ce3c43096",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The dataflow analysis indicates that the destination buffer may alias or overlap with the source buffer, which is not allowed for the standard memory copy function used here. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The destination buffer is a pointer type with unknown capacity, and the count argument is not directly tied to the destination's size, increasing the risk. These factors together make this a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination buffers safely.\n\n```cpp\nmemmove(xi, c, sizeof(*x) * d);\n```\n\nAdditionally, ensure that both `xi` and `c` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (xi != nullptr && c != nullptr) {\n    memmove(xi, c, sizeof(*x) * d);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "08e7519f-ba1e-3f4b-8464-a45e96c0bb35",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions in a memory copy operation. The destination and source buffers may overlap, as indicated by the data flow analysis, which can lead to unpredictable results when using functions like memcpy. Additionally, the source may be null, which could also result in undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's capacity is not known or enforced. The risk is further increased because the count argument is not directly tied to the destination's capacity, and the source kind is not a string literal or constant, making overlap more plausible. Therefore, this is a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination buffers may overlap, replace the memory copy function with one that is safe for overlapping regions, such as `memmove`. This ensures that the copy operation works correctly even if the memory areas overlap.\n\n```cpp\nmemmove(c, ScopedIds(il, list_no).get(), sz * sizeof(idx_t));\n```\n\nAdditionally, consider adding explicit checks to ensure that neither the source nor the destination is null before performing the copy. This can help prevent crashes due to null pointer dereferencing.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a2c11e15-4514-3a7c-be79-bcb17aa257ff",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The code uses a memory copy function to transfer data from one buffer to another, but dataflow analysis indicates that the source and destination may overlap. This can lead to unpredictable results or program crashes, as the standard memory copy function does not guarantee correct behavior when regions overlap. There are no explicit checks or guards in the code to prevent this scenario, and both the source and destination are non-null at the point of the call. The risk is further supported by the fact that the destination is a pointer type with no known capacity, and the count argument is not directly tied to the destination's size.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between regions that may overlap, use a memory move function that is designed to handle overlapping regions safely. Replace the memory copy function with a memory move function, which guarantees correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(xi, c, sizeof(*x) * d);\n```\n\nThis change ensures that the operation is safe regardless of whether the source and destination buffers overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "578c55e4-4d0f-3c8f-aefc-e39096208a50",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 243,
                  "startColumn": 12,
                  "endLine": 245,
                  "endColumn": 22,
                  "charOffset": 7062,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + q) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + q) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + q) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7062,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + q) * 32, <size of dest + (sq / 2 * nq + q) * 32>, \n                   src + (q * nsq + sq) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "114fa345-18d9-309b-91c9-2db23400ed96",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 278,
                  "startColumn": 12,
                  "endLine": 280,
                  "endColumn": 22,
                  "charOffset": 7937,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + qi) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + qi) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + qi) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7937,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + qi) * 32, <size of dest + (sq / 2 * nq + qi) * 32>, \n                   src + (q * nsq + sq) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b0d3fda1-07f6-33a5-9e10-70ab8481fc6d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 246,
                  "startColumn": 12,
                  "endLine": 248,
                  "endColumn": 22,
                  "charOffset": 7182,
                  "charLength": 115,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + q) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + q) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + q) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7182,
                        "charLength": 115
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + q) * 32 + 16, <size of dest + (sq / 2 * nq + q) * 32 + 16>, \n                   src + (q * nsq + sq + 1) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "64180376-1b1c-3b46-a98a-a43d6eacfdcc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/kmeans1d.cpp"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 8,
                  "endLine": 197,
                  "endColumn": 43,
                  "charOffset": 5261,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(centroids, x, n * sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(centroids, x, n * sizeof(*x)",
                      "markdown": "`memcpy(centroids, x, n * sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/kmeans1d.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5261,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids, <size of centroids>,  x,  n * sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "730b0633-00ea-332d-881a-74012922eecc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 281,
                  "startColumn": 12,
                  "endLine": 283,
                  "endColumn": 22,
                  "charOffset": 8058,
                  "charLength": 116,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + qi) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + qi) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + qi) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8058,
                        "charLength": 116
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + qi) * 32 + 16, <size of dest + (sq / 2 * nq + qi) * 32 + 16>, \n                   src + (q * nsq + sq + 1) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "58a11958-a1cc-3655-87a0-99e4648597d1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 28,
                  "endLine": 230,
                  "endColumn": 38,
                  "charOffset": 6047,
                  "charLength": 10,
                  "snippet": {
                    "text": "strlen(sx)",
                    "rendered": {
                      "text": "strlen(sx)",
                      "markdown": "`strlen(sx)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6047,
                        "charLength": 10
                      },
                      "insertedContent": {
                        "text": "strlen_s(sx, <size of sx>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6047,
                        "charLength": 10
                      },
                      "insertedContent": {
                        "text": "strnlen(sx, <size of sx>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a5d2717d-e878-33d4-bc4a-8062b34a3bbf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 8,
                  "endLine": 209,
                  "endColumn": 39,
                  "charOffset": 5537,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(buffer.data(), src, nb1)",
                    "rendered": {
                      "text": "memcpy(buffer.data(), src, nb1)",
                      "markdown": "`memcpy(buffer.data(), src, nb1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5537,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer.data(), <size of buffer.data()>,  src,  nb1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2dc4f657-1f96-3c4a-b264-85598cc8d15a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 8,
                  "endLine": 191,
                  "endColumn": 43,
                  "charOffset": 5005,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(buffer.data() + b0, src, nb)",
                    "rendered": {
                      "text": "memcpy(buffer.data() + b0, src, nb)",
                      "markdown": "`memcpy(buffer.data() + b0, src, nb)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5005,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer.data() + b0, <size of buffer.data() + b0>,  src,  nb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9b9f1611-450e-36e8-a28d-51defe71bddc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 8,
                  "endLine": 166,
                  "endColumn": 39,
                  "charOffset": 4371,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(dst, buffer.data(), nb2)",
                    "rendered": {
                      "text": "memcpy(dst, buffer.data(), nb2)",
                      "markdown": "`memcpy(dst, buffer.data(), nb2)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4371,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  buffer.data(),  nb2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "649b1afd-bf2b-3fb8-ba10-4d6aa27fd77e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 8,
                  "endLine": 145,
                  "endColumn": 43,
                  "charOffset": 3855,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(dst, buffer.data() + b0, nb)",
                    "rendered": {
                      "text": "memcpy(dst, buffer.data() + b0, nb)",
                      "markdown": "`memcpy(dst, buffer.data() + b0, nb)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3855,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  buffer.data() + b0,  nb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6786065e-61c7-3c7b-aca0-8deed6ba7411",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 8,
                  "endLine": 66,
                  "endColumn": 13,
                  "charOffset": 1769,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2c46a065-6a91-3b2c-ade3-26242e1cf925",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 8,
                  "endLine": 52,
                  "endColumn": 45,
                  "charOffset": 1391,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(ptr, &data[rp], size * nitems)",
                    "rendered": {
                      "text": "memcpy(ptr, &data[rp], size * nitems)",
                      "markdown": "`memcpy(ptr, &data[rp], size * nitems)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1391,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr, <size of ptr>,  &data[rp],  size * nitems)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dba21b98-c748-3a27-b3dd-15474d13c799",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 8,
                  "endLine": 96,
                  "endColumn": 13,
                  "charOffset": 2539,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0ccc6549-8f3d-3762-9d7b-1ead0627e652",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 8,
                  "endLine": 40,
                  "endColumn": 44,
                  "charOffset": 1068,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&data[o], ptr, size * nitems)",
                    "rendered": {
                      "text": "memcpy(&data[o], ptr, size * nitems)",
                      "markdown": "`memcpy(&data[o], ptr, size * nitems)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1068,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&data[o], <size of &data[o]>,  ptr,  size * nitems)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "537d19a5-2f2c-355f-afa6-a3db1a93df29",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                },
                "region": {
                  "startLine": 579,
                  "startColumn": 8,
                  "endLine": 579,
                  "endColumn": 56,
                  "charOffset": 16351,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(codes, best_codes.data(), sizeof(int32_t)",
                    "rendered": {
                      "text": "memcpy(codes, best_codes.data(), sizeof(int32_t)",
                      "markdown": "`memcpy(codes, best_codes.data(), sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16351,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codes, <size of codes>,  best_codes.data(),  sizeof(int32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5733ed89-3957-3ebd-8a12-dc6f11e3f2b9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                },
                "region": {
                  "startLine": 570,
                  "startColumn": 16,
                  "endLine": 572,
                  "endColumn": 38,
                  "charOffset": 16108,
                  "charLength": 110,
                  "snippet": {
                    "text": "memcpy(best_codes.data() + i * M,\n                       codes + i * M,\n                       sizeof(int32_t)",
                    "rendered": {
                      "text": "memcpy(best_codes.data() + i * M,\n                       codes + i * M,\n                       sizeof(int32_t)",
                      "markdown": "`memcpy(best_codes.data() + i * M,\n                       codes + i * M,\n                       sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16108,
                        "charLength": 110
                      },
                      "insertedContent": {
                        "text": "memcpy_s(best_codes.data() + i * M, <size of best_codes.data() + i * M>, \n                       codes + i * M, \n                       sizeof(int32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1697bdaa-81e2-3606-8217-9dcee7c6a69d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 354,
                  "startColumn": 16,
                  "endLine": 356,
                  "endColumn": 43,
                  "charOffset": 10541,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(xslice + (i - i0) * dsub,\n                       x + i * d + m * dsub,\n                       dsub * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xslice + (i - i0) * dsub,\n                       x + i * d + m * dsub,\n                       dsub * sizeof(float)",
                      "markdown": "`memcpy(xslice + (i - i0) * dsub,\n                       x + i * d + m * dsub,\n                       dsub * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10541,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xslice + (i - i0) * dsub, <size of xslice + (i - i0) * dsub>, \n                       x + i * d + m * dsub, \n                       dsub * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4fc94590-ccbf-3da5-bcd0-3627e5a6a1c4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 8,
                  "endLine": 287,
                  "endColumn": 37,
                  "charOffset": 8690,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(x + m * pq.dsub,\n               pq.get_centroids(m, c)",
                    "rendered": {
                      "text": "memcpy(x + m * pq.dsub,\n               pq.get_centroids(m, c)",
                      "markdown": "`memcpy(x + m * pq.dsub,\n               pq.get_centroids(m, c)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8690,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x + m * pq.dsub, <size of x + m * pq.dsub>, \n               pq.get_centroids(m,  c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c7ec45dd-3e5f-3145-abc9-3d1f90a92516",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 20,
                  "endLine": 164,
                  "endColumn": 46,
                  "charOffset": 4588,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(clus.centroids.data(),\n                           get_centroids(m, 0)",
                    "rendered": {
                      "text": "memcpy(clus.centroids.data(),\n                           get_centroids(m, 0)",
                      "markdown": "`memcpy(clus.centroids.data(),\n                           get_centroids(m, 0)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4588,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clus.centroids.data(), <size of clus.centroids.data()>, \n                           get_centroids(m,  0)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "64a16ac3-1fc5-354c-9c7d-32ccab564618",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/lattice_Zn.cpp"
                },
                "region": {
                  "startLine": 632,
                  "startColumn": 12,
                  "endLine": 634,
                  "endColumn": 29,
                  "charOffset": 17273,
                  "charLength": 98,
                  "snippet": {
                    "text": "memcpy(c + i * subdim,\n                   &cache[codes[i] * subdim],\n                   sizeof(*c)",
                    "rendered": {
                      "text": "memcpy(c + i * subdim,\n                   &cache[codes[i] * subdim],\n                   sizeof(*c)",
                      "markdown": "`memcpy(c + i * subdim,\n                   &cache[codes[i] * subdim],\n                   sizeof(*c)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/lattice_Zn.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17273,
                        "charLength": 98
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c + i * subdim, <size of c + i * subdim>, \n                   &cache[codes[i] * subdim], \n                   sizeof(*c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8ee942d6-d2af-381d-8f9c-678c505933f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 16,
                  "endLine": 144,
                  "endColumn": 43,
                  "charOffset": 3783,
                  "charLength": 114,
                  "snippet": {
                    "text": "memcpy(xslice + j * dsub,\n                       x + j * d + m * dsub,\n                       dsub * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xslice + j * dsub,\n                       x + j * d + m * dsub,\n                       dsub * sizeof(float)",
                      "markdown": "`memcpy(xslice + j * dsub,\n                       x + j * d + m * dsub,\n                       dsub * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3783,
                        "charLength": 114
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xslice + j * dsub, <size of xslice + j * dsub>, \n                       x + j * d + m * dsub, \n                       dsub * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "152d10cc-34aa-3e85-ad1a-e1b6d9704173",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/lattice_Zn.cpp"
                },
                "region": {
                  "startLine": 537,
                  "startColumn": 12,
                  "endLine": 539,
                  "endColumn": 44,
                  "charOffset": 14439,
                  "charLength": 115,
                  "snippet": {
                    "text": "memcpy(&cache[i * dimsub],\n                   c.data() + dim - dimsub,\n                   dimsub * sizeof(*c.data()",
                    "rendered": {
                      "text": "memcpy(&cache[i * dimsub],\n                   c.data() + dim - dimsub,\n                   dimsub * sizeof(*c.data()",
                      "markdown": "`memcpy(&cache[i * dimsub],\n                   c.data() + dim - dimsub,\n                   dimsub * sizeof(*c.data()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/lattice_Zn.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14439,
                        "charLength": 115
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&cache[i * dimsub], <size of &cache[i * dimsub]>, \n                   c.data() + dim - dimsub, \n                   dimsub * sizeof(*c.data()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ef78a412-d7eb-3021-8343-4edb683d13ac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 12,
                  "endLine": 173,
                  "endColumn": 39,
                  "charOffset": 4583,
                  "charLength": 111,
                  "snippet": {
                    "text": "memcpy(xsub.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xsub.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(float)",
                      "markdown": "`memcpy(xsub.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4583,
                        "charLength": 111
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xsub.data() + i * q->d, <size of xsub.data() + i * q->d>, \n                   x + i * d + offset_d, \n                   q->d * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "af03e58b-f774-367e-94e8-f95f1ff8b59e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 20,
                  "endLine": 253,
                  "endColumn": 44,
                  "charOffset": 7182,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7182,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "870414e2-ee65-3b68-8f12-e5d65c184d74",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 12,
                  "endLine": 106,
                  "endColumn": 36,
                  "charOffset": 2520,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(xt.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xt.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(*x)",
                      "markdown": "`memcpy(xt.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2520,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xt.data() + i * q->d, <size of xt.data() + i * q->d>, \n                   x + i * d + offset_d, \n                   q->d * sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e072c7fe-67ca-3a7a-9545-684762dd0b88",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 8,
                  "endLine": 125,
                  "endColumn": 73,
                  "charOffset": 3152,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(cb, q->codebooks.data(), sub_codebook_size * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(cb, q->codebooks.data(), sub_codebook_size * sizeof(float)",
                      "markdown": "`memcpy(cb, q->codebooks.data(), sub_codebook_size * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3152,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(cb, <size of cb>,  q->codebooks.data(),  sub_codebook_size * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3ce35f57-9bc2-3827-bb78-1cb8337ddb40",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 20,
                  "endLine": 222,
                  "endColumn": 44,
                  "charOffset": 6173,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6173,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1d70bb79-65c8-3ed4-a529-0bda9dbc1673",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/index_read.cpp"
                },
                "region": {
                  "startLine": 750,
                  "startColumn": 16,
                  "endLine": 750,
                  "endColumn": 77,
                  "charOffset": 24070,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(ail->codes[i].data(), vec.data(), ail->codes[i].size()",
                    "rendered": {
                      "text": "memcpy(ail->codes[i].data(), vec.data(), ail->codes[i].size()",
                      "markdown": "`memcpy(ail->codes[i].data(), vec.data(), ail->codes[i].size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/index_read.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24070,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ail->codes[i].data(), <size of ail->codes[i].data()>,  vec.data(),  ail->codes[i].size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0470a315-ab4a-3a76-95d4-ba955ab8ab05",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AuxIndexStructures.cpp"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 8,
                  "endLine": 102,
                  "endColumn": 65,
                  "charOffset": 2671,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis)",
                    "rendered": {
                      "text": "memcpy(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis)",
                      "markdown": "`memcpy(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AuxIndexStructures.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2671,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest_dis, <size of dest_dis>,  buf.dis + ofs,  ncopy * sizeof(*dest_dis)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "51c9f610-24b4-3eed-a8b8-2ceab3119963",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AuxIndexStructures.cpp"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 8,
                  "endLine": 101,
                  "endColumn": 65,
                  "charOffset": 2603,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids)",
                    "rendered": {
                      "text": "memcpy(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids)",
                      "markdown": "`memcpy(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AuxIndexStructures.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2603,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest_ids, <size of dest_ids>,  buf.ids + ofs,  ncopy * sizeof(*dest_ids)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "811d38f3-c76e-39ac-be38-c0ba5fe748cd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/index_read.cpp"
                },
                "region": {
                  "startLine": 192,
                  "startColumn": 8,
                  "endLine": 192,
                  "endColumn": 15,
                  "charOffset": 5794,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e28b967e-a65a-3db9-ab26-e014990fba94",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 909,
                  "startColumn": 28,
                  "endLine": 909,
                  "endColumn": 33,
                  "charOffset": 28554,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "50c00415-ff37-3c87-b1b5-00c467c2ab27",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 895,
                  "startColumn": 12,
                  "endLine": 895,
                  "endColumn": 18,
                  "charOffset": 28083,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5f984b00-e9dd-388f-b5fe-40f9fe14d1c5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 932,
                  "startColumn": 12,
                  "endLine": 934,
                  "endColumn": 46,
                  "charOffset": 29263,
                  "charLength": 134,
                  "snippet": {
                    "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                    "rendered": {
                      "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                      "markdown": "`memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29263,
                        "charLength": 134
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids + perm[i] * dsub, <size of centroids + perm[i] * dsub>, \n                   centroids_copy.data() + i * dsub, \n                   dsub * sizeof(centroids[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "021f3c2c-16c9-3c36-adda-160d4c1eb053",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 878,
                  "startColumn": 12,
                  "endLine": 880,
                  "endColumn": 32,
                  "charOffset": 27593,
                  "charLength": 114,
                  "snippet": {
                    "text": "memcpy(gt_distances.data(),\n                   pq.sdc_table.data() + m * nq * nb,\n                   sizeof(float)",
                    "rendered": {
                      "text": "memcpy(gt_distances.data(),\n                   pq.sdc_table.data() + m * nq * nb,\n                   sizeof(float)",
                      "markdown": "`memcpy(gt_distances.data(),\n                   pq.sdc_table.data() + m * nq * nb,\n                   sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27593,
                        "charLength": 114
                      },
                      "insertedContent": {
                        "text": "memcpy_s(gt_distances.data(), <size of gt_distances.data()>, \n                   pq.sdc_table.data() + m * nq * nb, \n                   sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3bbec019-e182-3e3a-8884-924dd7f0bf62",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ScalarQuantizer.cpp"
                },
                "region": {
                  "startLine": 576,
                  "startColumn": 8,
                  "endLine": 576,
                  "endColumn": 34,
                  "charOffset": 17292,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(vmin, x, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(vmin, x, sizeof(*x)",
                      "markdown": "`memcpy(vmin, x, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ScalarQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17292,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vmin, <size of vmin>,  x,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6f66c3aa-50ec-3d84-9e94-00c1e4cb4790",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 854,
                  "startColumn": 16,
                  "endLine": 856,
                  "endColumn": 36,
                  "charOffset": 26855,
                  "charLength": 117,
                  "snippet": {
                    "text": "memcpy(xtrain.data() + i * dsub,\n                       x + i * pq.d + m * dsub,\n                       sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xtrain.data() + i * dsub,\n                       x + i * pq.d + m * dsub,\n                       sizeof(float)",
                      "markdown": "`memcpy(xtrain.data() + i * dsub,\n                       x + i * pq.d + m * dsub,\n                       sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26855,
                        "charLength": 117
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xtrain.data() + i * dsub, <size of xtrain.data() + i * dsub>, \n                       x + i * pq.d + m * dsub, \n                       sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d86b9265-3668-3194-a301-08a8961b7e47",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 131,
                  "startColumn": 12,
                  "endLine": 131,
                  "endColumn": 18,
                  "charOffset": 3830,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "92936ba7-557c-3fa7-acd2-7fd793592b88",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 822,
                  "startColumn": 12,
                  "endLine": 824,
                  "endColumn": 46,
                  "charOffset": 25981,
                  "charLength": 134,
                  "snippet": {
                    "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                    "rendered": {
                      "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                      "markdown": "`memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25981,
                        "charLength": 134
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids + perm[i] * dsub, <size of centroids + perm[i] * dsub>, \n                   centroids_copy.data() + i * dsub, \n                   dsub * sizeof(centroids[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5ea9d47f-64dd-3f55-aa04-e7203db2b072",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ScalarQuantizer.cpp"
                },
                "region": {
                  "startLine": 577,
                  "startColumn": 8,
                  "endLine": 577,
                  "endColumn": 34,
                  "charOffset": 17333,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(vmax, x, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(vmax, x, sizeof(*x)",
                      "markdown": "`memcpy(vmax, x, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ScalarQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17333,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vmax, <size of vmax>,  x,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a27a49a3-24ca-3339-b76d-940a9c0aff8f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 802,
                  "startColumn": 28,
                  "endLine": 802,
                  "endColumn": 33,
                  "charOffset": 25355,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "966568b5-d63b-3190-a055-a35507bef0d4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 669,
                  "startColumn": 42,
                  "endLine": 669,
                  "endColumn": 45,
                  "charOffset": 21692,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21692,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21692,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "377f7004-546d-3dd9-a52f-8f4208f6e90a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 42,
                  "endLine": 593,
                  "endColumn": 45,
                  "charOffset": 19140,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19140,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19140,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "76a2213e-9de5-39cb-96b8-ade4f56ef25a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 772,
                  "startColumn": 42,
                  "endLine": 772,
                  "endColumn": 45,
                  "charOffset": 24541,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24541,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24541,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "0b79b6d8-127b-303a-adad-eb079c883444",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 535,
                  "startColumn": 42,
                  "endLine": 535,
                  "endColumn": 45,
                  "charOffset": 17610,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17610,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17610,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "aa176703-4dad-37ad-a8ae-7052aed91d0f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 12,
                  "endLine": 94,
                  "endColumn": 58,
                  "charOffset": 2619,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(best_perm, perm.data(), sizeof(perm[0])",
                    "rendered": {
                      "text": "memcpy(best_perm, perm.data(), sizeof(perm[0])",
                      "markdown": "`memcpy(best_perm, perm.data(), sizeof(perm[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2619,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(best_perm, <size of best_perm>,  perm.data(),  sizeof(perm[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "62a53627-6b59-3f69-9d5e-87a3e13c3e38",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 42,
                  "endLine": 403,
                  "endColumn": 45,
                  "charOffset": 13221,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13221,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13221,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "7805de82-ccb9-3258-8dba-b1999b6d2f0f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ScalarQuantizer.cpp"
                },
                "region": {
                  "startLine": 488,
                  "startColumn": 8,
                  "endLine": 488,
                  "endColumn": 47,
                  "charOffset": 14897,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(x_copy.data(), x, n * sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(x_copy.data(), x, n * sizeof(*x)",
                      "markdown": "`memcpy(x_copy.data(), x, n * sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ScalarQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14897,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x_copy.data(), <size of x_copy.data()>,  x,  n * sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bd247ac0-9838-3c52-b1d8-36a7df58ed5d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/BlockInvertedLists.cpp"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 4,
                  "endLine": 52,
                  "endColumn": 54,
                  "charOffset": 1419,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])",
                    "rendered": {
                      "text": "memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])",
                      "markdown": "`memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/BlockInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1419,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ids[list_no][o], <size of &ids[list_no][o]>,  ids_in,  sizeof(ids_in[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "33738c62-12bb-3d8a-8fff-b56aa81a315f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 42,
                  "endLine": 415,
                  "endColumn": 45,
                  "charOffset": 13642,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13642,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13642,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "4f9f6ccf-6eaf-31de-b069-e5a191a99b7b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 215,
                  "startColumn": 42,
                  "endLine": 215,
                  "endColumn": 45,
                  "charOffset": 6189,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6189,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6189,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "62d96ae8-9ad6-3890-9544-8435b41852e2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 140,
                  "startColumn": 15,
                  "endLine": 140,
                  "endColumn": 22,
                  "charOffset": 4005,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8c89d273-2481-32bb-836a-44ffb7f16096",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/BlockInvertedLists.cpp"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 8,
                  "endLine": 57,
                  "endColumn": 74,
                  "charOffset": 1667,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&codes[list_no][o * code_size], code, n_block * block_size)",
                    "rendered": {
                      "text": "memcpy(&codes[list_no][o * code_size], code, n_block * block_size)",
                      "markdown": "`memcpy(&codes[list_no][o * code_size], code, n_block * block_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/BlockInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1667,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&codes[list_no][o * code_size], <size of &codes[list_no][o * code_size]>,  code,  n_block * block_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "65ce472d-9ffe-31f2-9bc9-28a6b3b1930d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 9,
                  "endLine": 113,
                  "endColumn": 39,
                  "charOffset": 3278,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(bytes, ds, sizeof(char)",
                    "rendered": {
                      "text": "memcpy(bytes, ds, sizeof(char)",
                      "markdown": "`memcpy(bytes, ds, sizeof(char)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3278,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes, <size of bytes>,  ds,  sizeof(char)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "66085b83-2001-397a-a1fd-229a1b75ab05",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 12,
                  "endLine": 96,
                  "endColumn": 15,
                  "charOffset": 2761,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2761,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2761,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "0228618e-67ca-3c8c-9643-cfbd42b6b5dc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1505,
                  "startColumn": 8,
                  "endLine": 1505,
                  "endColumn": 68,
                  "charOffset": 48492,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                    "rendered": {
                      "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                      "markdown": "`memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48492,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_codes, <size of out_codes>,  codes_ptr,  codes_size * sizeof(*codes_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f2668f77-7e12-3200-ac08-27afd13e71ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1511,
                  "startColumn": 8,
                  "endLine": 1513,
                  "endColumn": 54,
                  "charOffset": 48723,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(out_distances,\n               distances_ptr,\n               distances_size * sizeof(*distances_ptr)",
                    "rendered": {
                      "text": "memcpy(out_distances,\n               distances_ptr,\n               distances_size * sizeof(*distances_ptr)",
                      "markdown": "`memcpy(out_distances,\n               distances_ptr,\n               distances_size * sizeof(*distances_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48723,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_distances, <size of out_distances>, \n               distances_ptr, \n               distances_size * sizeof(*distances_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "037da8d4-ba58-3c16-8d0a-bdd979bceca8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 924,
                  "startColumn": 8,
                  "endLine": 926,
                  "endColumn": 54,
                  "charOffset": 28793,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(out_residuals,\n               residuals_ptr,\n               residuals_size * sizeof(*residuals_ptr)",
                    "rendered": {
                      "text": "memcpy(out_residuals,\n               residuals_ptr,\n               residuals_size * sizeof(*residuals_ptr)",
                      "markdown": "`memcpy(out_residuals,\n               residuals_ptr,\n               residuals_size * sizeof(*residuals_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28793,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_residuals, <size of out_residuals>, \n               residuals_ptr, \n               residuals_size * sizeof(*residuals_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1d749b2c-cff0-3421-bd7e-48d9f545b0ec",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1493,
                  "startColumn": 12,
                  "endLine": 1493,
                  "endColumn": 18,
                  "charOffset": 48098,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3213c710-6b62-300e-8aa2-9c9a98155fa3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 932,
                  "startColumn": 8,
                  "endLine": 934,
                  "endColumn": 57,
                  "charOffset": 29070,
                  "charLength": 117,
                  "snippet": {
                    "text": "memcpy(out_distances,\n               pool.distances.data(),\n               distances_size * sizeof(pool.distances[0])",
                    "rendered": {
                      "text": "memcpy(out_distances,\n               pool.distances.data(),\n               distances_size * sizeof(pool.distances[0])",
                      "markdown": "`memcpy(out_distances,\n               pool.distances.data(),\n               distances_size * sizeof(pool.distances[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29070,
                        "charLength": 117
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_distances, <size of out_distances>, \n               pool.distances.data(), \n               distances_size * sizeof(pool.distances[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "aa1cab7a-5cd8-3292-9346-03252528663a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1385,
                  "startColumn": 16,
                  "endLine": 1385,
                  "endColumn": 68,
                  "charOffset": 44706,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                    "rendered": {
                      "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                      "markdown": "`memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44706,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_codes_i, <size of new_codes_i>,  codes_i + js * m,  sizeof(*codes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5fbba3c0-4c4c-35ec-86db-b14ca14cb6bc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 906,
                  "startColumn": 12,
                  "endLine": 906,
                  "endColumn": 18,
                  "charOffset": 28164,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c09f8625-1aec-3f91-afc6-96755c3547fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 918,
                  "startColumn": 8,
                  "endLine": 918,
                  "endColumn": 68,
                  "charOffset": 28562,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                    "rendered": {
                      "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                      "markdown": "`memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28562,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_codes, <size of out_codes>,  codes_ptr,  codes_size * sizeof(*codes_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3b6fa39f-d4af-3e28-8249-5e81081edac8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 419,
                  "startColumn": 16,
                  "endLine": 419,
                  "endColumn": 22,
                  "charOffset": 13780,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "689c600e-ae99-3a4e-a3e5-c898414bc490",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 345,
                  "startColumn": 8,
                  "endLine": 347,
                  "endColumn": 31,
                  "charOffset": 11121,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(this->codebooks.data() + codebook_offsets[m] * d,\n               codebooks.data(),\n               codebooks.size()",
                    "rendered": {
                      "text": "memcpy(this->codebooks.data() + codebook_offsets[m] * d,\n               codebooks.data(),\n               codebooks.size()",
                      "markdown": "`memcpy(this->codebooks.data() + codebook_offsets[m] * d,\n               codebooks.data(),\n               codebooks.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11121,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(this->codebooks.data() + codebook_offsets[m] * d, <size of this->codebooks.data() + codebook_offsets[m] * d>, \n               codebooks.data(), \n               codebooks.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8aeb9193-400a-3370-a64f-b5589fdb407e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 399,
                  "startColumn": 12,
                  "endLine": 399,
                  "endColumn": 18,
                  "charOffset": 13092,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7de317c0-460f-3b18-acca-8bda9c60e47e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 306,
                  "startColumn": 16,
                  "endLine": 308,
                  "endColumn": 43,
                  "charOffset": 9668,
                  "charLength": 142,
                  "snippet": {
                    "text": "memcpy(residuals1.data() + j * d,\n                       residuals.data() + j * d * cur_beam_size,\n                       sizeof(residuals[0])",
                    "rendered": {
                      "text": "memcpy(residuals1.data() + j * d,\n                       residuals.data() + j * d * cur_beam_size,\n                       sizeof(residuals[0])",
                      "markdown": "`memcpy(residuals1.data() + j * d,\n                       residuals.data() + j * d * cur_beam_size,\n                       sizeof(residuals[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9668,
                        "charLength": 142
                      },
                      "insertedContent": {
                        "text": "memcpy_s(residuals1.data() + j * d, <size of residuals1.data() + j * d>, \n                       residuals.data() + j * d * cur_beam_size, \n                       sizeof(residuals[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0b329990-7068-3021-af51-00a62557defb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 4,
                  "endLine": 113,
                  "endColumn": 23,
                  "charOffset": 2518,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(nbits.data(),\n           other.nbits.data() + skip_M,\n           nbits.size()",
                    "rendered": {
                      "text": "memcpy(nbits.data(),\n           other.nbits.data() + skip_M,\n           nbits.size()",
                      "markdown": "`memcpy(nbits.data(),\n           other.nbits.data() + skip_M,\n           nbits.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2518,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(nbits.data(), <size of nbits.data()>, \n           other.nbits.data() + skip_M, \n           nbits.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "796bc0f1-54c8-3ab2-8ad8-2b8d2364f7bd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 265,
                  "startColumn": 20,
                  "endLine": 265,
                  "endColumn": 72,
                  "charOffset": 8434,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                    "rendered": {
                      "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                      "markdown": "`memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8434,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_codes_i, <size of new_codes_i>,  codes_i + js * m,  sizeof(*codes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e95e1201-8c57-31fa-abb0-725ef3106ca9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 20,
                  "endLine": 211,
                  "endColumn": 72,
                  "charOffset": 6304,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                    "rendered": {
                      "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                      "markdown": "`memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6304,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_codes_i, <size of new_codes_i>,  codes_i + js * m,  sizeof(*codes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e370e54a-532f-3817-b473-6d750b5cfcbb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 121,
                  "startColumn": 8,
                  "endLine": 123,
                  "endColumn": 31,
                  "charOffset": 2857,
                  "charLength": 132,
                  "snippet": {
                    "text": "memcpy(codebooks.data(),\n               other.codebooks.data() + other.codebook_offsets[skip_M] * d,\n               codebooks.size()",
                    "rendered": {
                      "text": "memcpy(codebooks.data(),\n               other.codebooks.data() + other.codebook_offsets[skip_M] * d,\n               codebooks.size()",
                      "markdown": "`memcpy(codebooks.data(),\n               other.codebooks.data() + other.codebook_offsets[skip_M] * d,\n               codebooks.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2857,
                        "charLength": 132
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codebooks.data(), <size of codebooks.data()>, \n               other.codebooks.data() + other.codebook_offsets[skip_M] * d, \n               codebooks.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "55832926-9b88-31cd-b897-314138476b4d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 775,
                  "startColumn": 63,
                  "endLine": 775,
                  "endColumn": 71,
                  "charOffset": 21995,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1d886a41-cf71-3977-abb2-58039de5f671",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 730,
                  "startColumn": 12,
                  "endLine": 730,
                  "endColumn": 18,
                  "charOffset": 20492,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "146d6b8d-9500-30e4-acbf-b793742fe9fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 471,
                  "startColumn": 12,
                  "endLine": 473,
                  "endColumn": 36,
                  "charOffset": 13270,
                  "charLength": 129,
                  "snippet": {
                    "text": "memcpy(ptr + new_l.offset + new_l.capacity * code_size,\n                   get_ids(list_no),\n                   n * sizeof(idx_t)",
                    "rendered": {
                      "text": "memcpy(ptr + new_l.offset + new_l.capacity * code_size,\n                   get_ids(list_no),\n                   n * sizeof(idx_t)",
                      "markdown": "`memcpy(ptr + new_l.offset + new_l.capacity * code_size,\n                   get_ids(list_no),\n                   n * sizeof(idx_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13270,
                        "charLength": 129
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr + new_l.offset + new_l.capacity * code_size, <size of ptr + new_l.offset + new_l.capacity * code_size>, \n                   get_ids(list_no), \n                   n * sizeof(idx_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "98f2fc2f-9d60-3167-a4ca-f0520e7e341d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured URL Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 3,
                  "endLine": 48,
                  "endColumn": 24,
                  "charOffset": 1070,
                  "charLength": 21,
                  "snippet": {
                    "text": "http://www.netlib.org",
                    "rendered": {
                      "text": "http://www.netlib.org",
                      "markdown": "`http://www.netlib.org`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1070,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "https://www.netlib.org"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "11784b33-ea2d-3411-b7a4-9b55e3fb520c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 648,
                  "startColumn": 4,
                  "endLine": 648,
                  "endColumn": 50,
                  "charOffset": 17839,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(new_lists.data(), &lists[l0], (l1 - l0)",
                    "rendered": {
                      "text": "memcpy(new_lists.data(), &lists[l0], (l1 - l0)",
                      "markdown": "`memcpy(new_lists.data(), &lists[l0], (l1 - l0)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17839,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_lists.data(), <size of new_lists.data()>,  &lists[l0],  (l1 - l0)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "829d1dd4-e357-3254-a241-891b8e5a8158",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 765,
                  "startColumn": 61,
                  "endLine": 765,
                  "endColumn": 69,
                  "charOffset": 21647,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "17c9bad1-4dfb-3ab8-be94-9df7f03d028d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 413,
                  "startColumn": 4,
                  "endLine": 413,
                  "endColumn": 50,
                  "charOffset": 11595,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(ids + offset, ids_in, sizeof(ids_in[0])",
                    "rendered": {
                      "text": "memcpy(ids + offset, ids_in, sizeof(ids_in[0])",
                      "markdown": "`memcpy(ids + offset, ids_in, sizeof(ids_in[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11595,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ids + offset, <size of ids + offset>,  ids_in,  sizeof(ids_in[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f1869165-b929-3ebf-ab27-b2097321677a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 470,
                  "startColumn": 12,
                  "endLine": 470,
                  "endColumn": 73,
                  "charOffset": 13195,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(ptr + new_l.offset, get_codes(list_no), n * code_size)",
                    "rendered": {
                      "text": "memcpy(ptr + new_l.offset, get_codes(list_no), n * code_size)",
                      "markdown": "`memcpy(ptr + new_l.offset, get_codes(list_no), n * code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13195,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr + new_l.offset, <size of ptr + new_l.offset>,  get_codes(list_no),  n * code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fd9b7f22-eff3-399a-94da-50a1c2e20523",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 18,
                  "endLine": 299,
                  "endColumn": 23,
                  "charOffset": 8547,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "886f4aac-e5fe-3289-a467-e133d81a4541",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 61,
                  "endLine": 295,
                  "endColumn": 69,
                  "charOffset": 8432,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9fdb8f84-49f3-3364-9160-2e20b247a0f9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 4,
                  "endLine": 415,
                  "endColumn": 69,
                  "charOffset": 11721,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(codes + offset * code_size, codes_in, code_size * n_entry)",
                    "rendered": {
                      "text": "memcpy(codes + offset * code_size, codes_in, code_size * n_entry)",
                      "markdown": "`memcpy(codes + offset * code_size, codes_in, code_size * n_entry)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11721,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codes + offset * code_size, <size of codes + offset * code_size>,  codes_in,  code_size * n_entry)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fa6777c6-3a7b-3661-b932-8ef4d4b1aeac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 513,
                  "startColumn": 4,
                  "endLine": 513,
                  "endColumn": 30,
                  "charOffset": 14757,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(&norm2, &norm_i, 4)",
                    "rendered": {
                      "text": "memcpy(&norm2, &norm_i, 4)",
                      "markdown": "`memcpy(&norm2, &norm_i, 4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14757,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&norm2, <size of &norm2>,  &norm_i,  4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8ff697c7-556b-3e15-9f70-d7165241ec51",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NSG.cpp"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 8,
                  "endLine": 103,
                  "endColumn": 15,
                  "charOffset": 2353,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ad1af128-cc77-3257-b9a5-1957e66c1d2f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 270,
                  "startColumn": 14,
                  "endLine": 270,
                  "endColumn": 19,
                  "charOffset": 7727,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "30394aae-25d1-396e-acb7-3a7ad1986dca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 384,
                  "startColumn": 12,
                  "endLine": 384,
                  "endColumn": 41,
                  "charOffset": 10698,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(ips, LUT, sizeof(*ips)",
                    "rendered": {
                      "text": "memcpy(ips, LUT, sizeof(*ips)",
                      "markdown": "`memcpy(ips, LUT, sizeof(*ips)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10698,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ips, <size of ips>,  LUT,  sizeof(*ips)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "94eec2ea-7cd8-3ba9-a1c7-32fdc0c7ee9d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NSG.cpp"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 4,
                  "endLine": 133,
                  "endColumn": 11,
                  "charOffset": 3070,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4f1fd3bf-2b1f-3163-b6a9-a44a10046044",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 12,
                  "endLine": 335,
                  "endColumn": 37,
                  "charOffset": 9620,
                  "charLength": 25,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*xi)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*xi)",
                      "markdown": "`memcpy(xi, c, sizeof(*xi)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9620,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*xi)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1836240b-80c0-30c9-ad4f-58fbb19d69a3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 198,
                  "startColumn": 12,
                  "endLine": 198,
                  "endColumn": 36,
                  "charOffset": 5148,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(&inorm, &norm, 4)",
                    "rendered": {
                      "text": "memcpy(&inorm, &norm, 4)",
                      "markdown": "`memcpy(&inorm, &norm, 4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5148,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&inorm, <size of &inorm>,  &norm,  4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b168ac0e-b0a7-3d56-8ff8-764ce3c43096",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 272,
                  "startColumn": 16,
                  "endLine": 272,
                  "endColumn": 40,
                  "charOffset": 7730,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7730,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "08e7519f-ba1e-3f4b-8464-a45e96c0bb35",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 382,
                  "startColumn": 12,
                  "endLine": 382,
                  "endColumn": 44,
                  "charOffset": 11409,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(c, ScopedIds(il, list_no)",
                    "rendered": {
                      "text": "memcpy(c, ScopedIds(il, list_no)",
                      "markdown": "`memcpy(c, ScopedIds(il, list_no)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11409,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c, <size of c>,  ScopedIds(il,  list_no)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a2c11e15-4514-3a7c-be79-bcb17aa257ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 16,
                  "endLine": 301,
                  "endColumn": 40,
                  "charOffset": 8549,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8549,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}