{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-357391c3-1f61-468f-9ad0-86afed9b0419",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-29122e96-305c-470d-9b0c-c979bbc6c1d8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-761b3e8c-de45-436c-86ea-8535d598f487",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-9d2c122c-a0c8-413d-b5a3-3939e86f0b37",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-e5361224-8447-4fd9-9162-190667907a7b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-2cdd17b8-a8fe-429e-9805-bc154a686e5b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-08e81c43-2a6c-4a97-9b6c-84963d7dc7da",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is less than the size of the source buffer. This can lead to buffer overflow, which can cause the program to crash or, in worst-case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = sub_d * sizeof(sub_x);\nif (size <= sizeof(sub_x)) {\n    memcpy(sub_x + i * sub_d, x + ofs + i * d, size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first calculate the size of the data to be copied and then check if it is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` (for `memcpy` function)\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0d8ea8b0-b0db-49b1-89ac-5ff8d4ba898b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the destination buffer is smaller than the source buffer, it can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t copy_size = other->ntotal * code_size;\nif (copy_size <= codes.size() - (ntotal * code_size)) {\n    memcpy(codes.data() + (ntotal * code_size),\n           other->codes.data(),\n           copy_size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1650076e-e88e-49ec-8ea4-a25b737e0886",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-83180e2c-e890-48ac-8f67-48d90bdbaebb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of data, crash of the application, or even code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling the `memcpy` function. Also, consider using safer functions such as `strncpy` or `memcpy_s` which include the size of the destination as a parameter.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(char* dest, const char* src, size_t dest_size) {\n    size_t src_size = strlen(src);\n    if (src_size < dest_size) {\n        memcpy(dest, src, src_size);\n        dest[src_size] = '\\0'; // Ensure null termination\n    } else {\n        // Handle error: source is too large to fit in dest\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `memcpy` function and the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-de14f7a8-a070-444b-a590-86bfceae85cb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-583c2a55-f53e-464a-8bb5-93985b1229e7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to dynamically allocate memory during runtime. The vulnerability arises when the size of the memory to be allocated is not properly validated or calculated, leading to potential buffer overflow, integer overflow, or memory corruption issues. In the provided code snippet, the size of the memory to be allocated is calculated as `k * nq * sizeof(float)`. If the values of `k` and `nq` are not properly controlled, this could lead to an integer overflow, resulting in a smaller buffer being allocated than expected. This could then lead to buffer overflow vulnerabilities if more data is written to the buffer than it can hold.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate and control the values that are used to calculate the size of the memory to be allocated.\n2. Use functions that limit the amount of data that can be written to a buffer to prevent buffer overflows.\n3. Consider using languages that handle memory management automatically to prevent these types of vulnerabilities.\n\n## Source Code Fix Recommendation\n\nA potential fix for the provided code snippet could be:\n\n```cpp\nif (k > 0 && nq > 0 && k <= (INT_MAX / nq / sizeof(float))) {\n    float* buffer = (float*) malloc(k * nq * sizeof(float));\n    if (buffer == NULL) {\n        // Handle malloc failure\n    }\n    // Continue with program\n} else {\n    // Handle invalid size\n}\n```\n\nThis code first checks if the values of `k` and `nq` would cause an integer overflow when multiplied together and with `sizeof(float)`. If they would, it handles the invalid size. If they wouldn't, it proceeds to allocate the memory.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc` function.\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-e390c38f-c2e1-4159-bdb0-47d2f96c6aa5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a product of variables (like `d * nq * sizeof(float)`), there is a potential for integer overflow. If the multiplication overflows, the allocated memory will be less than expected, which can lead to buffer overflow vulnerabilities when the program tries to use the allocated memory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always check for potential overflows before performing the multiplication. This can be done by dividing the maximum possible value (`SIZE_MAX`) by one of the operands and comparing the result with the other operand. If the other operand is greater, an overflow would occur.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability:\n\n```cpp\n#include <climits>\n#include <cstdlib>\n\nif (nq == 0 || d > SIZE_MAX / (nq * sizeof(float))) {\n    // handle error\n} else {\n    float* ptr = (float*) malloc(d * nq * sizeof(float));\n    if (!ptr) {\n        // handle error\n    } else {\n        // use ptr\n        free(ptr);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `climits`: for `SIZE_MAX`\n- `cstdlib`: for `malloc` and `free`\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-157a723f-cfac-44da-bff9-1b974dee53b8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a product of variables (like `k * nq * sizeof(idx_t)`), there is a potential for integer overflow. If the multiplication results in a value that is too large to be represented as an `size_t` type, the actual allocated memory will be less than expected. This can lead to buffer overflow vulnerabilities, where data can be written past the end of the allocated space, potentially leading to code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Always check for multiplication overflow before calling `malloc`.\n2. Use functions that can handle allocation size calculation safely.\n3. Consider using languages that are not susceptible to these types of vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a simple way to check for overflow before performing the `malloc`:\n\n```cpp\nif (nq && k > SIZE_MAX / nq / sizeof(idx_t)) {\n    /* Handle error - multiplication would overflow */\n} else {\n    idx_t* ptr = malloc(k * nq * sizeof(idx_t));\n    if (!ptr) {\n        /* Handle error - malloc failed */\n    }\n    /* Continue with program, free ptr when done */\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc` function.\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-141cc062-5616-4ad8-8656-7f34e13a180a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators can lead to vulnerabilities, especially when randomness is required for security purposes. The `rand()` function, which relies on `RAND_MAX`, is a common example of a non-cryptographic random number generator. It is predictable and not suitable for cryptographic purposes, such as generating keys, tokens, or any other security-sensitive data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographic random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which are more suitable for generating random numbers in a secure manner.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here's an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++11-compliant compiler.\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-b6611e7f-2173-4d72-9e80-dc1df8037d60",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-357391c3-1f61-468f-9ad0-86afed9b0419",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 669,
                  "startColumn": 42,
                  "endLine": 669,
                  "endColumn": 45,
                  "charOffset": 21692,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21692,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21692,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-29122e96-305c-470d-9b0c-c979bbc6c1d8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 772,
                  "startColumn": 42,
                  "endLine": 772,
                  "endColumn": 45,
                  "charOffset": 24541,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24541,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24541,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-761b3e8c-de45-436c-86ea-8535d598f487",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 535,
                  "startColumn": 42,
                  "endLine": 535,
                  "endColumn": 45,
                  "charOffset": 17610,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17610,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17610,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-9d2c122c-a0c8-413d-b5a3-3939e86f0b37",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 42,
                  "endLine": 415,
                  "endColumn": 45,
                  "charOffset": 13642,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13642,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13642,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-e5361224-8447-4fd9-9162-190667907a7b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 42,
                  "endLine": 403,
                  "endColumn": 45,
                  "charOffset": 13221,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13221,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13221,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-2cdd17b8-a8fe-429e-9805-bc154a686e5b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 215,
                  "startColumn": 42,
                  "endLine": 215,
                  "endColumn": 45,
                  "charOffset": 6189,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6189,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6189,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-08e81c43-2a6c-4a97-9b6c-84963d7dc7da",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/MetaIndexes.cpp"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 12,
                  "endLine": 99,
                  "endColumn": 76,
                  "charOffset": 3181,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(sub_x + i * sub_d, x + ofs + i * d, sub_d * sizeof(sub_x)",
                    "rendered": {
                      "text": "memcpy(sub_x + i * sub_d, x + ofs + i * d, sub_d * sizeof(sub_x)",
                      "markdown": "`memcpy(sub_x + i * sub_d, x + ofs + i * d, sub_d * sizeof(sub_x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/MetaIndexes.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3181,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(sub_x + i * sub_d, <size of sub_x + i * sub_d>,  x + ofs + i * d,  sub_d * sizeof(sub_x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0d8ea8b0-b0db-49b1-89ac-5ff8d4ba898b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexFlatCodes.cpp"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 4,
                  "endLine": 97,
                  "endColumn": 37,
                  "charOffset": 2783,
                  "charLength": 113,
                  "snippet": {
                    "text": "memcpy(codes.data() + (ntotal * code_size),\n           other->codes.data(),\n           other->ntotal * code_size)",
                    "rendered": {
                      "text": "memcpy(codes.data() + (ntotal * code_size),\n           other->codes.data(),\n           other->ntotal * code_size)",
                      "markdown": "`memcpy(codes.data() + (ntotal * code_size),\n           other->codes.data(),\n           other->ntotal * code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexFlatCodes.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2783,
                        "charLength": 113
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codes.data() + (ntotal * code_size), <size of codes.data() + (ntotal * code_size)>, \n           other->codes.data(), \n           other->ntotal * code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1650076e-e88e-49ec-8ea4-a25b737e0886",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 42,
                  "endLine": 593,
                  "endColumn": 45,
                  "charOffset": 19140,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19140,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19140,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-83180e2c-e890-48ac-8f67-48d90bdbaebb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 9,
                  "endLine": 113,
                  "endColumn": 39,
                  "charOffset": 3278,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(bytes, ds, sizeof(char)",
                    "rendered": {
                      "text": "memcpy(bytes, ds, sizeof(char)",
                      "markdown": "`memcpy(bytes, ds, sizeof(char)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3278,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes, <size of bytes>,  ds,  sizeof(char)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-de14f7a8-a070-444b-a590-86bfceae85cb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 12,
                  "endLine": 96,
                  "endColumn": 15,
                  "charOffset": 2761,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2761,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2761,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-583c2a55-f53e-464a-8bb5-93985b1229e7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "c_api/gpu/example_gpu_c.c"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 19,
                  "endLine": 100,
                  "endColumn": 48,
                  "charOffset": 3120,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc(k * nq * sizeof(float)",
                    "rendered": {
                      "text": "malloc(k * nq * sizeof(float)",
                      "markdown": "`malloc(k * nq * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "c_api/gpu/example_gpu_c.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3120,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e390c38f-c2e1-4159-bdb0-47d2f96c6aa5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "c_api/gpu/example_gpu_c.c"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 16,
                  "endLine": 48,
                  "endColumn": 45,
                  "charOffset": 1346,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc(d * nq * sizeof(float)",
                    "rendered": {
                      "text": "malloc(d * nq * sizeof(float)",
                      "markdown": "`malloc(d * nq * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "c_api/gpu/example_gpu_c.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1346,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-157a723f-cfac-44da-bff9-1b974dee53b8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "c_api/gpu/example_gpu_c.c"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 19,
                  "endLine": 99,
                  "endColumn": 48,
                  "charOffset": 3069,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc(k * nq * sizeof(idx_t)",
                    "rendered": {
                      "text": "malloc(k * nq * sizeof(idx_t)",
                      "markdown": "`malloc(k * nq * sizeof(idx_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "c_api/gpu/example_gpu_c.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3069,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-141cc062-5616-4ad8-8656-7f34e13a180a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "c_api/gpu/example_gpu_c.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 36,
                  "endLine": 32,
                  "endColumn": 44,
                  "charOffset": 943,
                  "charLength": 8,
                  "snippet": {
                    "text": "RAND_MAX",
                    "rendered": {
                      "text": "RAND_MAX",
                      "markdown": "`RAND_MAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b6611e7f-2173-4d72-9e80-dc1df8037d60",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "c_api/gpu/example_gpu_c.c"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 19,
                  "endLine": 32,
                  "endColumn": 24,
                  "charOffset": 926,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}