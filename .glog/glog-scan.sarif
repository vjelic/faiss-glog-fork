{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "829d1dd4-e357-3254-a241-891b8e5a8158",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. In the provided code snippet, the function `strerror(errno)` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `strerror(errno)`, a safer alternative would be `strerror_r(errno, buf, buflen)`, which is thread-safe.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nchar buf[1024];\nFAISS_THROW_IF_NOT_FMT(ret == 0, \"fstat failed: %s\", strerror_r(errno, buf, sizeof(buf)))\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<errno.h>`: for `errno`\n- `<string.h>`: for `strerror_r(errno)`\n- `<sys/stat.h>`: for `fstat`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that all the provided links are active and accessible by anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "55832926-9b88-31cd-b897-314138476b4d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions in the code. These functions are prone to various types of security vulnerabilities such as buffer overflows, format string vulnerabilities, integer overflows, etc. The specific sink `ails->ptr != MAP_FAILED` is not a prohibited C function itself, but it's related to the use of `mmap` function which can lead to vulnerabilities if not used properly.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. If you must use them, ensure that you handle all possible error conditions. Always validate and sanitize input data. Use secure alternatives to these functions whenever possible.\n\n## Source Code Fix Recommendation\n\nThe `mmap` function is used to map files or devices into memory. It can return `MAP_FAILED` in case of an error. The correct way to use it is to always check the return value against `MAP_FAILED` before using the returned pointer.\n\n```cpp\nvoid* ptr = mmap(...);\nif (ptr == MAP_FAILED) {\n    // handle error\n} else {\n    // use ptr\n}\n```\n\n## Library Dependencies\n\nThe `mmap` function is part of the POSIX library. To use it, you need to include the `sys/mman.h` header file.\n\n```cpp\n#include <sys/mman.h>\n```\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "146d6b8d-9500-30e4-acbf-b793742fe9fc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This can cause unpredictable results or crashes, as the standard memory copy function does not handle overlapping regions safely. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which further increases the risk. There are no explicit checks or guards in the code to prevent these issues, and the classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a memory-safe function that handles overlapping regions, such as `memmove` instead of `memcpy`. Replace the original call with `memmove` to ensure correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(ptr + new_l.offset + new_l.capacity * code_size, get_ids(list_no), n * sizeof(idx_t));\n```\n\nAdditionally, ensure that the source pointer returned by `get_ids(list_no)` is not null before performing the copy. Add a check before the memory operation:\n\n```cpp\nvoid* src = get_ids(list_no);\nif (src != nullptr) {\n    memmove(ptr + new_l.offset + new_l.capacity * code_size, src, n * sizeof(idx_t));\n} else {\n    // Handle error: source is null\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "11784b33-ea2d-3411-b7a4-9b55e3fb520c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis suggests that the destination and source may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there is no evidence of checks to ensure that the source and destination are not null, increasing the risk of null pointer dereference. The absence of explicit bounds or capacity checks further increases the risk. The verdict is supported by the classification and the high-confidence 'GENUINE' label from the analysis.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. Ensure that both the source and destination pointers are valid and not null before performing the operation.\n\n```cpp\nif (new_lists.data() != nullptr && &lists[l0] != nullptr) {\n    memmove(new_lists.data(), &lists[l0], (l1 - l0) * sizeof(List));\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap. Always validate pointers before use to avoid null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f1869165-b929-3ebf-ab27-b2097321677a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This can cause unpredictable results or crashes, as the standard memory copy function does not support overlapping regions. Additionally, the analysis could not rule out the possibility that the source pointer is null, which further increases the risk. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the source and destination are distinct or valid. These factors indicate a real risk of undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a memory-safe function that supports overlapping regions. Replace the memory copy operation with a function designed for this purpose, such as `memmove`, which is safe for overlapping memory areas. For example:\n\n```cpp\nmemmove(ptr + new_l.offset, get_codes(list_no), n * code_size);\n```\n\nThis change ensures that the copy operation behaves correctly even if the source and destination regions overlap, eliminating the risk of undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9fdb8f84-49f3-3364-9160-2e20b247a0f9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory areas, as indicated by the data flow analysis. This can cause unpredictable results or program crashes, since the standard memory copy function does not support overlapping regions. Additionally, there is a risk that the source pointer could be null, as there is no prior check ensuring it is valid. The absence of explicit bounds checks or guards further increases the risk. These factors make this a high-confidence, actionable issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy` for such cases. This ensures that the copy operation works correctly even if the source and destination overlap.\n\n```cpp\nmemmove(codes + offset * code_size, codes_in, code_size * n_entry);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy:\n\n```cpp\nif (codes_in != nullptr) {\n    memmove(codes + offset * code_size, codes_in, code_size * n_entry);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "17c9bad1-4dfb-3ab8-be94-9df7f03d028d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This is a well-known source of undefined behavior in C/C++ when using functions like memcpy. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null at this call site, further increasing the risk. The destination is likely a local or field array, reducing the risk of it being null, but this does not mitigate the overlap issue. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. `memmove` is specifically designed to handle overlapping memory areas, whereas `memcpy` is not. \n\n**Remediation example:**\n\n```cpp\nmemmove(ids + offset, ids_in, sizeof(ids_in[0]) * n_entry);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "886f4aac-e5fe-3289-a467-e133d81a4541",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. In the provided code snippet, the function `strerror` is used, which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using non-thread-safe functions or those that can lead to buffer overflows or other security issues. Instead, use safer alternatives provided by the language or third-party libraries. In the case of `strerror`, a thread-safe alternative `strerror_r` can be used.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror` function with `strerror_r`:\n\n```cpp\nchar buf[1024];\nFAISS_THROW_IF_NOT_FMT(err == 0, \"munmap error: %s\", strerror_r(errno, buf, sizeof(buf)));\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- `cstring` for `strerror` function.\n- `cerrno` for `errno`.\n- `stdexcept` for `runtime_error`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fd9b7f22-eff3-399a-94da-50a1c2e20523",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can potentially introduce a security risk. In the context of C++ programming, certain C library functions are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service.\n\nIn the provided code snippet, the function `fopen` is used, which is a standard C library function for opening a file. The vulnerability arises when the filename is manipulated in a way that it points to a location that the program should not have access to, leading to potential unauthorized file system access.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to use these functions in a way that their risks are minimized. In the case of `fopen`, it is important to ensure that the filename cannot be manipulated to point to an unintended location.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ofstream f;\nf.open(filename.c_str(), std::ios::out);\nif (!f.is_open()) {\n    // Handle error\n}\n```\n\nIn this fixed code, the C++ `std::ofstream` is used instead of the C `fopen` function. This provides better type safety and exception handling.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<fstream>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ad1af128-cc77-3257-b9a5-1957e66c1d2f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the filename is not properly validated or controlled, potentially leading to arbitrary file read/write operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives provided by the C++ Standard Library, which includes exception handling and type safety. In this case, you can use the `fstream` class from the `<fstream>` library to open files.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `fstream` class:\n\n```cpp\n#include <fstream>\n\nstd::fstream f;\nf.open(filename.c_str(), std::fstream::in | std::fstream::out);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<fstream>`: This library provides facilities for file-based input and output.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "08e7519f-ba1e-3f4b-8464-a45e96c0bb35",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions that do not support overlapping regions. Additionally, the source may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly derived from a known capacity. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination buffers do not overlap. If there is any possibility of overlap, use a memory copy function that is safe for overlapping regions, such as `memmove`, instead of `memcpy`. For example, replace the original call with:\n\n```cpp\nmemmove(c, ScopedIds(il, list_no).get(), sz * sizeof(idx_t));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap. Additionally, consider adding explicit checks to ensure that neither the source nor the destination is null before performing the copy operation.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f1085e7a-6da6-353b-a098-66c1595c91fb",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the destination and source may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, the source pointer may be null, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly defined or checked against the copy size. These factors all contribute to the assessment that this is a real and actionable issue that should be addressed to prevent potential security and stability problems.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(c, ScopedCodes(il, list_no).get(), sz);\n```\n\nAdditionally, consider adding explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy. This can help prevent crashes due to null pointer dereferencing:\n\n```cpp\nif (c != nullptr && ScopedCodes(il, list_no).get() != nullptr) {\n    memmove(c, ScopedCodes(il, list_no).get(), sz);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "43f97c64-ba69-3c56-b489-21773aca1453",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may refer to overlapping memory, which can cause undefined behavior when using memory copy operations like memcpy. Additionally, there is a risk that the source pointer may be null, as there is no prior check ensuring it is valid. The destination is likely a local or field array, reducing the risk of it being null, but this does not mitigate the overlap or null source risks. No explicit bounds or capacity checks are present, and the count expression is not derived from the destination's capacity. These factors all contribute to the assessment that this is a genuine and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (ids_in != nullptr) {\n    memmove(&ids[list_no][offset], ids_in, sizeof(ids_in[0]) * n_entry);\n}\n```\n\nIf you are certain that overlap cannot occur, document this assumption clearly in the code and add assertions to enforce it at runtime:\n\n```cpp\nassert(ids_in != nullptr);\nassert(&ids[list_no][offset] + n_entry <= ids_in || ids_in + n_entry <= &ids[list_no][offset]);\nmemcpy(&ids[list_no][offset], ids_in, sizeof(ids_in[0]) * n_entry);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9a5a4676-a65d-31e5-8720-f6ad309db9ae",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null, which could lead to a crash or further undefined behavior. The destination is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. The classification and verdict both indicate a genuine risk that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the regions overlap.\n\n```cpp\nmemmove(&codes[list_no][offset * code_size], codes_in, code_size * n_entry);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy to avoid potential crashes:\n\n```cpp\nif (codes_in != nullptr) {\n    memmove(&codes[list_no][offset * code_size], codes_in, code_size * n_entry);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5ab4dc3a-fe8e-3ae3-b7b1-11d623dc9d74",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior with functions like memcpy. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, which further increases the risk. The destination is not likely to be null, but the overlap and null source risks are sufficient to make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping regions safely. Additionally, ensure that the source pointer is not null before performing the copy to avoid a null pointer dereference.\n\n```cpp\nif (code != nullptr) {\n    memmove(&codes[list_no][o * code_size], code, code_size * n_entry);\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination overlap, and it also guards against null pointer dereference. For further information, see the following resources:\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e70516d9-65a0-3c97-97bd-ed0cf7f1f4c6",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a 'UB Risk' (undefined behavior risk) due to possible overlap between the source and destination memory regions in a memory copy operation. The analysis detected that the source and destination may overlap based on data flow, which can lead to undefined behavior when using functions like memcpy. Additionally, there is a risk that the source pointer may be null, as there is no prior check ensuring it is non-null. The destination is less likely to be null, but the primary concern is the potential for overlapping memory regions, which is not safe with memcpy. These factors indicate a real risk of undefined behavior and possible security or correctness issues.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping regions. Additionally, ensure that the source pointer is not null before performing the copy operation. For example:\n\n```cpp\nif (ids_in != nullptr) {\n    memmove(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n}\n```\n\nThis change ensures that the copy is safe even if the source and destination overlap, and avoids dereferencing a null pointer. \n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1970ef80-8756-33cd-8edd-1ae8241e91e6",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "336fe975-41e7-3c03-9422-77e7974c1cef",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "65683616-7ceb-3963-b010-176378ea4876",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "93440079-6472-3e06-aab5-b8afa921cff8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b9e0180f-0caa-33a3-9dda-38e223b7465a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code example `memcpy(u8, x, 32)`, if the size of `x` is larger than the size of `u8`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code, potentially gaining unauthorized access to the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code example:\n\n```cpp\nif(sizeof(u8) >= 32) {\n    memcpy(u8, x, 32);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if the size of `u8` is at least 32 before calling `memcpy`. If `u8` is not large enough, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code example.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "57102ed5-1506-320a-8c40-e4297169239d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code example `memcpy(ptr, u8, 32)`, if the size of `ptr` is less than 32 bytes, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAlso, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11) which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `strncpy`:\n\n```cpp\nchar ptr[32];\nstrncpy(ptr, u8, sizeof(ptr));\nptr[sizeof(ptr) - 1] = '\\0'; // Ensure null-termination\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "da45c7af-ae85-35dd-bdeb-6b2c7389070a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code example `memcpy(u8, ptr, 32)`, if the size of `u8` is less than 32 bytes, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code example:\n\n```cpp\nif (sizeof(u8) >= 32) {\n    memcpy(u8, ptr, 32);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if the size of `u8` is at least 32 bytes before calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f0dd8a5c-b513-35c7-a2ee-91d90b4163be",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"quantizer_\")` is used to determine the length of a constant string. This is not a vulnerability per se, but it's a bad practice because the length of a constant string can be determined at compile time, making the use of `strlen` unnecessary and inefficient.\n\n## Mitigation Advice\n\nAvoid using `strlen` to determine the length of constant strings. Instead, use the `sizeof` operator, which can determine the length at compile time, or simply hard-code the length if it's known.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(\"quantizer_\")` with `sizeof(\"quantizer_\") - 1` or `10` (the actual length of the string \"quantizer_\").\n\n```cpp\nsub_name = name.substr(sizeof(\"quantizer_\") - 1);\n```\n\nor\n\n```cpp\nsub_name = name.substr(10);\n```\n\n## Library Dependencies\n\nThe code snippet requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "d094616b-96df-34f6-a7c0-8a2ab84867d2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no explicit check to ensure that the source pointer is not null, which could also lead to undefined behavior. The absence of a guard for the source pointer and the lack of evidence that the destination buffer is sufficiently sized further increase the risk. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid dereferencing a null pointer.\n\n```cpp\nif (v2 != nullptr && v2_in != nullptr) {\n    memmove(v2, v2_in, sizeof(int64_t) * k2);\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination overlap, and it also guards against null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f4fe7a17-d74e-3cc7-a020-cc850d27a743",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions that do not support overlapping regions. Additionally, the source may be null at this call site, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's capacity is not clearly defined or enforced. These factors together indicate a high-confidence, actionable issue that should be addressed to ensure memory safety and program correctness.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that safely handles overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. For example, change the code to:\n\n```cpp\nmemmove(&x_subset[i * d], &x[subset[i] * size_t(d)], sizeof(x[0]) * d);\n```\n\nThis change ensures that even if the source and destination regions overlap, the data will be copied correctly without causing undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "152ca755-37f1-390e-95ec-7134ee5a85f3",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no explicit check to ensure that the source pointer is not null, which could also lead to undefined behavior. The destination is a pointer, and there is no evidence that its capacity is being checked or that the length argument is derived from the destination's size. These factors, combined with the high-confidence classification and verdict, indicate a real risk of memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n**Remediation Example:**\n\n```cpp\nif (lI0 != nullptr && tmpI.data() != nullptr) {\n    memmove(lI0, tmpI.data(), sizeof(lI0[0]) * k);\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds null pointer checks for both the destination and source. This ensures safe copying even if the memory regions overlap and prevents undefined behavior due to null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ea2271c2-45db-36d2-8bfa-11dedc5e7f47",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no explicit check to ensure that the source pointer is not null, which could also lead to undefined behavior. The destination is a pointer type, and there is no evidence that the length argument is derived from the destination's capacity, nor is there a guard to prevent underflow or null pointer dereference. These factors collectively indicate a high-confidence, actionable issue that could result in memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (lD0 != nullptr && tmpD.data() != nullptr) {\n    memmove(lD0, tmpD.data(), sizeof(lD0[0]) * k);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fe256194-aac1-3eae-902e-58f8d5df2d09",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1fb9ee43-26cc-383a-aa3c-cc709008218f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if the `fname` parameter is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation and sanitization. In the case of `fopen`, it is important to ensure that the `fname` parameter does not contain any malicious input that could lead to a file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::string fname;\n// ... (set fname to the desired file name)\nstd::ifstream f(fname);\nif (!f.is_open()) {\n    // handle error\n}\n```\n\nIn this fixed code, the C++ `std::ifstream` class is used instead of the C `fopen` function. This class automatically handles many of the potential issues with `fopen`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n* `<fstream>`\n\n## References\n\n* [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/CPlusPlus_Security_Cheat_Sheet.html)\n* [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "59ea5dec-cff1-38bf-a7be-e60499c1b3be",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination pointers are non-null, increasing the risk of null pointer dereference. The verdict is marked as genuine, and the risk is further supported by the absence of explicit bounds or null checks, as well as the dataflow analysis indicating overlap. Developers should ensure that the source and destination do not overlap and are valid before performing the memory copy operation.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that both the source and destination pointers are not null before the copy operation.\n\n```cpp\nif (ptrs.data() != nullptr && lims != nullptr) {\n    // If overlap is possible, use memmove instead of memcpy\n    memmove(ptrs.data(), lims, sizeof(lims[0]) * nbucket);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c55fdf17-d59e-3219-a616-723a70d9d6b7",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The code copies data from one region to another using a memory copy function, but dataflow analysis suggests that the source and destination may refer to overlapping memory areas. This can lead to unpredictable results or program crashes, as the memory copy function does not guarantee correct behavior when regions overlap. Additionally, the analysis could not rule out the possibility that the source pointer is null, which could also cause a crash. There are no explicit checks or guards in the code to prevent these issues, and the classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with a memory move function, which is designed to handle overlapping regions safely. For example, change the code to use `memmove` instead of `memcpy`:\n\n```cpp\nmemmove(permB + segs[s].i0, permA + segs[s].i0, segs[s].len() * sizeof(size_t));\n```\n\nThis ensures that the copy operation works correctly even if the source and destination regions overlap. Additionally, consider adding checks to ensure that the source pointer is not null before performing the operation to avoid potential crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ef8b743a-745e-3369-852a-9dde3d4756a8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflow, memory corruption, or other similar issues. The `memmove` function is one of these prohibited functions. It is used to copy a block of memory from one location to another and can lead to vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `memmove` such as `memcpy_s` or `memmove_s` which are part of the C11 standard. These functions include additional parameters that specify the maximum size of the destination buffer, which can help prevent buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `memmove_s` or `memcpy_s`. Here is an example of how to do it:\n\n```cpp\n#include <string.h>\n\nvoid unsafe(char *src, char *dest, size_t n) {\n    memmove(dest, src, n);\n}\n\nvoid safe(char *src, char *dest, size_t n, size_t max) {\n    memmove_s(dest, max, src, n);\n}\n```\n\nIn this example, `memmove_s` is used instead of `memmove`. The `max` parameter specifies the maximum size of the destination buffer.\n\n## Library Dependencies\n\nThe `string.h` library is required for the `memmove` and `memmove_s` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d1ef891d-f844-3b7e-86e8-9d5d3cf2e658",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with standard memory copy functions. Additionally, the source pointer may be null, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the count expression is not directly tied to the destination's capacity. These factors all contribute to a high confidence in the finding's validity and a low probability of it being a false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the regions overlap.\n\n```cpp\nmemmove(dst + sw.i0, src + s2t.i0, s2t.len() * sizeof(dst[0]));\n```\n\nAdditionally, ensure that both source and destination pointers are valid and not null before performing the operation. If possible, add explicit checks or assertions to validate the pointers and the size of the copy.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c2989b22-2162-30cd-9e07-b331bcf4ca56",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with standard memory copy functions. Additionally, the source pointer may be null, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's capacity is not clearly defined or checked. These factors all contribute to the high confidence in this being a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the regions overlap.\n\n```cpp\nmemmove(dst + sw.i0, src + s1t.i0, s1t.len() * sizeof(dst[0]));\n```\n\nAdditionally, ensure that both source and destination pointers are valid and not null before performing the operation. If possible, add explicit checks to verify that the source and destination do not overlap in an unsafe way, or document the function's requirements clearly.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "91c877d1-90d8-3f14-9489-fe0b56e9a8c0",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Found\" is a vulnerability that occurs when a C++ program uses a function that is considered unsafe due to its potential to cause buffer overflow, memory corruption, or other similar issues. The `memmove` function is one of these prohibited functions. It is used to copy a block of memory from one location to another and can lead to vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `memmove` such as `memcpy_s` or `memmove_s` which are part of the C11 standard. These functions include additional parameters that specify the maximum size of the destination buffer, which can help prevent buffer overflow vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `memmove_s` or `memcpy_s`. Here is an example of how to do it:\n\n```cpp\n#include <string.h>\n\nvoid unsafe(char *src, char *dest, size_t n) {\n    memmove(dest, src, n);\n}\n\nvoid safe(char *src, char *dest, size_t n, size_t max) {\n    memmove_s(dest, max, src, n);\n}\n```\n\nIn this example, `memmove_s` is used instead of `memmove`. The `max` parameter specifies the maximum size of the destination buffer.\n\n## Library Dependencies\n\nThe `string.h` library is required for the `memmove` and `memmove_s` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "05671d44-76c7-3ed8-b5c8-49008155031d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c91b88ce-48e8-309d-9581-a1d740df821c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "eaa16495-16e0-3ff3-ad13-bbd3e523e511",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "419458cd-4602-378d-9018-60b7b9fde656",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c942bf37-bd46-35e3-a9cc-45155c0855c8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of valid data, crash the application, or in worst case scenarios, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by using functions that limit the amount of data copied to the size of the destination buffer, such as `strncpy` or `memcpy_s`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s`, which includes an additional parameter for the size of the destination buffer. This ensures that the function does not write more data than the buffer can hold, preventing buffer overflow.\n\n```cpp\n// Assuming 'dest' is the destination buffer and 'src' is the source data\n// 'destSize' is the size of the destination buffer and 'count' is the amount of data to copy\nmemcpy_s(dest, destSize, src, count);\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the code to execute properly.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b72052b8-64c4-3ca0-b234-e10df22d4394",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet `memcpy(new_ptr, ptr, sizeof(T))`, if the size of `T` is larger than the size of `new_ptr`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code snippet:\n\n```cpp\nif (sizeof(T) <= sizeof(new_ptr)) {\n    memcpy(new_ptr, ptr, sizeof(T));\n} else {\n    // Handle error\n}\n```\n\nIn this code, we check if the size of `T` is less than or equal to the size of `new_ptr` before calling `memcpy`. If `T` is larger than `new_ptr`, we handle the error instead of causing a buffer overflow.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "bd247ac0-9838-3c52-b1d8-36a7df58ed5d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null at this point in the code, since there is no prior check ensuring it is non-null. The destination is likely a local or field array, reducing the risk of it being null. No explicit bounds or capacity checks are present, and the count argument is not derived from the destination's capacity. These factors all contribute to the high confidence in this being a genuine issue that could lead to undefined behavior, memory corruption, or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (ids_in != nullptr) {\n    memmove(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly and consider adding assertions to enforce it during development:\n\n```cpp\nassert(ids_in != &ids[list_no][o]); // Ensure no overlap\nmemcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0]) * n_entry);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8c89d273-2481-32bb-836a-44ffb7f16096",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is no evidence of a guard to prevent the source from being null, which further increases the risk. The destination is not likely to be null, but the source could be. The operation does not use a standard size or capacity check, and the count argument is not derived from the destination's capacity. These factors all contribute to the assessment that this is a real and actionable issue that could lead to undefined behavior or memory corruption.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the source and destination overlap.\n\n```cpp\nmemmove(&codes[list_no][o * code_size], code, n_block * block_size);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy:\n\n```cpp\nif (code != nullptr) {\n    memmove(&codes[list_no][o * code_size], code, n_block * block_size);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "62d96ae8-9ad6-3890-9544-8435b41852e2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often referred to as \"banned\" functions. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data exceeds the size of the destination buffer. This can cause crashes, data corruption, and potentially allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using the `sprintf` function. Instead, use safer alternatives that check the size of the destination buffer, such as `snprintf`.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf`. Here is an example:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", someString);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", someString);\n```\n\nIn the fixed code, `snprintf` checks that it does not write more than `sizeof(buffer)` characters, including the null terminator, preventing buffer overflow.\n\n## Library Dependencies\n\nThe `sprintf` and `snprintf` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5efd201b-72fc-3848-8b86-5c138a820645",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The source and destination pointers may alias, as indicated by the observed assignment relationship. Additionally, there is no evidence of a guard ensuring that the source is non-null, which increases the risk of a null pointer dereference. The destination is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence issue. The classification and verdict both indicate a genuine problem that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the regions overlap.\n\n```cpp\nmemmove(tab, norm_lut, norm_dim12 * sizeof(*tab));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and non-null before performing the operation. For example:\n\n```cpp\nif (tab != nullptr && norm_lut != nullptr) {\n    memmove(tab, norm_lut, norm_dim12 * sizeof(*tab));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d4a3ba91-9e71-332b-aadc-e6fc2e637d5a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the `memmove` function is used, which can lead to buffer overflow if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions whenever possible. For instance, instead of `memmove`, consider using `std::copy` from the C++ Standard Library, which is type-safe and less prone to errors.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy`. Here is how you can do it:\n\n```cpp\n#include <algorithm> // for std::copy\n\n// ...\n\nstd::copy(codes + i * code_size, codes + i * code_size + code_size, code + coarse_size);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memmove`\n- `<algorithm>` for `std::copy`\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "65ce472d-9ffe-31f2-9bc9-28a6b3b1930d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the data being copied is not checked before the `memcpy` operation, which can lead to a buffer overflow if the size of `ds` is larger than the size of `bytes`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data before the `memcpy` operation. If the size of the data is larger than the size of the destination buffer, do not perform the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\n#include <cstring> // for memcpy\n#include <cstdlib> // for malloc\n\nchar* bytes = (char*) malloc(sizeof(char) * 10); // allocate memory for bytes\nchar* ds = \"1234567890\"; // data to be copied\n\nif (sizeof(ds) <= sizeof(bytes)) {\n    memcpy(bytes, ds, sizeof(char) * 10); // copy data\n} else {\n    // handle error\n}\n```\n\nIn this fixed code, we first check if the size of `ds` is less than or equal to the size of `bytes` before performing the `memcpy` operation.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n- `<cstdlib>`: This library is required for the `malloc` function.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "64a16ac3-1fc5-354c-9c7d-32ccab564618",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from the same base (as indicated by the dataflow analysis), which means they may refer to overlapping memory areas. The use of a standard memory copy function in such a scenario can lead to unpredictable results, including data corruption or crashes. Additionally, the analysis could not rule out the possibility that the source pointer may be null, which further increases the risk. There are no explicit checks or guards in the code to prevent these issues, and the classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with a function that is safe for overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is specifically designed to handle overlapping memory areas safely. For example, change the code to:\n\n```cpp\nmemmove(c + i * subdim, &cache[codes[i] * subdim], sizeof(*c) * subdim);\n```\n\nThis ensures that even if the source and destination regions overlap, the data will be copied correctly without causing corruption or crashes.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "152d10cc-34aa-3e85-ad1a-e1b6d9704173",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected, through data flow, that the destination and source may reference overlapping memory, which can cause unpredictable results with memcpy. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null, further increasing the risk. The destination is likely a local or field array, reducing the risk of it being null, but this does not mitigate the overlap concern. These factors together confirm the presence of a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping source and destination regions safely. For the given code, update the call as follows:\n\n```cpp\nmemmove(&cache[i * dimsub], c.data() + dim - dimsub, dimsub * sizeof(*c.data()));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap. Always verify that both source and destination pointers are valid and not null before performing the operation.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "730b0633-00ea-332d-881a-74012922eecc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, the source pointer may be null at this location, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's capacity is not clearly defined or checked. This combination of factors makes the issue highly likely to be a real and exploitable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping source and destination regions safely. For example, change the code to:\n\n```cpp\nmemmove(dest + (sq / 2 * nq + qi) * 32 + 16, src + (q * nsq + sq + 1) * 16, 16);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. If possible, add explicit checks or assertions to verify pointer validity and buffer sizes to prevent buffer overflows and null pointer dereferences.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "114fa345-18d9-309b-91c9-2db23400ed96",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that overlap is feasible based on data flow between the destination and source expressions. Additionally, the source pointer may be null at this call site, which further increases the risk of undefined behavior. There are no explicit guards or checks to prevent these issues, and the count argument is a fixed literal, which does not mitigate the overlap risk. As a result, this finding should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely.\n\n**Remediation example:**\n\n```cpp\nmemmove(dest + (sq / 2 * nq + qi) * 32, src + (q * nsq + sq) * 16, 16);\n```\n\nThis change ensures that even if the source and destination regions overlap, the memory copy will be performed correctly without causing undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "578c55e4-4d0f-3c8f-aefc-e39096208a50",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from the same or related base, and dataflow analysis indicates that the destination may overlap with the source. Additionally, the source pointer may be null at this call site, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. This type of vulnerability can lead to unpredictable program behavior, data corruption, or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not result in data corruption or unpredictable behavior even if the regions overlap.\n\n```cpp\nmemmove(dest + (sq / 2 * nq + q) * 32, src + (q * nsq + sq) * 16, 16);\n```\n\nAdditionally, ensure that both `src` and `dest` pointers are valid and not null before performing the memory operation. You can add checks like:\n\n```cpp\nif (src != nullptr && dest != nullptr) {\n    memmove(dest + (sq / 2 * nq + q) * 32, src + (q * nsq + sq) * 16, 16);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b0d3fda1-07f6-33a5-9e10-70ab8481fc6d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may reference overlapping memory, which is not allowed for the standard memory copy function used here. Additionally, the source pointer may be null at this call site, which could also lead to a crash or undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function does not ensure that the source and destination are distinct or valid. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use a memory move function that is designed to handle overlapping regions. For example, replace the memory copy function with a memory move function:\n\n```cpp\nmemmove(dest + (sq / 2 * nq + q) * 32 + 16, src + (q * nsq + sq + 1) * 16, 16);\n```\n\nAdditionally, add explicit checks to ensure that the source pointer is not null before performing the operation:\n\n```cpp\nif (src != nullptr) {\n    memmove(dest + (sq / 2 * nq + q) * 32 + 16, src + (q * nsq + sq + 1) * 16, 16);\n}\n```\n\nThis change will prevent undefined behavior if the source and destination regions overlap and will avoid crashes due to null pointers.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2084664d-108d-3363-b022-3e0ebdae70ae",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, the source pointer may be null, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the count argument is not derived from the destination's capacity, increasing the risk of memory errors.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(x + i * d, xt + i * nbits, nbits * sizeof(xt[0]));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. If the size of the copy is derived from variables, validate that the size does not exceed the bounds of either buffer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f152cc97-359d-3cff-91aa-b59ac107f74a",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis observed that the destination and source may alias each other, as indicated by the assignment 'xt = rrot.apply(n, x)'. The verdict for this call site is also marked as 'GENUINE', confirming the high confidence in the issue. The source and destination are both pointers, and there is no evidence of explicit overlap prevention. Additionally, the function used (memcpy) is not safe for overlapping memory regions, which can lead to unpredictable results or crashes. There are no null pointer risks detected for either the source or destination, but the primary concern is the potential for memory overlap, which is a well-known cause of undefined behavior in C/C++ programs.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not result in data corruption or crashes, even if the regions overlap.\n\n```cpp\nmemmove(xt, x, sizeof(*x) * n * nbits);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "af03e58b-f774-367e-94e8-f95f1ff8b59e",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior when using memory copy operations like memcpy. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null at this point, increasing the risk of a crash or further undefined behavior. The destination is a pointer type, and there is no indication that the length argument is derived from the destination's capacity, which further increases the risk. These factors together make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory regions safely. Replace the original call with:\n\n```cpp\nmemmove(xi, c, sizeof(*x) * q->d);\n```\n\nAdditionally, ensure that both `xi` and `c` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (xi != nullptr && c != nullptr) {\n    memmove(xi, c, sizeof(*x) * q->d);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3ce35f57-9bc2-3827-bb78-1cb8337ddb40",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis indicates that they may refer to overlapping memory areas. In C and C++, using memcpy with overlapping memory is undefined behavior and can lead to data corruption or crashes. There are no explicit checks or guards in the code to prevent this overlap, and the function does not use a safer alternative that handles overlapping regions. The source and destination are both confirmed to be non-null, so the main risk is the potential for memory overlap.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the memory areas overlap.\n\n```cpp\nmemmove(xi, c, sizeof(*x) * q->d);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e072c7fe-67ca-3a7a-9545-684762dd0b88",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent this, and the source pointer may be null at this point, which could also lead to a crash or undefined behavior. The destination is a pointer, and there is no information about its capacity or bounds checking. These factors together indicate a real risk of memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(cb, q->codebooks.data(), sub_codebook_size * sizeof(float));\n```\n\nAdditionally, add checks to ensure that the source pointer is not null before performing the copy:\n\n```cpp\nif (q->codebooks.data() != nullptr) {\n    memmove(cb, q->codebooks.data(), sub_codebook_size * sizeof(float));\n}\n```\n\nThis change will prevent undefined behavior due to overlapping memory and null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ef78a412-d7eb-3021-8343-4edb683d13ac",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from related data structures or pointers, and dataflow analysis indicates that they may refer to overlapping memory. Additionally, there are no explicit checks or guards in the code to prevent null pointers for either the source or destination, which further increases the risk. The classification specifically highlights undefined behavior due to overlapping memory regions, which is a well-known issue with memory copy functions like memcpy. The verdict is supported by the high-confidence classification and the absence of mitigating factors such as bounds checks, explicit null checks, or evidence that the source and destination are always distinct.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions, such as `memmove`. This function is designed to handle overlapping source and destination memory areas correctly. For example, change the code to:\n\n```cpp\nmemmove(xsub.data() + i * q->d, x + i * d + offset_d, q->d * sizeof(float));\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the operation. You can add explicit checks before the memory operation:\n\n```cpp\nif (xsub.data() && x) {\n    memmove(xsub.data() + i * q->d, x + i * d + offset_d, q->d * sizeof(float));\n}\n```\n\nThis will help prevent undefined behavior due to null pointers as well as overlapping memory regions.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "870414e2-ee65-3b68-8f12-e5d65c184d74",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The code copies data from one memory region to another using a standard memory copy function, but dataflow analysis indicates that the source and destination may overlap, which is not allowed for this function and can result in unpredictable behavior. Additionally, there is no evidence of checks to ensure that the source and destination pointers are not null, which further increases the risk of runtime errors. The absence of explicit bounds checks or guards, and the lack of information about the actual buffer sizes, means that this code is at high risk for undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy` for this purpose. `memmove` is designed to correctly handle overlapping source and destination buffers.\n\n**Remediation Example:**\n\n```cpp\nmemmove(xt.data() + i * q->d, x + i * d + offset_d, q->d * sizeof(*x));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c2320358-484a-331b-afc2-ac578f490ddd",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The destination buffer is a pointer with no known capacity, and the size of the copy is determined by a variable whose safety is not established. These factors together indicate a real risk of memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination buffers do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid crashes.\n\n```cpp\nif (recons != nullptr && invlists->get_single_code(list_no, offset) != nullptr) {\n    memmove(recons, invlists->get_single_code(list_no, offset), code_size);\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds null pointer checks for both the destination and source. This ensures safe copying even if the memory regions overlap and prevents dereferencing a null pointer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "58a11958-a1cc-3655-87a0-99e4648597d1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts characters until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to a buffer overflow. This can result in undefined behavior, including program crashes, incorrect results, or even code execution.\n\nIn the provided code snippet, the `strlen` function is used to check if the length of the string `sx` is equal to 4. If `sx` is not null-terminated, this could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen` on strings that may not be null-terminated. Instead, consider using functions that take the length of the string as an argument, such as `strnlen`, which will not read past the specified length.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` and add a maximum length to prevent buffer overflow:\n\n```cpp\nFAISS_THROW_IF_NOT(4 == strnlen(sx, MAX_LENGTH))\n```\n\nReplace `MAX_LENGTH` with the maximum length of the string `sx`.\n\n## Library Dependencies\n\nThe provided code snippet requires the following libraries:\n\n- `cstring` or `string.h` for `strlen` or `strnlen`\n- `faiss/impl/FaissAssert.h` for `FAISS_THROW_IF_NOT`\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "a5d2717d-e878-33d4-bc4a-8062b34a3bbf",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there are no checks ensuring that the source and destination pointers are non-null before the operation, which increases the risk of null pointer dereference. The absence of explicit bounds checks or guards further increases the risk of buffer overflows or memory corruption. These factors make this a high-confidence, actionable issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. If overlap is possible, use a function that safely handles overlapping regions, such as `memmove`. Also, add explicit checks to ensure that both the source and destination pointers are not null, and that the copy size does not exceed the bounds of either buffer.\n\n```cpp\nif (buffer.data() != nullptr && src != nullptr && nb1 <= buffer.size()) {\n    // If overlap is possible, use memmove instead of memcpy\n    memmove(buffer.data(), src, nb1);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "de532ab1-48fe-3c6d-a6a8-4978d74c1876",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to execution of arbitrary code, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the data being copied is greater than the size of the destination buffer, then the program should handle this condition appropriately, such as by truncating the data or by allocating a larger buffer.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the specific vulnerability sink:\n\n```cpp\nif (N * K * sizeof(node_t) <= sizeof(data)) {\n    memcpy(data, g.data, N * K * sizeof(node_t));\n} else {\n    // Handle error condition, such as by truncating data or allocating a larger buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2dc4f657-1f96-3c4a-b264-85598cc8d15a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which could lead to null pointer dereference. The absence of explicit bounds checks or guards further increases the risk. The verdict is supported by the classification and the automated assessment, which both indicate a high-confidence issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation. For example:\n\n```cpp\nif (src != nullptr && buffer.data() != nullptr && nb > 0) {\n    memmove(buffer.data() + b0, src, nb);\n}\n```\n\nThis change ensures safe copying even if the memory regions overlap and prevents null pointer dereference. Always validate the size parameter (`nb`) to avoid buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "9b9f1611-450e-36e8-a28d-51defe71bddc",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the destination and source may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, further increasing the risk. The destination is a pointer type with no known capacity, and the count argument is not derived from the destination's size, which means there is no guarantee that the copy will be safe. These factors all contribute to a high confidence that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of memcpy with memmove, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(dst, buffer.data(), nb2);\n```\n\nBefore making this change, ensure that both the source and destination pointers are valid and that the number of bytes to copy does not exceed the size of either buffer. If the source pointer could be null, add a check to prevent dereferencing a null pointer:\n\n```cpp\nif (buffer.data() != nullptr && dst != nullptr) {\n    memmove(dst, buffer.data(), nb2);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "649b1afd-bf2b-3fb8-ba10-4d6aa27fd77e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The source and destination may overlap, as indicated by the dataflow analysis, which can cause unpredictable results with memcpy. Additionally, there is a possibility that the source pointer could be null at this point, as there is no prior check ensuring it is non-null. The destination is less likely to be null, but the main concern is the overlap and undefined behavior. No explicit buffer size checks or guards are present, and the count argument is not derived from the destination's capacity, increasing the risk. This combination of factors makes the issue highly likely to be a true positive and a real risk in the code.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. `memmove` is specifically designed to handle overlapping memory areas, whereas `memcpy` is not. Additionally, ensure that both source and destination pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (dst != nullptr && buffer.data() + b0 != nullptr) {\n    memmove(dst, buffer.data() + b0, nb);\n}\n```\n\nThis change ensures that the copy is safe even if the regions overlap, and it also guards against null pointer dereference. Always validate the size (`nb`) to ensure it does not exceed the bounds of either buffer.\n\n## References\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dba21b98-c748-3a27-b3dd-15474d13c799",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that arises when a program uses a function that can potentially introduce a security risk. In this case, the `fopen` function is used, which can lead to vulnerabilities such as arbitrary file overwrite, directory traversal, or other file-based attacks if the `fname` parameter is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen` that provide better control over file access and permissions. Also, always validate and sanitize input that will be used as a filename or a part of a filename. Avoid using user input to construct a filename if possible.\n\n## Source Code Fix Recommendation\n\nInstead of using `fopen`, consider using `fopen_s` which is a safer alternative. Here is an example of how to use it:\n\n```cpp\nerrno_t err;\nFILE* f;\nerr = fopen_s(&f, fname, \"wb\");\nif (err != 0) {\n    // Handle error\n}\n```\n\nIn this example, `fopen_s` returns an error code that can be checked to ensure the file was opened successfully.\n\n## Library Dependencies\n\nThe code example requires the `stdio.h` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6786065e-61c7-3c7b-aca0-8deed6ba7411",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `fopen` function is used, which can lead to vulnerabilities if the file name (`fname`) is manipulated by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. In the case of `fopen`, consider using `fopen_s` which is a more secure alternative. Always validate and sanitize inputs to these functions to prevent any malicious manipulation.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with `fopen_s`:\n\n```cpp\nerrno_t err;\nFILE* f;\nerr = fopen_s(&f, fname, \"rb\");\nif (err != 0) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0ccc6549-8f3d-3762-9d7b-1ead0627e652",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory areas, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null at this point in the code, since there is no prior check ensuring it is non-null. The absence of explicit bounds checks or guards further increases the risk. These factors make this a high-confidence, actionable issue that could lead to unpredictable program behavior or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (ptr != nullptr) {\n    memmove(&data[o], ptr, size * nitems);\n}\n```\n\nIf you are certain that overlap cannot occur, document this assumption clearly and consider adding assertions to enforce it at runtime:\n\n```cpp\nassert(ptr != &data[o]); // or a more precise non-overlap check\nmemcpy(&data[o], ptr, size * nitems);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2c46a065-6a91-3b2c-ade3-26242e1cf925",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. The destination buffer type is a generic pointer, and the size calculation is not directly tied to a known buffer capacity, increasing the risk of memory safety violations.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(ptr, &data[rp], size * nitems);\n```\n\nAdditionally, validate that the source pointer is not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (&data[rp] != nullptr) {\n    memmove(ptr, &data[rp], size * nitems);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0c70383c-25ae-345c-90df-8b474838d8fc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are both derived from potentially overlapping data flows, which can cause undefined behavior when using memory copy functions like memcpy. Additionally, the source may be null at this call site, which further increases the risk of a crash or security issue. There are no explicit checks or guards in place to prevent these issues, and the destination buffer's size is not clearly defined or enforced. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory regions safely. Replace the original call with:\n\n```cpp\nmemmove(ptr, PyBytes_AsString(result), sz);\n```\n\nAdditionally, ensure that both `ptr` and the result of `PyBytes_AsString(result)` are valid, non-null pointers before performing the copy. For example:\n\n```cpp\nif (ptr != NULL && PyBytes_AsString(result) != NULL) {\n    memmove(ptr, PyBytes_AsString(result), sz);\n}\n```\n\nThis change eliminates the risk of undefined behavior due to overlapping memory regions and null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c1cfd870-7d7e-355e-8de6-cd877a1c7d23",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to a variety of security issues.\n\nThe specific vulnerability sink in question is `(double)rand() / (double)RAND_MAX`. The `rand()` function in C++ is a weak random number generator that is not suitable for cryptographic purposes. It generates a pseudo-random number that can be easily predicted, especially if the seed is known or can be guessed.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use the `<random>` library, which provides a variety of random number generators that are more suitable for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nReplace the use of `rand()` with a cryptographic random number generator. Here is an example using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\ndouble random = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "c1cfd870-7d7e-355e-8de6-cd877a1c7d23"
                ]
              }
            },
            {
              "id": "becf4d46-43dd-31a3-84c1-5e0bdb43abb9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to a variety of security issues.\n\nThe specific vulnerability sink in question is `(double)rand() / (double)RAND_MAX`. The `rand()` function in C++ is a weak random number generator that is not suitable for cryptographic purposes. It generates a pseudo-random number that can be easily predicted, especially if the seed is known or can be guessed.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use the `<random>` library, which provides a variety of random number generators that are more suitable for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nReplace the use of `rand()` with a cryptographic random number generator. Here is an example using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\ndouble random = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "becf4d46-43dd-31a3-84c1-5e0bdb43abb9"
                ]
              }
            },
            {
              "id": "64180376-1b1c-3b46-a98a-a43d6eacfdcc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may refer to overlapping memory regions through data flow, which can cause unpredictable results when using memory copy functions that do not support overlapping regions. Additionally, there is a risk that the source pointer may be null, as there is no prior check ensuring it is valid. The destination is less likely to be null, but the primary concern is the potential for overlapping memory and undefined behavior. No explicit buffer size or guard checks are present, and the count argument is not derived from the destination's capacity, increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. Additionally, ensure that both the source and destination pointers are valid and that the size argument does not exceed the capacity of either buffer. For example:\n\n```cpp\nif (centroids != nullptr && x != nullptr) {\n    memmove(centroids, x, n * sizeof(*x));\n}\n```\nThis change ensures that the copy is safe even if the memory regions overlap, and adds basic null pointer checks. For further safety, validate that `n * sizeof(*x)` does not exceed the allocated size of either buffer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fe14c683-0ec4-32f3-af98-4c77d2542070",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as 'GENUINE', and the classification explicitly states a risk of undefined behavior. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, both the source and destination pointers may be null at this call site, and there are no explicit guards to prevent this. The count argument is not directly tied to the destination's capacity, and there are no additional safety checks or null-termination after the copy. All these factors indicate a high likelihood of a real issue that could lead to memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not result in data corruption or crashes if the source and destination regions overlap.\n\n```cpp\n// Replace memcpy with memmove to safely handle overlapping regions\nstd::memmove(tmp.data() + i * old_code_size, bytes + i * new_code_size + (new_code_size - old_code_size), old_code_size);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. Add explicit checks if necessary to avoid null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ce7d3c8a-02fb-3cd2-968f-84327cf0b07b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `std::memmove` function is used, which can lead to buffer overflow if not used carefully.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `std::memmove`, consider using `std::copy` or `std::copy_backward` from `<algorithm>` header.\n\n## Source Code Fix Recommendation\n\nReplace `std::memmove` with `std::copy` or `std::copy_backward`:\n\n```cpp\nstd::copy_backward(\n    bytes + i * old_code_size,\n    bytes + i * old_code_size + old_code_size,\n    bytes + i * new_code_size + new_code_size);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for `std::memmove` and `<algorithm>` library for `std::copy_backward`.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "018a8ee2-3c31-3d45-b99e-f219e8cc4f4f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, the source pointer may be null, which would also cause undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function call is not protected by any length or capacity checks. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(sub_x + i * sub_d, x + ofs + i * d, sub_d * sizeof(sub_x));\n```\n\nThis ensures that the copy operation works correctly even if the source and destination regions overlap. Additionally, consider adding checks to ensure that the source pointer is not null before performing the copy operation to avoid null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "fa6777c6-3a7b-3661-b932-8ef4d4b1aeac",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are both addresses of variables, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, the source may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. Replace the original call with:\n\n```cpp\nmemmove(&norm2, &norm_i, 4);\n```\n\nThis ensures that the copy operation is performed safely, even if the source and destination overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4f1fd3bf-2b1f-3163-b6a9-a44a10046044",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the code uses a memory copy operation where the source and destination may overlap, which can result in undefined behavior. The analysis detected that the source and destination may refer to overlapping memory regions due to data flow between them. Additionally, there is a risk that the source pointer could be null at this point, as there is no prior check ensuring it is non-null. The destination is a pointer, and there is no evidence that the length argument is derived from the destination's capacity, nor is there a guard to prevent underflow or overflow. These factors indicate a real risk of undefined behavior, memory corruption, or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the regions overlap.\n\n```cpp\nmemmove(xi, c, sizeof(*xi) * d);\n```\n\nAdditionally, ensure that both the source (`c`) and destination (`xi`) pointers are not null before performing the operation:\n\n```cpp\nif (xi != nullptr && c != nullptr) {\n    memmove(xi, c, sizeof(*xi) * d);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "30394aae-25d1-396e-acb7-3a7ad1986dca",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no explicit check to ensure that the source pointer is not null, which could also lead to undefined behavior. The destination pointer is considered safe from being null, but the combination of possible overlap and a potentially null source makes this a high-confidence issue. The use of a calculated size for the copy operation does not mitigate the risk of undefined behavior if the memory regions overlap.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. Additionally, ensure that the source pointer is not null before performing the copy. For example:\n\n```cpp\nif (LUT != nullptr && ips != nullptr) {\n    memmove(ips, LUT, sizeof(*ips) * nc);\n}\n```\nThis change ensures that the copy is safe even if the source and destination regions overlap, and also guards against null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a2c11e15-4514-3a7c-be79-bcb17aa257ff",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions that do not support overlapping regions. There are no indications that the source or destination pointers are null at this point, and the destination is likely a local or field array. The count argument is not directly derived from the destination's capacity, and there are no explicit guards or null-termination after the copy. The use of a raw memory copy function in this context, with potential overlap, is a well-known source of subtle and dangerous bugs.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, `memmove` is designed for this purpose. Change the code to use `memmove` instead of `memcpy`:\n\n```cpp\nmemmove(xi, c, sizeof(*x) * d);\n```\n\nThis ensures that the copy operation is performed correctly even if the source and destination regions overlap, eliminating the risk of undefined behavior.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b168ac0e-b0a7-3d56-8ff8-764ce3c43096",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior when using memory copy operations like memcpy. Additionally, there is no evidence of a guard to prevent null pointers for the source, further increasing the risk. The destination is a pointer type with no known capacity, and the count expression is not directly tied to the destination's size, which increases the likelihood of a real issue. The verdict is marked as genuine, and the risk is further supported by the absence of mitigating factors such as overlap prevention or null pointer checks.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the memory areas overlap.\n\n```cpp\nmemmove(xi, c, sizeof(*x) * d);\n```\n\nAdditionally, ensure that both `xi` and `c` are not null before performing the operation:\n\n```cpp\nif (xi != nullptr && c != nullptr) {\n    memmove(xi, c, sizeof(*x) * d);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1836240b-80c0-30c9-ad4f-58fbb19d69a3",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as genuine, and the classification specifically highlights undefined behavior risk. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions. Additionally, the source may be null at this point, which further increases the risk of undefined behavior. There are no explicit guards or checks to prevent these issues, and the destination is not confirmed to be a safe, non-overlapping region. These factors indicate a real risk that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. This ensures that the copy operation works correctly even if the source and destination overlap.\n\n```cpp\n// Replace memcpy with memmove for overlapping regions\nmemmove(&inorm, &norm, 4);\n```\n\nIf you are certain that the source and destination do not overlap, document this assumption clearly in the code. Otherwise, always prefer `memmove` for safety.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "67227c77-9f64-32d0-8505-d3f16f997747",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the operation copies memory from one location to another using a standard memory copy function, but there is a risk that the source and destination memory regions may overlap. This can result in undefined behavior, which is a serious correctness and security issue in C/C++ programs. The analysis detected that the source and destination may overlap due to data flow between them. Additionally, there is a risk that the source pointer may be null at this point in the code, as there is no prior check ensuring it is valid. The destination is less likely to be null, but the overlap and null source risks make this a high-confidence, actionable issue. No explicit bounds or capacity checks are present, and the count argument is not derived from the destination's capacity, further increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, use a memory move function that is safe for overlapping regions. Replace the memory copy function with a memory move function, which handles overlapping memory correctly. For example:\n\n```cpp\nmemmove(x, bytes, sizeof(float) * d * n);\n```\n\nBefore performing the copy, also ensure that the source pointer is not null to avoid dereferencing a null pointer:\n\n```cpp\nif (bytes != nullptr) {\n    memmove(x, bytes, sizeof(float) * d * n);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a3158f47-333d-37fb-9664-b492fd9ec4e4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null at this point in the code, since there is no prior check ensuring it is non-null. The destination is a pointer type, and there is no evidence that the size of the copy is bounded by the actual capacity of the destination buffer. These factors together indicate a real risk of undefined behavior, which can lead to security vulnerabilities or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (x != nullptr && bytes != nullptr) {\n    memmove(bytes, x, sizeof(float) * d * n);\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination overlap, and it also guards against null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7b1488f8-4a99-356b-9729-ad6a88078f11",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the destination and source may overlap based on data flow, which can cause undefined behavior with functions like memcpy. Additionally, the source pointer may be null at this call site, which further increases the risk. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly defined. These factors together make this a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory regions safely. Replace the original call with:\n\n```cpp\nmemmove(recons, &(codes[key * code_size]), code_size);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. You can add checks like:\n\n```cpp\nif (recons != nullptr && codes != nullptr) {\n    memmove(recons, &(codes[key * code_size]), code_size);\n}\n```\n\nThis change will eliminate the risk of undefined behavior due to overlapping memory regions and null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5f984b00-e9dd-388f-b5fe-40f9fe14d1c5",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from the same base object, and dataflow analysis confirms that overlap is feasible. Additionally, there is no explicit check to ensure that the source and destination do not overlap, and the source pointer may be null at this point, which further increases the risk. The operation uses a raw memory copy function, which is not safe when overlapping regions are possible, as it can lead to unpredictable results or data corruption. The absence of a guard or capacity check, and the fact that the count is not derived from a known safe bound, further contribute to the risk. Therefore, this is a high-confidence, actionable issue that should be addressed to prevent undefined behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of the standard memory copy function with a function that is safe for overlapping regions. In C and C++, `memmove` is designed for this purpose. Replace the original call with `memmove` to ensure correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(centroids + perm[i] * dsub, centroids_copy.data() + i * dsub, dsub * sizeof(centroids[0]));\n```\n\nThis change ensures that the memory copy operation is safe regardless of whether the source and destination regions overlap, eliminating the risk of undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e28b967e-a65a-3db9-ab26-e014990fba94",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a program uses insecure or deprecated C library functions. In this case, the `fopen` function is used, which can lead to various security risks such as buffer overflows or format string vulnerabilities. \n\nThe `fopen` function is used to open a file, but it does not perform any checks on the validity of the filename. This can lead to vulnerabilities if the filename is in any way influenced by user input, as it could lead to opening of unintended files or even execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen`. In C++, the `fstream` library provides the `ofstream` and `ifstream` classes which can be used to open files for writing and reading respectively. These classes provide more robust error checking and are less prone to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ofstream` class from the `fstream` library. The fixed code would look like this:\n\n```cpp\n#include <fstream>\n\nstd::ofstream optim_logfile(fname);\nif (!optim_logfile) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstdio` for the `fopen` function\n\nThe fixed code requires the following library:\n\n- `fstream` for the `ofstream` class\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "021f3c2c-16c9-3c36-adda-160d4c1eb053",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from potentially related data structures, and dataflow analysis suggests that the destination may overlap with the source. Additionally, there are no explicit checks to ensure that the source and destination pointers are non-null, which increases the risk of null pointer dereference. The absence of bounds checks or guards further increases the likelihood of a real issue. The classification specifically highlights undefined behavior due to overlapping memory regions, which is a well-known risk with memory copy operations such as memcpy.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that both the source and destination pointers are not null before performing the copy operation. For example:\n\n```cpp\nif (gt_distances.data() != nullptr && pq.sdc_table.data() != nullptr) {\n    memmove(gt_distances.data(), pq.sdc_table.data() + m * nq * nb, sizeof(float) * nq * nb);\n}\n```\n\nThis change ensures that the copy operation is safe even if the memory regions overlap, and it avoids null pointer dereference. Always validate the size and bounds of the buffers to prevent buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6f66c3aa-50ec-3d84-9e94-00c1e4cb4790",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination pointers may refer to overlapping memory areas, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there is no evidence of checks to ensure that the source and destination are non-overlapping, and both pointers may potentially be null, increasing the risk of undefined behavior or crashes. The absence of explicit bounds checks or null pointer guards further supports the assessment that this is a real issue requiring remediation.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation works correctly even if the source and destination regions overlap.\n\n```cpp\n// Replace memcpy with memmove to safely handle overlapping regions\nmemmove(xtrain.data() + i * dsub, x + i * pq.d + m * dsub, sizeof(float) * dsub);\n```\n\nAdditionally, consider adding explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation:\n\n```cpp\nfloat* dst = xtrain.data() + i * dsub;\nfloat* src = x + i * pq.d + m * dsub;\nif (dst != nullptr && src != nullptr) {\n    memmove(dst, src, sizeof(float) * dsub);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "92936ba7-557c-3fa7-acd2-7fd793592b88",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from related data structures, and dataflow analysis indicates that the destination may overlap with the source. Additionally, there is no explicit check or guard to prevent this overlap. The source pointer may also be null at this point, as there is no prior check ensuring it is valid. The destination is likely a local or field array, reducing the risk of it being null, but this does not mitigate the overlap risk. The use of a raw memory copy function without overlap protection in this context can lead to unpredictable program behavior, data corruption, or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, `memmove` is designed for this purpose. Change the code to use `memmove` instead of `memcpy` to ensure correct behavior even if the regions overlap.\n\n```cpp\nmemmove(centroids + perm[i] * dsub, centroids_copy.data() + i * dsub, dsub * sizeof(centroids[0]));\n```\n\nThis change ensures that the memory is copied correctly, even if the source and destination overlap, eliminating the risk of undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a27a49a3-24ca-3339-b76d-940a9c0aff8f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a program uses insecure or deprecated C library functions. In this case, the `fopen` function is used, which can lead to various security risks such as buffer overflows or format string vulnerabilities. \n\nThe `fopen` function is used to open a file, but it does not perform any checks on the validity of the filename. This can lead to vulnerabilities if the filename is in any way influenced by user input, as it could lead to opening of unintended files or even execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen`. In C++, the `fstream` library provides the `ofstream` and `ifstream` classes which can be used to open files for writing and reading respectively. These classes provide more robust error checking and are less prone to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with the `ofstream` class from the `fstream` library. The fixed code would look like this:\n\n```cpp\n#include <fstream>\n\nstd::ofstream optim_logfile(fname);\nif (!optim_logfile) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `cstdio` for the `fopen` function\n\nThe fixed code requires the following library:\n\n- `fstream` for the `ofstream` class\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "aa176703-4dad-37ad-a8ae-7052aed91d0f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no explicit check to ensure that the source pointer is not null, which could also lead to undefined behavior. The destination buffer is a pointer type, and there is no evidence that its size is being checked or that it is derived from a fixed-size array. The absence of a guard for the source pointer and the potential for overlapping memory regions make this a high-confidence, actionable issue that should be addressed to prevent unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid dereferencing a null pointer.\n\n```cpp\nif (best_perm != nullptr && perm.data() != nullptr) {\n    memmove(best_perm, perm.data(), sizeof(perm[0]) * n);\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination overlap, and it also guards against null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7807379b-00b5-3856-8435-1e62bae444f3",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as 'UB Risk: possible src/dst overlap (strncpy undefined behavior)' and the verdict is 'GENUINE'. The code copies memory from one buffer to another using a memory copy function, but there is a risk that the source and destination memory regions may overlap. This can lead to undefined behavior, which is a serious correctness and security issue. The analysis also indicates that both the source and destination pointers may be null at this point, and there are no guards in place to prevent this. Additionally, dataflow analysis has determined that overlap between source and destination is feasible. All these factors confirm the presence of a real risk of undefined behavior due to overlapping memory regions and possible null pointer dereference.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a memory move function that is safe for overlapping regions. Before performing the copy, ensure that both the source and destination pointers are not null. For example:\n\n```cpp\nif (codes.data() && other->codes.data()) {\n    memmove(codes.data() + (ntotal * code_size), other->codes.data(), other->ntotal * code_size);\n}\n```\nThis change replaces the memory copy function with a memory move function, which is designed to handle overlapping memory regions safely. Additionally, the null pointer checks prevent dereferencing null pointers, which would otherwise cause a crash or undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "decbf71b-43e0-362f-a1ef-5c876e8df23d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string, or integer overflow vulnerabilities. In this case, the `memmove` function is used, which can lead to buffer overflow if not used carefully.\n\nBuffer overflow vulnerabilities occur when the volume of data exceeds the storage capacity of the memory buffer. As a result, the program attempting to write the data to the buffer overflows the buffer's boundary and overwrites adjacent memory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `memmove`, consider using `memcpy_s` or `memmove_s` which are safer as they include the size of the destination buffer as a parameter, helping to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `memmove_s`:\n\n```cpp\n#include <string.h> // for memmove_s\n\nerrno_t err = memmove_s(&codes[code_size * j], sizeof(codes) - code_size * j, &codes[code_size * i], code_size);\nif (err)\n{\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `<string.h>` library for the `memmove` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6421bb04-abd0-3cb4-af94-dbf5cb46b341",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. This can lead to unpredictable program behavior, data corruption, or crashes. Additionally, there is no evidence of a guard to prevent null pointers for the source, which further increases the risk. The use of a raw memory copy function without explicit overlap checks or guarantees makes this a high-confidence issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with a function that safely handles overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. For example, change the code to:\n\n```cpp\nmemmove(x, xt, sizeof(xt[0]) * n * d_in);\n```\n\nThis ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b9437365-b71d-3619-85cd-9755c3d6e132",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard to prevent null pointers for the source, which increases the risk of undefined behavior. The function used for copying does not handle overlapping memory regions safely, and the absence of explicit checks or safeguards further supports the assessment that this is a real issue that could lead to unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. For example, change the code to:\n\n```cpp\nmemmove(xt, x, sizeof(x[0]) * n * d_in);\n```\n\nThis ensures that the copy operation will not result in undefined behavior even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d7ed3af0-f9f8-3a38-80fb-0bbcd1144b49",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be risky due to their potential to cause buffer overflow, format string vulnerabilities, or other issues. These functions often do not perform bounds checking or input validation, which can lead to serious security vulnerabilities if not handled properly. In this case, the `memmove` function is used, which can lead to buffer overflow if the size of the destination buffer is smaller than the size of the source buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these risky C functions. For instance, instead of using `memmove`, you can use `std::copy` or `std::copy_n` from the `<algorithm>` library in C++, which are safer as they work with iterators rather than raw pointers.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `std::copy_n`:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy_n(&A[i * d], d_in, &A[i * d_in]);\n```\n\n## Library Dependencies\n\nThe code example requires the `<algorithm>` library for `std::copy_n`.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest and most reliable resources for secure coding practices."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "853e9c18-a99f-30e2-96db-c506dfa67d79",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The classification explicitly states there is a risk of undefined behavior if the source and destination overlap, and the verdict confirms this is a genuine issue. The analysis determined that overlap is feasible based on data flow between the source and destination, which can cause memcpy to behave unpredictably. There are no indications that the source or destination pointers are null at this point, and there are no explicit guards or mitigations present. This type of issue can lead to data corruption or crashes at runtime.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. This change ensures that the copy operation will not result in data corruption or unpredictable behavior if the regions overlap.\n\n**Remediation example:**\n\n```cpp\nmemmove(rotation.data(), init_rotation.data(), d * d * sizeof(rotation[0]));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "26bda864-deb0-3fe7-9bbb-413c237fc3d1",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1ec83b91-c85f-3c39-98bb-7bb2af23d59f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2a911b2a-91cc-3b8f-8da6-c0c27c8e93c2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from potentially overlapping regions of arrays, as indicated by the dataflow analysis. Additionally, the source pointer may be null, which could also lead to undefined behavior. There are no explicit checks or guards in the code to prevent these issues. The classification and verdict both indicate a high-confidence, actionable issue that should be addressed to prevent memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(&A[row_dst * d_in], &Ain[i * d_in], d_in * sizeof(A[0]));\n```\n\nAdditionally, ensure that both source and destination pointers are valid and not null before performing the operation. If the source or destination can be null, add explicit checks to avoid dereferencing null pointers.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e4df549a-bf42-3887-896e-5420643a1965",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as 'GENUINE', and the classification explicitly states there is a risk of undefined behavior. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null, which further increases the risk. The destination is not likely to be null, but the main concern is the potential for overlapping memory regions, which is not handled by memcpy and can lead to data corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of memcpy with memmove, which is designed to handle overlapping regions safely. For example:\n\n```cpp\nmemmove(distances + i * k, beam_distances.data() + beam_size * i, k * sizeof(distances[0]));\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap, preventing data corruption or crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "df80cc9b-5f10-3deb-936a-92fb84377c33",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no evidence of a guard or check to prevent this overlap. The source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The use of a raw memory copy function without overlap protection in this context is unsafe and can result in unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(lut, norm_lut, norm_dim12 * sizeof(*lut));\n```\n\nThis ensures that even if the source and destination regions overlap, the copy will be performed correctly without causing undefined behavior. Additionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy to avoid potential crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "53eec251-26af-3b31-a2e9-c9dcbec57443",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination pointers may overlap based on data flow analysis, which can lead to unpredictable results when using memory copy functions that do not support overlapping regions. Additionally, there is a risk that either the source or destination pointer could be null at this point in the code, as there are no clear checks or guards to prevent this. The count argument used for the copy operation is not directly tied to the capacity of the destination buffer, increasing the risk of buffer overflows or memory corruption. These factors together indicate a high-confidence, actionable issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions. In C and C++, `memmove` is designed for this purpose. Replace the original memory copy call with `memmove` to ensure correct behavior even if the regions overlap.\n\n```cpp\nmemmove(tmp2.get() + i * cs2, bytes + i * (cs1 + cs2), cs2);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. Add appropriate checks if necessary to avoid null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "758a599d-efc8-3474-9a29-7fa5b4bdb1bf",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from related pointers, and dataflow analysis indicates that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The classification specifically highlights the undefined behavior risk, and the verdict confirms this is a genuine issue. Developers should ensure that the source and destination buffers do not overlap when using memory copy functions like memcpy, as this is not allowed by the C/C++ standard and can result in unpredictable program behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination buffers do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(b + cs1, tmp2.get() + cs2 * i, cs2);\n```\n\nAdditionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy operation:\n\n```cpp\nif (tmp2.get() != nullptr) {\n    memmove(b + cs1, tmp2.get() + cs2 * i, cs2);\n}\n```\n\nThis approach eliminates the risk of undefined behavior due to overlapping memory and null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "12c3174d-dd03-3441-ad53-29954fe33f5f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memcpy. Additionally, there is a risk that the source pointer may be null at this point, as there is no prior check ensuring it is non-null. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence, actionable issue. No explicit length or capacity checks are present, and the count argument is not derived from the destination's capacity, further increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of memcpy with memmove, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(lut, ip_lut.data() + i * ip_dim12, ip_dim12 * sizeof(*lut));\n```\n\nThis ensures that even if the source and destination regions overlap, the copy will be performed correctly without causing undefined behavior. Additionally, consider adding checks to ensure that the source pointer is not null before performing the copy to avoid potential null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "388b1ae6-fc83-33d6-80a7-9c5729ee0295",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, there is a risk that the source pointer may be null at this point, as there is no prior check ensuring it is non-null. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence, actionable issue. No explicit buffer size or guard is present to mitigate these risks.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(b, tmp1.get() + cs1 * i, cs1);\n```\n\nAdditionally, ensure that the source pointer is not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (tmp1.get() != nullptr) {\n    memmove(b, tmp1.get() + cs1 * i, cs1);\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "537d19a5-2f2c-355f-afa6-a3db1a93df29",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with memcpy. Additionally, there is a risk that the source pointer may be null at this point, as there is no prior check ensuring it is valid. The destination is less likely to be null, but the main concern is the potential for overlapping memory regions, which is not handled by memcpy and can lead to data corruption or crashes. No explicit bounds or null-termination handling is present, and the count argument is not derived from a known safe capacity, further increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that safely handles overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. For the given code, change the function call as follows:\n\n```cpp\nmemmove(codes, best_codes.data(), sizeof(int32_t) * n * M);\n```\n\nThis change ensures that even if `codes` and `best_codes.data()` overlap, the data will be copied correctly without causing undefined behavior. Additionally, consider adding checks to ensure that the source pointer is not null before performing the copy to avoid null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5733ed89-3957-3ebd-8a12-dc6f11e3f2b9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from similar base pointers with index arithmetic, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there are no explicit checks or guards in the code to prevent null pointers for either the source or destination, which further increases the risk. The absence of a guard and the possibility of null pointers make this a high-confidence issue that could lead to unpredictable program behavior or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(best_codes.data() + i * M, codes + i * M, sizeof(int32_t) * M);\n```\n\nThis ensures that even if the source and destination regions overlap, the copy will be performed correctly without causing undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3aac61c9-2d55-3b10-9c32-a90c2a05fb7f",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may refer to overlapping memory through data flow analysis. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which further increases the risk of undefined behavior or crashes. The function used (`memcpy`) is not safe for overlapping memory regions, and the absence of explicit bounds or capacity checks for the destination buffer increases the risk of buffer overflows or memory corruption. These factors collectively indicate a high-confidence, actionable issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace `memcpy` with `memmove`, which is designed to handle overlapping memory safely. Additionally, ensure that both the source and destination pointers are not null before performing the copy operation. For example:\n\n```cpp\nif (biases.get() != nullptr && coarse_dis != nullptr) {\n    memmove(biases.get(), coarse_dis, sizeof(float) * n * nprobe);\n}\n```\nThis change ensures that the copy operation is safe even if the source and destination regions overlap, and it avoids dereferencing null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-416: Use After Free](https://cwe.mitre.org/data/definitions/416.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "457753e3-3a9a-35f4-88ae-6b17fa8d6672",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the `memmove` function is used, which can lead to buffer overflow if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions whenever possible. For instance, instead of `memmove`, consider using `std::copy` from the C++ Standard Library, which is type-safe and less prone to errors.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy`. Here is how you can do it:\n\n```cpp\n#include <algorithm> // for std::copy\n\n// ...\n\nstd::copy(codes + i * code_size, codes + i * code_size + code_size, code + coarse_size);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memmove`\n- `<algorithm>` for `std::copy`\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "120f3087-779a-3e45-aee0-e8b072ffef29",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there are no checks ensuring that either pointer is non-null before the operation, which increases the risk of null pointer dereference. The use of a calculated size for the copy operation does not guarantee safety if the underlying buffers overlap or are not properly allocated. These factors make this a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointer is null before performing the copy operation.\n\nExample remediation:\n\n```cpp\nif (biases.get() != nullptr && coarse_dis != nullptr) {\n    // Use memmove if overlap is possible\n    memmove(biases.get(), coarse_dis, sizeof(float) * n * nprobe);\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly in the code and add assertions to enforce it at runtime:\n\n```cpp\nassert(biases.get() != nullptr && coarse_dis != nullptr);\nassert((char*)biases.get() + sizeof(float) * n * nprobe <= (char*)coarse_dis ||\n       (char*)coarse_dis + sizeof(float) * n * nprobe <= (char*)biases.get());\nmemcpy(biases.get(), coarse_dis, sizeof(float) * n * nprobe);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "22a7e8fc-ad2f-3065-99e4-8a93fd3b1e96",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there is no evidence of a guard or check to ensure that the source and destination do not overlap. The source pointer may also be null at this point, as there is no prior check to guarantee its validity. The destination is guarded as non-null, but this does not mitigate the overlap or null source risks. These factors make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid a potential null pointer dereference.\n\n**Remediation example:**\n\n```cpp\n// Ensure src and dst do not overlap, or use memmove if overlap is possible\nif (orig.precomputed_table.data() != precomputed_table.get()) {\n    // Optionally, add a null check for the source\n    if (orig.precomputed_table.data() != nullptr) {\n        memcpy(precomputed_table.get(), orig.precomputed_table.data(), precomputed_table.nbytes());\n    }\n} else {\n    // Use memmove if overlap is possible\n    if (orig.precomputed_table.data() != nullptr) {\n        memmove(precomputed_table.get(), orig.precomputed_table.data(), precomputed_table.nbytes());\n    }\n}\n```\n\n## References\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8ff0a4bd-2348-3885-ba75-821957064ecf",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The source and destination are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. Additionally, there is no explicit check or guard in the code to prevent this overlap. The source pointer may also be null, which could lead to a crash or further undefined behavior. The destination is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. The classification and verdict both indicate a genuine risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the source and destination overlap.\n\n```cpp\nmemmove(xdest, xsrc, dsub * sizeof(xdest[0]));\n```\n\nAdditionally, ensure that both `xdest` and `xsrc` are not null before performing the operation:\n\n```cpp\nif (xdest != nullptr && xsrc != nullptr) {\n    memmove(xdest, xsrc, dsub * sizeof(xdest[0]));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "52613f04-ff2b-3e97-8c27-2429f8f1bc0c",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may overlap based on data flow, which can cause undefined behavior with functions like memcpy. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null at this point, further increasing the risk. The destination is a pointer, and there is no information about its capacity or bounds checking. These factors together make this a high-confidence, actionable issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. Additionally, ensure that the source pointer is not null before performing the copy to avoid a potential null pointer dereference.\n\n```cpp\nif (pq.get_centroids(m, n) != nullptr) {\n    memmove(recons, pq.get_centroids(m, n), sizeof(recons[0]) * pq.dsub);\n}\n```\n\nThis change ensures that the copy operation is safe even if the memory regions overlap, and it guards against null pointer dereference. For further information, see the following references.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "010d6744-47f0-30de-ba0c-04085965e944",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `memmove` function is used, which can lead to buffer overflow if not used properly. Buffer overflow can allow an attacker to execute arbitrary code, cause a system crash, or lead to information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of using `memmove`, consider using `std::copy` from the C++ Standard Library, which is type-safe and exception-safe.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy`:\n\n```cpp\n#include <algorithm>\n\nstd::copy(bytes + i * code_size_2, bytes + i * code_size_2 + code_size_2, code + code_size_1);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<algorithm>`: for `std::copy`\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices Guide](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "059270fa-9b64-3407-b56b-952b5e663460",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is a risk that the source pointer could be null at this point, as there is no prior check ensuring it is non-null. The destination is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. The classification and verdict both indicate a genuine problem that could lead to unpredictable program behavior or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original call with `memmove`:\n\n```cpp\nmemmove(&key01, code, storage.code_size_1);\n```\n\nAdditionally, ensure that the source pointer (`code`) is not null before performing the copy to avoid a potential null pointer dereference:\n\n```cpp\nif (code != nullptr) {\n    memmove(&key01, code, storage.code_size_1);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "808724ab-1297-35af-9187-c4ecf3919b72",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null at runtime, since there is no prior check ensuring it is non-null. The destination is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. The operation does not use a standard size or capacity check for the destination, and there are no explicit guards or null-termination after the copy. These factors all contribute to the assessment that this is a genuine vulnerability with a very low probability of being a false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping source and destination regions. Additionally, ensure that the source pointer is not null before performing the copy to avoid a potential null pointer dereference.\n\n```cpp\nif (code != nullptr) {\n    memmove(&key, code, storage.code_size_1);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6311d02f-f675-3e1b-938e-5d04ecb5d556",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is a risk that the source pointer could be null at this point in the code, since there is no prior check ensuring it is non-null. The destination is not likely to be null, as it appears to be a local or field array. The count argument used for the copy is not derived from the destination's capacity, and there is no explicit guard or null-termination after the copy. These factors all increase the likelihood of a real issue, and the classification and verdict both indicate a high-confidence, actionable problem.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid a null pointer dereference.\n\n**Remediation example:**\n\n```cpp\nif (rp != nullptr) {\n    memmove(&key, rp, code_size_1);\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination overlap, and it also guards against a null source pointer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "982cc8d3-1c6a-3a54-b13d-ec428abcb61f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected, through data flow, that the destination and source may reference overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there are no checks ensuring that the source and destination pointers are non-null, further increasing the risk. No explicit buffer size or bounds checks are present, and the count argument is not derived from the destination's capacity. These factors all contribute to the high confidence in this being a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of memcpy with memmove, which is designed to handle overlapping source and destination regions safely. Additionally, ensure that both source and destination pointers are valid and not null before performing the operation. For example:\n\n```cpp\nif (list_codes.data() && flat_codes.data()) {\n    memmove(list_codes.data() + (i - i0) * code_size,\n            flat_codes.data() + order[i] * code_size,\n            code_size);\n}\n```\nThis change ensures that the copy operation is safe even if the source and destination regions overlap, and it guards against null pointer dereference.\n\n## References\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "04dd7141-420f-30a5-92eb-a0da6be48a16",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `memmove`, you can use `std::copy` or `std::copy_backward` from `<algorithm>` which are safer and less prone to errors.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy_backward`:\n\n```cpp\n#include <algorithm>\n\nstd::copy_backward(&addr[right], &addr[right] + (size - right), &addr[right + 1] + (size - right));\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memmove`\n- `<algorithm>` for `std::copy_backward`\n\n## OWASP Resources\n\n- [OWASP Proactive Controls](https://owasp.org/www-project-proactive-controls/)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "89b28d0d-efda-3074-87b0-7f58c40385e3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, integer overflow, etc. These functions are often prohibited in secure coding standards. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `memmove`, you can use `std::copy` or `std::copy_backward` from the `<algorithm>` library in C++, which are safer as they work with C++ containers and iterators.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `std::copy_backward`:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy_backward(&addr[left], &addr[left + size], &addr[left + size + 1]);\n```\n\n## Library Dependencies\n\nThe original code requires the `<cstring>` library for `memmove`. The fixed code requires the `<algorithm>` library for `std::copy_backward`.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "47cb8447-c292-3ec5-a85e-7cfe201aeec2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions. Additionally, the source pointer may be null at this location, which further increases the risk of runtime errors. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly defined, increasing the risk of buffer overflows or memory corruption. Developers should ensure that the source and destination do not overlap and that both pointers are valid before performing the memory copy.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use a function that is safe for overlapping regions, such as `memmove`, instead of `memcpy`. Additionally, validate that both source and destination pointers are not null before performing the operation.\n\n**Remediation example:**\n\n```cpp\nif (recons != nullptr && &(xb[code_size * key]) != nullptr) {\n    // Use memmove if overlap is possible\n    memmove(recons, &(xb[code_size * key]), sizeof(*recons) * code_size);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "82f506bb-aa8b-3466-8223-1139c2f7b2f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Found\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflow, memory corruption, or other types of undefined behavior. In this case, the `memmove` function is used, which can lead to such issues if not used carefully.\n\nThe `memmove` function copies n bytes from memory area src to memory area dest. The memory areas may overlap: copying takes place as though the bytes in src are first copied into a temporary array that does not overlap src or dest, and the bytes are then copied from the temporary array to dest.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `memmove` whenever possible. In C++, this could be achieved by using the `std::copy` or `std::copy_n` functions from the `<algorithm>` library, which are type-safe and less prone to buffer overflow issues.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix using `std::copy`:\n\n```cpp\n#include <algorithm>\n\nstd::copy(knng.data() + i * (GK + 1) + 1,\n          knng.data() + i * (GK + 1) + 1 + GK,\n          knng.data() + i * GK);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<algorithm>`: For the `std::copy` function.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b77ab18d-ead1-36e2-a6d0-92e44f83740a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be risky and can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `memmove` function is used, which can lead to buffer overflow if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these risky C functions. For instance, instead of using `memmove`, you can use `std::copy` or `std::copy_backward` from the `<algorithm>` library in C++, which are safer as they work with C++ containers and iterators.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `std::copy`:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy(&xb[code_size * i], &xb[code_size * i] + code_size, &xb[code_size * j]);\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library provides the `memmove` function.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a27bda8f-4d08-362d-bfd9-9e794fa5e00d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the operation copies memory from one region to another using a function that is not safe when the source and destination regions overlap. The analysis detected that the source and destination memory regions may overlap due to data flow between them, which can result in undefined behavior according to the C standard for memory copy operations. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null, which further increases the risk of undefined behavior or a crash. The destination is likely a local or field array, reducing the risk of it being null, but this does not mitigate the overlap issue. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, `memmove` is designed for this purpose. Change the function call to use `memmove` instead of `memcpy`:\n\n```cpp\nmemmove(dis1 + j0, dis2.data() + j0, sizeof(dis2[0]) * (k - j0));\n```\n\nThis ensures that the copy operation is performed correctly even if the source and destination regions overlap, eliminating the risk of undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "00143001-9998-3f9f-827e-a58dd8462c1a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from potentially overlapping data, as indicated by the dataflow analysis. Additionally, there is no explicit check to ensure that the source and destination do not overlap, and the source pointer may be null at this point in the code, which further increases the risk. The use of a raw memory copy function without overlap protection (such as memcpy) in this context can lead to unpredictable behavior, data corruption, or crashes if the regions overlap. The absence of a guard or explicit null check for the source, and the fact that the destination is not a pointer-based member, reinforce the risk assessment.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping source and destination regions safely. For example, change the code to:\n\n```cpp\nmemmove(labels1 + j0, labels2.data() + j0, sizeof(labels1[0]) * (k - j0));\n```\n\nThis ensures that the copy operation is safe even if the source and destination memory regions overlap. Additionally, consider adding explicit null checks for the source pointer before performing the copy to avoid potential null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f9eeecd7-48eb-361d-aee1-4b846010b38b",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination is a pointer to float, and the source is obtained from a function call, with dataflow analysis indicating that the source and destination may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null, which further increases the risk of undefined behavior. The verdict is supported by the classification and the explicit 'GENUINE' verdict from the analysis. These factors indicate a real risk of memory corruption or program crashes if the overlap or null pointer dereference occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n**Remediation example:**\n\n```cpp\nif (recons != nullptr && invlists->get_single_code(list_no, offset) != nullptr) {\n    memmove(recons, invlists->get_single_code(list_no, offset), code_size);\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds null pointer checks for both the destination and source. This ensures safe copying even if the memory regions overlap and prevents undefined behavior due to null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ecd6c576-3252-3c23-8f2d-70e18c31f1b1",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from similar base pointers with calculated offsets, and dataflow analysis suggests that overlap is feasible. Additionally, the source pointer may be null at this call site, which further increases the risk. There are no explicit checks or guards in the code to prevent these issues, and the function used does not handle overlapping memory regions safely. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` correctly handles overlapping memory areas. For example, change the code to:\n\n```cpp\nmemmove(x2.get() + n2 * d, x + i * d, code_size);\n```\n\nThis ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "db72fe5c-a832-38b8-9a43-4bc28c642a24",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The source and destination may overlap, as indicated by the dataflow analysis, which can cause unpredictable results with standard memory copy functions. Additionally, the source pointer may be null, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly defined, increasing the risk of buffer overflows or memory corruption.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. Replace the original memory copy operation with:\n\n```cpp\nmemmove(xi, code + coarse_size, code_size);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination memory regions overlap, preventing unpredictable results or data corruption.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1a28c168-5e34-33a0-ab90-5e5fcc87c31c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for the standard memory copy function and can result in unpredictable program behavior. Additionally, there is no evidence of a guard to prevent the source from being null, which further increases the risk. The destination is likely a local or field array, reducing the risk of it being null, but the overlap and null source risks are both present. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, use a memory move function that is designed to handle overlapping regions. Replace the memory copy function with a memory move function, which safely handles overlap:\n\n```cpp\nmemmove(code + coarse_size, xi, code_size);\n```\n\nThis change ensures that the operation is well-defined even if the source and destination memory regions overlap. Additionally, consider adding explicit checks to ensure that the source pointer is not null before performing the operation to avoid null pointer dereference issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "50e667da-aea3-321a-82ab-511f5c099dce",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The dataflow analysis indicates that the destination buffer may be derived from the source, which can lead to overlapping memory regions. Additionally, there is no evidence of a guard or check to prevent this overlap. The source pointer may also be null at this point, as there is no prior check ensuring it is valid. The destination buffer is likely a local or field array, reducing the risk of it being null, but this does not mitigate the overlap risk. The use of a raw memory copy function without overlap protection in this context is dangerous and can result in unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions. In C and C++, `memmove` is designed for this purpose. Replace the original memory copy call with `memmove`:\n\n```cpp\nmemmove(codes, x, code_size * n);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap. Additionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy to avoid null pointer dereference issues.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3fe1bef2-9c7b-395b-84b4-9b822b48894d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"quantizer_\")` is used to determine the length of a constant string. This is not a vulnerability per se, but it's a bad practice because the length of a constant string can be determined at compile time, making the use of `strlen` unnecessary and inefficient.\n\n## Mitigation Advice\n\nAvoid using `strlen` to determine the length of constant strings. Instead, use the `sizeof` operator, which can determine the length at compile time, or simply hard-code the length if it's known.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(\"quantizer_\")` with `sizeof(\"quantizer_\") - 1` or `10` (the actual length of the string \"quantizer_\").\n\n```cpp\nsub_name = name.substr(sizeof(\"quantizer_\") - 1);\n```\n\nor\n\n```cpp\nsub_name = name.substr(10);\n```\n\n## Library Dependencies\n\nThe code snippet requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "b68dfac8-504e-30c8-a6bf-804008e22e38",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"quantizer_\")` is used to determine the length of a constant string. This is not a vulnerability per se, but it's a bad practice because the length of a constant string can be determined at compile time, making the use of `strlen` unnecessary and inefficient.\n\n## Mitigation Advice\n\nAvoid using `strlen` to determine the length of constant strings. Instead, use the `sizeof` operator, which can determine the length at compile time, or simply hard-code the length if it's known.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(\"quantizer_\")` with `sizeof(\"quantizer_\") - 1` or `10` (the actual length of the string \"quantizer_\").\n\n```cpp\nsub_name = name.substr(sizeof(\"quantizer_\") - 1);\n```\n\nor\n\n```cpp\nsub_name = name.substr(10);\n```\n\n## Library Dependencies\n\nThe code snippet requires the following library:\n\n- `<string>`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "7e5e844a-37e5-3172-958c-ab9d50f7c36a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `fopen` is used, which can lead to vulnerabilities if the `fname` parameter is not properly validated or sanitized. An attacker could potentially manipulate the `fname` to overwrite files or to access sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation and sanitization. In the case of `fopen`, it is important to ensure that the `fname` parameter is a valid and safe file name. This can be done by checking that the file name does not contain any special characters or sequences that could be used to traverse directories, such as \"../\".\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::string fname = \"filename.txt\";\nstd::ofstream f(fname);\nif (!f) {\n    // Handle error\n}\n```\n\nIn this fixed code, the C++ `ofstream` class is used instead of `fopen`. This class automatically handles many of the potential issues with `fopen`, making it a safer alternative.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n* `<fstream>`\n\n## References\n\n* [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n* [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "44c1fe05-e811-32ae-a18a-295bd46cb975",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `fopen` is used, which can lead to vulnerabilities if the `fname` parameter is not properly validated or sanitized. An attacker could potentially manipulate the `fname` to overwrite files or to access sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation and sanitization. In the case of `fopen`, it is important to ensure that the `fname` parameter is a valid and safe file name. This can be done by checking that the file name does not contain any special characters or sequences that could be used to traverse directories, such as \"../\".\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::string fname = \"filename.txt\";\nstd::ofstream f(fname);\nif (!f) {\n    // Handle error\n}\n```\n\nIn this fixed code, the C++ `ofstream` class is used instead of `fopen`. This class automatically handles many of the potential issues with `fopen`, making it a safer alternative.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n* `<fstream>`\n\n## References\n\n* [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n* [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "23bbf271-a5c1-384a-a122-ab4cae62c798",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there are no checks ensuring that the source and destination pointers are non-null, which increases the risk of null pointer dereference. The copy size is calculated using a product of element size and two variables, but there is no evidence that the destination buffer is large enough to accommodate the copy, nor is there a guard to prevent buffer overflows. These factors together indicate a high-confidence, actionable issue that could lead to memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy. For example:\n\n```cpp\nif (gt_I_in != nullptr && gt_I.data() != nullptr) {\n    memmove(gt_I.data(), gt_I_in, sizeof(gt_I[0]) * nq * gt_nnn);\n}\n```\n\nThis change ensures safe copying even if the memory regions overlap and prevents null pointer dereference. For further information, see the following resources.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "07d44a22-be0d-3b9e-bba8-bd681389267a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. There are no indications that the source or destination pointers are null at the call site, and there are no explicit bounds or capacity checks to mitigate the risk. The absence of a guard and the lack of evidence that the length is derived from the destination's capacity further increase the risk. Therefore, this is a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```cpp\nmemmove(gt_D.data(), gt_D_in, sizeof(gt_D[0]) * nq * gt_nnn);\n```\n\nThis change ensures that the memory copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "94eec2ea-7cd8-3ba9-a1c7-32fdc0c7ee9d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of memory corruption. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `memmove`, you can use `std::copy` or `std::copy_backward` from the `<algorithm>` library in C++, which are safer as they work with C++ containers and iterators.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy_backward`:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy_backward(&addr[right], &addr[K], &addr[K + 1]);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memmove`\n- `<algorithm>` for `std::copy_backward`\n\n## OWASP and CWE Resources\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8ff697c7-556b-3e15-9f70-d7165241ec51",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Found\" vulnerability refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflow, format string, or integer overflow vulnerabilities. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\nBuffer overflow vulnerabilities occur when a program writes more data to a buffer than it can hold, causing the excess data to overflow into adjacent memory. This can lead to unpredictable program behavior, including memory access errors, incorrect results, a crash, or a breach of system security.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `memmove`, you can use `memcpy_s` or `memmove_s` which are safer as they include the size of the destination buffer as a parameter, helping to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the code:\n\n```cpp\n#include <string.h>\n#include <stdlib.h>\n\n// Assuming Neighbor is a defined structure\nstruct Neighbor {\n    // structure members\n};\n\n// Assuming K and left are defined and valid\nsize_t K = 10;\nsize_t left = 5;\n\n// Assuming addr is a defined and valid array of Neighbor\nNeighbor addr[15];\n\n// Fix: Use memmove_s instead of memmove\nerrno_t err = memmove_s(&addr[left + 1], (K - left - 1) * sizeof(Neighbor), &addr[left], K * sizeof(Neighbor));\nif (err) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string.h>` for `memmove`\n- `<stdlib.h>` for `errno_t` and error handling\n\n## OWASP and CWE Links\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "6f1d9a41-b6c8-34d2-a373-5878483b4e1b",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the destination and source may alias, as suggested by the assignment involving the same vector object. Additionally, there are no explicit checks ensuring that the source and destination do not overlap, and both may be null at this point in the code, which further increases the risk. The use of memcpy in this context is unsafe if the memory regions overlap, as memcpy does not guarantee correct behavior in such cases. The absence of explicit bounds checks or null pointer guards further supports the assessment that this is a real issue that could lead to memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. Additionally, ensure that both the source and destination pointers are not null before performing the copy operation. For example:\n\n```cpp\nif (centroids.data() && cpq.get_centroids(m, i)) {\n    memmove(centroids.data() + i * d + m * cpq.dsub, cpq.get_centroids(m, i), sizeof(*centroids.data()) * cpq.dsub);\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap, and it avoids dereferencing null pointers.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "09cd632e-33a4-3c25-87fd-832af6c8e13b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the `memmove` function is used, which can lead to buffer overflow if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions whenever possible. For instance, instead of `memmove`, consider using `std::copy` from the C++ Standard Library, which is type-safe and less prone to errors.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy`. Here is how you can do it:\n\n```cpp\n#include <algorithm> // for std::copy\n\n// ...\n\nstd::copy(codes + i * code_size, codes + i * code_size + code_size, code + coarse_size);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memmove`\n- `<algorithm>` for `std::copy`\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "aeca8cbe-7a71-3eb5-a36b-c90a749d7f6b",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, which could lead to a crash or further undefined behavior. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent potential memory corruption or program instability.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid potential crashes.\n\n```cpp\nif (block != nullptr && flat_codes != nullptr) {\n    memmove(flat_codes, block, code_size);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "58f4d292-5aa8-3e07-9472-356e50bff644",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results with functions like memcpy. Additionally, there is a risk that the source pointer may be null at this point, as there is no prior check ensuring it is valid. The destination is less likely to be null, but the main concern is the potential for overlapping memory regions, which is not handled by memcpy and can lead to data corruption or crashes. No explicit length or capacity checks are present, and the count argument is not derived from the destination's capacity, increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This function is designed to correctly copy memory even if the source and destination overlap.\n\n**Remediation Example:**\n\n```cpp\n// Replace memcpy with memmove to safely handle overlapping regions\nmemmove(block, flat_codes, code_size);\n```\n\nAdditionally, ensure that both `block` and `flat_codes` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (block != nullptr && flat_codes != nullptr) {\n    memmove(block, flat_codes, code_size);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "6c3d703f-bd48-3b5d-846a-2c1df6e4cb02",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ programming. These functions are often prone to buffer overflow attacks, which can lead to arbitrary code execution, denial of service, or information disclosure. In the provided code, the function `vsnprintf()` is used, which is generally considered safe. However, if not used properly, it can still lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the buffer size (`nbuf`) is large enough to accommodate the formatted string. Also, always check the return value of `vsnprintf()`. If it's equal to or larger than `nbuf`, it means the output was truncated and the buffer is likely too small.\n\n## Source Code Fix Recommendation\n\nHere is a safer way to use `vsnprintf()`:\n\n```cpp\n#include <stdarg.h>\n#include <stdio.h>\n\nvoid safe_vsnprintf(char *buf, size_t nbuf, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    int ret = vsnprintf(buf, nbuf, fmt, ap);\n    va_end(ap);\n\n    if (ret < 0 || (size_t)ret >= nbuf) {\n        // Handle error: output was truncated or an encoding error occurred\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<stdarg.h>`: for handling variable argument list functions (`va_start`, `va_end`)\n- `<stdio.h>`: for `vsnprintf()`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3b1bbd62-36aa-3a0a-8a2d-ca77a8683c35",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The code copies data from one buffer to another using a memory copy function, but dataflow analysis indicates that the source and destination may refer to overlapping memory regions. This can lead to unpredictable results or program crashes. Additionally, there are no checks to ensure that the source and destination pointers are not null, which could also result in undefined behavior. The absence of explicit bounds checks or guards further increases the risk. These factors make this a high-confidence, actionable issue that should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination regions may overlap, use a memory move function that safely handles overlapping regions. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the operation. For example:\n\n```cpp\nif (dst.data() != nullptr && src.data() != nullptr) {\n    std::memmove(dst.data() + insert_point, src.data(), src.size() * sizeof(T));\n}\n```\nThis change replaces the memory copy function with a memory move function, which is designed to handle overlapping memory regions safely. It also adds null pointer checks to avoid undefined behavior if either pointer is null.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f72f6d4c-bb38-3496-a8db-2b0f3a71dfc3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, integer overflow, etc. In this case, the `memmove()` function is used, which can lead to buffer overflow if not used correctly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives provided by the C++ Standard Library. These alternatives are designed to prevent buffer overflow and other common vulnerabilities. \n\n## Source Code Fix Recommendation\n\nReplace the `memmove()` function with a safer alternative. In this case, you can use the `std::copy()` function from the C++ Standard Library. Here is how you can modify the code:\n\n```cpp\n#include <algorithm> // for std::copy\n\nstd::copy(dst.data() + remove, dst.data() + dst.size(), dst.data());\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<algorithm>`: for `std::copy()`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4fc94590-ccbf-3da5-bcd0-3627e5a6a1c4",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means that under certain conditions, they may refer to overlapping memory areas. This can cause unpredictable program behavior, crashes, or data corruption. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null, which further increases the risk of undefined behavior. The verdict is supported by the classification and the high-confidence 'GENUINE' label from the analysis.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. `memmove` is specifically designed to handle overlapping source and destination memory areas without causing undefined behavior. \n\n**Remediation example:**\n\n```cpp\nmemmove(x + m * pq.dsub, pq.get_centroids(m, c), sizeof(float) * pq.dsub);\n```\n\nThis change ensures that even if the source and destination regions overlap, the copy will be performed safely.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1697bdaa-81e2-3606-8217-9dcee7c6a69d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from similar base pointers and index calculations, and dataflow analysis suggests that they may refer to overlapping memory. The verdict is marked as 'GENUINE', and the classification explicitly states a risk of undefined behavior. Additionally, the source pointer may be null at this call site, which further increases the risk. There are no explicit guards or checks to prevent overlap or null pointer dereference, and the count argument is not derived from a known safe capacity. These factors all indicate a high likelihood of a real issue that could lead to memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping source and destination regions safely. For example, change the code to:\n\n```cpp\nmemmove(xslice + (i - i0) * dsub, x + i * d + m * dsub, dsub * sizeof(float));\n```\n\nThis ensures that even if the source and destination memory regions overlap, the copy will be performed correctly without causing memory corruption or crashes.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c7ec45dd-3e5f-3145-abc9-3d1f90a92516",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is a possibility that either the source or destination pointer could be null, and there are no explicit checks or guards in place to prevent this. The operation does not use a count derived from the destination's capacity, and there is no evidence of a null-terminator being set after the copy. All these factors increase the likelihood of a real issue, such as a buffer overflow or undefined behavior, making this a high-confidence, actionable finding.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointer is null before performing the copy operation. For example:\n\n```cpp\nif (clus.centroids.data() != nullptr && get_centroids(m, 0) != nullptr) {\n    memmove(clus.centroids.data(), get_centroids(m, 0), dsub * ksub * sizeof(float));\n}\n```\n\nThis change ensures that the copy is safe even if the memory regions overlap and avoids dereferencing null pointers.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8ee942d6-d2af-381d-8f9c-678c505933f2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are computed from related base pointers and index calculations, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, the source may be null at this call site, which further increases the risk. There are no explicit checks or guards in the code to prevent this overlap or null pointer dereference. The classification and verdict both indicate a high-confidence issue that could lead to unpredictable program behavior, data corruption, or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. `memmove` is specifically designed to handle overlapping source and destination buffers, ensuring correct results even if the regions overlap.\n\n**Remediation example:**\n\n```cpp\n// Replace memcpy with memmove to safely handle possible overlap\nmemmove(xslice + j * dsub, x + j * d + m * dsub, dsub * sizeof(float));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. This can be done by adding explicit checks:\n\n```cpp\nif ((xslice != nullptr) && (x != nullptr)) {\n    memmove(xslice + j * dsub, x + j * d + m * dsub, dsub * sizeof(float));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "02131c1e-ade1-31ea-801f-1cd901c6fff2",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the observed alias assignment. Additionally, there is no evidence of a guard ensuring that the source pointer is non-null, which increases the risk of a null pointer dereference. The destination pointer is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. The use of a raw memory copy function without explicit checks or guarantees about the relationship between source and destination memory regions can lead to unpredictable program behavior, data corruption, or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with a function that safely handles overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory correctly. For example, change the code to:\n\n```cpp\nmemmove(invlist, list, list_size * sizeof(idx_t));\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (invlist != NULL && list != NULL) {\n    memmove(invlist, list, list_size * sizeof(idx_t));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f2668f77-7e12-3200-ac08-27afd13e71ea",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may refer to overlapping memory through data flow analysis. Additionally, there is a risk that the source pointer could be null at this point in the code, as there is no prior check ensuring it is non-null. The destination is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue. No explicit bounds or capacity checks are present, and the count argument is not derived from the destination's capacity, further increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```cpp\nmemmove(out_distances, distances_ptr, distances_size * sizeof(*distances_ptr));\n```\n\nAdditionally, ensure that `distances_ptr` is not null before performing the copy to avoid a possible null pointer dereference:\n\n```cpp\nif (distances_ptr != nullptr) {\n    memmove(out_distances, distances_ptr, distances_size * sizeof(*distances_ptr));\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0228618e-67ca-3c8c-9643-cfbd42b6b5dc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there is no evidence of a guard to ensure that the source pointer is non-null, which increases the risk of a null pointer dereference. The destination pointer is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence issue. The classification and verdict both indicate a genuine risk, and the absence of mitigating factors such as explicit bounds checks or overlap prevention further supports this assessment.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the source and destination overlap.\n\n```cpp\nmemmove(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr));\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the operation:\n\n```cpp\nif (out_codes != nullptr && codes_ptr != nullptr) {\n    memmove(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "aa1cab7a-5cd8-3292-9346-03252528663a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected, via data flow, that the destination buffer may overlap with the source buffer, which is not allowed for the memory copy function used here. Additionally, the source pointer may be null at this call site, which further increases the risk of undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer is a pointer type with no clear capacity information. These factors all contribute to the assessment that this is a genuine and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy` when there is any possibility that the source and destination regions overlap. This ensures correct behavior regardless of overlap.\n\n**Remediation example:**\n\n```cpp\nmemmove(new_codes_i, codes_i + js * m, sizeof(*codes) * m);\n```\n\nThis change ensures that the memory copy will work correctly even if the source and destination regions overlap, eliminating the risk of undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3213c710-6b62-300e-8aa2-9c9a98155fa3",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. This can lead to unpredictable results or program crashes, since the standard memory copy function does not guarantee correct behavior when source and destination overlap. Additionally, there is no evidence of a guard to prevent this situation, and the source pointer may also be null, which further increases the risk of undefined behavior. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with a memory move function, which is designed to handle overlapping regions safely. For example, change the code to use `memmove` instead of `memcpy`:\n\n```cpp\nmemmove(out_distances, pool.distances.data(), distances_size * sizeof(pool.distances[0]));\n```\n\nThis ensures that the copy operation is safe even if the source and destination regions overlap. Additionally, consider adding checks to ensure that the source pointer is not null before performing the operation to avoid null pointer dereference.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "037da8d4-ba58-3c16-8d0a-bdd979bceca8",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. This can cause undefined behavior with memcpy, which does not support overlapping regions. Additionally, there is no evidence of a guard to ensure the source pointer is non-null, further increasing the risk. The destination pointer is not likely to be null, but the source pointer may be. The absence of explicit bounds checks or overlap handling makes this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the memory areas overlap.\n\n```cpp\nmemmove(out_residuals, residuals_ptr, residuals_size * sizeof(*residuals_ptr));\n```\n\nAdditionally, consider adding explicit checks to ensure that the source pointer is not null before performing the copy:\n\n```cpp\nif (residuals_ptr != nullptr) {\n    memmove(out_residuals, residuals_ptr, residuals_size * sizeof(*residuals_ptr));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c09f8625-1aec-3f91-afc6-96755c3547fc",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null at this point, which could lead to a crash. The destination is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence issue. The classification and verdict both indicate a real risk, and the context does not provide any mitigating factors.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap when using `memcpy`. If overlap is possible, use `memmove` instead, which is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```cpp\nmemmove(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr));\n```\n\nBefore performing the copy, you should also check that the source pointer is not null to avoid a potential crash:\n\n```cpp\nif (codes_ptr != nullptr) {\n    memmove(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "689c600e-ae99-3a4e-a3e5-c898414bc490",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to the possibility that either the source or destination pointer in the memory copy operation may be null. There are no visible checks in the code to ensure that the source or destination pointers are valid before the memory copy is performed. The risk is further supported by the fact that the analysis could not determine any prior validation or guard that would guarantee the pointers are non-null. This can lead to crashes or other unpredictable behavior if a null pointer is dereferenced. The probability of this being a false positive is low, as both the source and destination pointers are potentially unguarded, and the classification and verdict both indicate a high-confidence issue.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that both the source and destination pointers are checked for null. This prevents undefined behavior if either pointer is invalid. For example:\n\n```cpp\nif (this->codebooks.data() != nullptr && codebooks.data() != nullptr) {\n    memcpy(this->codebooks.data() + codebook_offsets[m] * d, codebooks.data(), codebooks.size() * sizeof(codebooks[0]));\n} else {\n    // Handle error: one or both pointers are null\n}\n```\n\nAlternatively, if the logic guarantees that these pointers should never be null, add assertions to document and enforce this assumption:\n\n```cpp\nassert(this->codebooks.data() != nullptr);\nassert(codebooks.data() != nullptr);\nmemcpy(this->codebooks.data() + codebook_offsets[m] * d, codebooks.data(), codebooks.size() * sizeof(codebooks[0]));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7de317c0-460f-3b18-acca-8bda9c60e47e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected that neither the source nor the destination pointers are guaranteed to be non-null before the memory copy operation. The code copies memory from one buffer to another using a standard memory copy function, but there are no checks to ensure that either buffer is valid (not null) at the time of the operation. This can lead to undefined behavior, including potential crashes or security vulnerabilities, if either pointer is null. The risk is further increased because the analysis did not detect any explicit guard conditions or assignments that would guarantee the validity of these pointers. The absence of overlap between source and destination reduces the risk of data corruption, but the lack of null checks remains a critical issue.\n\n## In Context Remediation\nBefore performing the memory copy operation, ensure that both the source and destination pointers are not null. This can be done by adding explicit checks before the call. If either pointer is null, handle the error appropriately (e.g., return an error code, throw an exception, or log the error).\n\n```cpp\nif (residuals1.data() != nullptr && residuals.data() != nullptr) {\n    memcpy(residuals1.data() + j * d, residuals.data() + j * d * cur_beam_size, sizeof(residuals[0]) * d);\n} else {\n    // Handle error: one or both pointers are null\n    // For example:\n    // throw std::runtime_error(\"Null pointer in memory copy operation\");\n}\n```\n\nAlternatively, if you are certain by design that these pointers can never be null, document this assumption clearly in the code and consider using assertions to enforce it during development:\n\n```cpp\nassert(residuals1.data() != nullptr && \"Destination buffer is null\");\nassert(residuals.data() != nullptr && \"Source buffer is null\");\nmemcpy(residuals1.data() + j * d, residuals.data() + j * d * cur_beam_size, sizeof(residuals[0]) * d);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "796bc0f1-54c8-3ab2-8ad8-2b8d2364f7bd",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This is a well-known source of undefined behavior in C/C++ when using functions like memcpy. Additionally, the analysis could not rule out the possibility that the source pointer may be null, further increasing the risk. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's capacity is not derived from a known safe source. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(new_codes_i, codes_i + js * m, sizeof(*codes) * m);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e95e1201-8c57-31fa-abb0-725ef3106ca9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination in a memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The dataflow analysis suggests that the destination and source may overlap, which can cause unpredictable results with standard memory copy functions. Additionally, the source pointer may be null at this location, which further increases the risk of runtime errors. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's size is not clearly defined, increasing the risk of memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with one that safely handles overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. For example, change the code to:\n\n```cpp\nmemmove(new_codes_i, codes_i + js * m, sizeof(*codes) * m);\n```\n\nThis change ensures that even if the source and destination regions overlap, the data will be copied correctly without causing undefined behavior.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e370e54a-532f-3817-b473-6d750b5cfcbb",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the destination and source may overlap based on data flow, which can cause undefined behavior with functions like memcpy. Additionally, there is no explicit check to ensure that the source is non-null, increasing the risk of a null pointer dereference. The destination is guarded as non-null, but the source is not. The count argument is not directly derived from the destination's capacity, and there are no additional guards or null-termination steps. These factors all contribute to the assessment that this is a genuine and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace `memcpy` with `memmove`, which is safe for overlapping regions. Additionally, ensure that the source pointer is not null before the copy operation to avoid null pointer dereference.\n\n```cpp\nif (other.codebooks.data() != nullptr) {\n    memmove(codebooks.data(), other.codebooks.data() + other.codebook_offsets[skip_M] * d, codebooks.size() * sizeof(codebooks[0]));\n}\n```\n\nThis change ensures that the copy operation is safe even if the source and destination overlap, and it guards against null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0b329990-7068-3021-af51-00a62557defb",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with memcpy. Additionally, there are no checks ensuring that the source and destination are non-null, which increases the risk of null pointer dereference. No explicit bounds or capacity checks are present, and there is no evidence that the length argument is derived from the destination's capacity. These factors all contribute to the high confidence in this being a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. Additionally, ensure that both the source and destination pointers are not null before performing the operation. For example:\n\n```cpp\nif (nbits.data() != nullptr && other.nbits.data() != nullptr) {\n    memmove(nbits.data(), other.nbits.data() + skip_M, nbits.size() * sizeof(nbits[0]));\n}\n```\nThis change ensures that the copy operation is safe even if the source and destination regions overlap, and it avoids null pointer dereference. For further information, see the following resources.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "54008130-9785-3b33-bfad-2b305b08fcc7",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may refer to overlapping memory areas, which is not allowed for the memcpy function and can result in unpredictable program behavior. Additionally, there is no evidence of a guard to ensure that the source pointer is non-null, increasing the risk of a null pointer dereference. The destination is a pointer type with no known capacity, and the count argument is not directly derived from the destination's size, further increasing the risk. The verdict is supported by the high-confidence classification and the presence of multiple risk factors.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of memcpy with memmove, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(dest, src, sizeof(float) * d);\n```\n\nBefore performing the copy, also ensure that the source pointer is not null to avoid a potential null pointer dereference:\n\n```cpp\nif (src != nullptr) {\n    memmove(dest, src, sizeof(float) * d);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "8e8f3fd3-dec0-3ef6-9c5c-dac0f8a0b477",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are both pointers, and dataflow analysis suggests that they may refer to overlapping memory regions. Additionally, there is no explicit check or guard in the code to ensure that the source and destination do not overlap. The source pointer may also be null at this point, as there is no prior check to guarantee it is valid. These factors together indicate a real risk of undefined behavior, which can lead to unpredictable program behavior, crashes, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination regions safely. Replace the original memory copy operation with the following:\n\n```cpp\nmemmove(centroids, clus.centroids.data(), sizeof(*centroids) * d * k);\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy. For example:\n\n```cpp\nif (centroids != nullptr && clus.centroids.data() != nullptr) {\n    memmove(centroids, clus.centroids.data(), sizeof(*centroids) * d * k);\n}\n```\n\nThis change eliminates the risk of undefined behavior due to overlapping memory regions and null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d61dba31-3363-3bc7-9c98-ac1dfaf756c6",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are derived from the same base data structure, and dataflow analysis indicates that the source and destination may overlap. Additionally, the source pointer could potentially be null, which would also result in undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the function verdict confirms this as a genuine issue. The risk is further increased because the size of the copy is not directly tied to the capacity of the destination, and there is no evidence that the length is derived from the buffer's size. This combination of factors makes the finding a high-confidence, actionable security or correctness issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. `memmove` is specifically designed to handle overlapping source and destination buffers safely, whereas `memcpy` is not. \n\n**Remediation example:**\n\n```cpp\nmemmove(&centroids[i * d], x + perm[i] * line_size, line_size);\n```\n\nThis change ensures that even if the source and destination regions overlap, the copy will be performed correctly without causing undefined behavior.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "82530a3e-989d-35fd-95b6-17f7f4673715",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory areas, as indicated by the dataflow analysis. Additionally, there are no checks ensuring that the source and destination pointers are non-null before the operation, which increases the risk of null pointer dereference. The absence of explicit bounds or capacity checks further increases the risk. The verdict is supported by the high-confidence classification and the 'GENUINE' label for this call site.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is safe for overlapping regions. Also, add explicit checks to ensure that both the source and destination pointers are not null before the operation.\n\n```cpp\nif (centroids.data() != nullptr && x_in != nullptr) {\n    // If overlap is possible, use memmove\n    memmove(centroids.data(), x_in, sizeof(float) * d * k);\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly in the code and add runtime assertions if feasible:\n\n```cpp\nassert(centroids.data() != x_in); // Document and enforce non-overlap\nmemcpy(centroids.data(), x_in, sizeof(float) * d * k);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "dc989425-8c7c-3095-8db7-9c50b76f3483",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the call site verdict marking it as genuine. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions that do not support overlapping regions. Additionally, the source pointer may be null, which could also lead to a crash or further undefined behavior. There are no explicit checks or guards in the code to prevent these issues, and the destination buffer's capacity is not clearly defined or checked. These factors all contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. Replace the original memory copy operation with `memmove` to ensure correct behavior even if the source and destination regions overlap.\n\n```cpp\nmemmove(x_new + i * line_size, x + perm[i] * line_size, line_size);\n```\n\nThis change ensures that the copy operation is safe regardless of whether the source and destination memory regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "cda31d14-1b01-313f-bbdc-42c2f4dbb5a6",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination expressions may refer to overlapping regions of the same buffer, which can cause undefined behavior when using functions like memcpy. Additionally, the analysis could not rule out the possibility that the source pointer may be null, further increasing the risk. There are no explicit guards or checks in the code to prevent these issues. The verdict is supported by the high-confidence classification and the evidence of potential overlap and null pointer dereference.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```cpp\nmemmove(centroids + ci * d, centroids + cj * d, sizeof(*centroids) * d);\n```\n\nThis ensures that the copy operation works correctly even if the source and destination regions overlap.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a926d7d2-cbef-3f9b-9fa3-22189300a1f0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to a variety of security issues.\n\nThe specific vulnerability sink in question is `(double)rand() / (double)RAND_MAX`. The `rand()` function in C++ is a weak random number generator that is not suitable for cryptographic purposes. It generates a pseudo-random number that can be easily predicted, especially if the seed is known or can be guessed.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use the `<random>` library, which provides a variety of random number generators that are more suitable for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nReplace the use of `rand()` with a cryptographic random number generator. Here is an example using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\ndouble random = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "a926d7d2-cbef-3f9b-9fa3-22189300a1f0"
                ]
              }
            },
            {
              "id": "212f93c1-72d4-38e1-8973-4145f2c7aaf5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to a variety of security issues.\n\nThe specific vulnerability sink in question is `(double)rand() / (double)RAND_MAX`. The `rand()` function in C++ is a weak random number generator that is not suitable for cryptographic purposes. It generates a pseudo-random number that can be easily predicted, especially if the seed is known or can be guessed.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use the `<random>` library, which provides a variety of random number generators that are more suitable for cryptographic purposes.\n\n## Source Code Fix Recommendation\n\nReplace the use of `rand()` with a cryptographic random number generator. Here is an example using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\ndouble random = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "212f93c1-72d4-38e1-8973-4145f2c7aaf5"
                ]
              }
            },
            {
              "id": "2b94c2c6-b1be-3564-94e9-f99967b317c9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of memory corruption. In the provided code snippet, the `printf` function is used, which can lead to format string vulnerabilities if the format string contains user-supplied data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `printf`, you can use `fprintf` or `snprintf` which are safer as they limit the number of characters to be printed, thus preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"[%.3f s] Setting parameter configuration \\\"%s\\\" on index\\n\",\n               elapsed() - t0,\n               selected_params.c_str());\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdio>` for `snprintf`\n- `<string>` for `std::string::c_str`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "595d2e22-8404-3a78-9efe-bcd969df96f9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of memory corruption. In this case, the `printf` function is used, which can lead to format string vulnerabilities if the format string contains user-supplied data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using unsafe C functions like `printf`. Instead, use safer alternatives that perform bounds checking or do not interpret format strings. In C++, you can use the `iostream` library for output, which does not interpret format strings and is generally safer.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `iostream`:\n\n```cpp\n#include <iostream>\n#include <iomanip>\n\nstd::cout << std::fixed << std::setprecision(3) << elapsed() - t0 << \" s] Preparing index \\\"\" << index_key << \"\\\" d=\" << d << std::endl;\n```\n\n## Library Dependencies\n\nThe original code requires the following libraries:\n\n- `stdio.h` for `printf`\n- Any libraries required by `elapsed`\n\nThe fixed code requires the following libraries:\n\n- `iostream` for `std::cout`\n- `iomanip` for `std::fixed` and `std::setprecision`\n- Any libraries required by `elapsed`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5889f598-58ef-3ece-885c-6d0bc4695919",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `memmove` function is used, which can lead to buffer overflow if not used correctly.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In C++, the Standard Template Library (STL) provides many safe alternatives. For example, instead of `memmove`, you can use `std::copy` or `std::copy_backward` from `<algorithm>` library.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy` or `std::copy_backward`. Here is how you can do it:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy_backward(x + 1 + i * (d + 1), x + 1 + i * (d + 1) + d, x + i * d + d);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for `memmove` function and `<algorithm>` library for `std::copy_backward` function.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2879a931-9b2f-3f6b-a5d0-17b50a483c90",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the `fopen` function is used, which can lead to vulnerabilities if the `fname` parameter is not properly validated or sanitized.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation and sanitization. In the case of `fopen`, it is important to ensure that the `fname` parameter does not contain any malicious input that could lead to a file inclusion vulnerability.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::string fname;\n// ... (set fname to the desired file name)\nstd::ifstream f(fname);\nif (!f.is_open()) {\n    // handle error\n}\n```\n\nIn this fixed code, the C++ `std::ifstream` class is used instead of the C `fopen` function. This class automatically handles many of the potential issues with `fopen`.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n* `<fstream>`\n\n## References\n\n* [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/CPlusPlus_Security_Cheat_Sheet.html)\n* [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4d94f2a8-19c7-3ad9-824e-ac45aba262ad",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the destination buffer's capacity is not known, and the number of bytes to copy is not proven to be within the bounds of the destination buffer. The use of a character pointer as the destination, without any information about its allocated size, increases the risk of a buffer overflow. Additionally, there is no explicit check or guard to ensure that the size argument does not exceed the actual buffer size, and there is no explicit null-termination after the copy. The source is a C-style string, which is generally safe, but the main risk comes from the lack of destination size validation. The classification and verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo remediate this buffer overflow risk, ensure that the number of bytes copied does not exceed the actual size of the destination buffer. If possible, determine the size of `char_buffer` at runtime or ensure it is always large enough for the data being copied. Additionally, explicitly null-terminate the destination buffer after copying, as `strncpy` does not guarantee null-termination if the source is longer than the specified size.\n\nExample fix:\n\n```cpp\n// Assume char_buffer_size is the actual size of char_buffer\nsize_t copy_len = (size < char_buffer_size - 1) ? size : char_buffer_size - 1;\nstrncpy(char_buffer, rep.c_str(), copy_len);\nchar_buffer[copy_len] = '\\0';\n```\n\nIf the size of `char_buffer` cannot be determined, consider using safer string handling functions or data structures, such as `std::string`, or ensure that the buffer is always allocated with sufficient space.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "c4b8cb65-7040-32ca-8b1f-b269c41a31fd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `atoi()` function is used, which is a prohibited function because it does not perform any error checking and can lead to integer overflow.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives that perform error checking. For example, instead of `atoi()`, you can use `strtol()` which allows you to check for errors.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`. Here is how you can do it:\n\n```cpp\n#include <cstdlib> // for strtol and errno\n#include <cerrno> // for errno\n#include <climits> // for LONG_MAX and LONG_MIN\n\nchar *end;\nlong the_with_weights = strtol(argv[2], &end, 10);\n\nif (end == argv[2] || *end != '\\0' || errno == ERANGE || the_with_weights > INT_MAX || the_with_weights < INT_MIN) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: for `strtol()` and `errno`\n- `<cerrno>`: for `errno`\n- `<climits>`: for `LONG_MAX` and `LONG_MIN`\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)\n- [CWE-807: Reliance on Untrusted Inputs in a Security Decision](https://cwe.mitre.org/data/definitions/807.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4ab8e6b3-9cfd-37c5-9f7c-8fb7ef5eb6f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\nThe `atoi()` function converts a string to an integer. It does not check for overflow or underflow, and it does not report errors. This can lead to unexpected behavior if the string cannot be represented as an integer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `atoi()` and instead use functions that perform error checking, such as `strtol()`. You should also validate all input to ensure it is within the expected range.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()`, which allows for error checking. Here is an example of how you can do this:\n\n```cpp\n#include <cstdlib>\n#include <cerrno>\n\nchar *endptr;\nlong the_index_num = strtol(argv[1], &endptr, 10);\n\nif (errno == ERANGE) {\n    // handle overflow or underflow\n} else if (endptr == argv[1]) {\n    // handle no digits were found\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This header file is needed for the `strtol()` function.\n- `<cerrno>`: This header file is needed to check for overflow or underflow errors.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ef9ecb8b-a49d-3647-9324-be5d800db9ea",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected that the source and destination may overlap based on data flow, which can cause unpredictable results with memory copy functions. Additionally, there is no evidence of a guard to prevent null pointers for the source, increasing the risk. The destination is not likely to be null, but the source may be. The destination is a pointer type with no clear capacity information, and the count expression is not directly tied to a known safe bound. All these factors contribute to the assessment that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n**Remediation Example:**\n\n```cpp\nif (centroids != nullptr && clus.centroids.data() != nullptr) {\n    memmove(centroids, clus.centroids.data(), sizeof(*centroids) * d * k);\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds null pointer checks for both the source and destination. This ensures safe copying even if the memory regions overlap and prevents undefined behavior due to null pointers.\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5ea9d47f-64dd-3f55-aa04-e7203db2b072",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis suggests that they may refer to overlapping memory areas. This can lead to unpredictable program behavior, data corruption, or crashes. There are no explicit checks or guards in the code to prevent this overlap, and the function used (`memcpy`) does not handle overlapping memory safely. The source and destination are both non-null at this point, so null pointer dereference is not a concern. However, the potential for overlapping memory regions makes this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to safely handle overlapping memory areas. This change ensures that the copy operation will not result in data corruption or unpredictable behavior if the source and destination regions overlap.\n\n```cpp\nmemmove(vmax, x, sizeof(*x) * d);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3bbec019-e182-3e3a-8884-924dd7f0bf62",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both pointers, and dataflow analysis indicates that they may refer to overlapping memory areas. In C and C++, using memcpy with overlapping memory is undefined behavior and can lead to data corruption or crashes. There are no explicit checks or guards in the code to prevent this overlap, and the function verdict confirms this as a genuine issue. The source and destination are both non-null at the call site, so the main risk is the potential for memory overlap.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the memory copy function with one that is safe for overlapping regions. In C and C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory safely. \n\n**Remediation:**\n\nReplace the original memory copy call with:\n\n```cpp\nmemmove(vmin, x, sizeof(*x) * d);\n```\n\nThis change ensures that even if the source and destination memory regions overlap, the copy will be performed correctly and safely, avoiding undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7805de82-ccb9-3258-8dba-b1999b6d2f0f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. In C and C++, using memory copy functions like memcpy with overlapping regions can result in unpredictable behavior, including data corruption or crashes. Additionally, there is no evidence that the destination pointer is always valid, which further increases the risk. The source pointer is guarded against being null, but the destination pointer may still be null at this point. These factors make this a high-confidence, actionable issue that should be addressed to ensure program correctness and security.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This ensures that the copy is performed correctly even if the regions overlap.\n\n```cpp\nmemmove(x_copy.data(), x, n * sizeof(*x));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. You can add explicit checks before the call:\n\n```cpp\nif (x_copy.data() != nullptr && x != nullptr) {\n    memmove(x_copy.data(), x, n * sizeof(*x));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "0470a315-ab4a-3a76-95d4-ba955ab8ab05",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis detected, via data flow, that the destination and source may overlap, which is not allowed for the standard memory copy function used here. Additionally, there is a risk that the source pointer may be null at this point, as there is no prior check ensuring it is non-null. The destination is less likely to be null, but the overlap and null source risks make this a high-confidence, actionable issue. No explicit bounds or null-termination protections are present, and the count argument is not derived from the destination's capacity, further increasing the risk.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy function with a function that safely handles overlapping regions. In C/C++, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. For example, change the code to:\n\n```cpp\nmemmove(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the operation. Add appropriate checks if necessary to avoid null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "51c9f610-24b4-3eed-a8b8-2ceab3119963",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source expressions are related by data flow, which means they may refer to overlapping memory areas. This is a well-known source of undefined behavior in C/C++ when using functions like memcpy. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null at this point, further increasing the risk. The destination is not likely to be null, but the combination of possible overlap and a potentially null source makes this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that safely handles overlapping regions, such as `memmove`. This function is designed to correctly handle overlapping memory areas, unlike `memcpy`, which can cause unpredictable results in such cases.\n\n```cpp\nmemmove(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids));\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the operation:\n\n```cpp\nif (dest_ids != nullptr && buf.ids != nullptr) {\n    memmove(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1d70bb79-65c8-3ed4-a529-0bda9dbc1673",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source pointers may refer to overlapping memory, as indicated by the data flow analysis. Additionally, there are no explicit checks ensuring that the source and destination are non-null, which increases the risk of null pointer dereference. The absence of bounds or capacity checks further increases the risk. The classification and verdict both indicate a high-confidence issue that should be addressed to prevent undefined behavior and potential security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation.\n\n```cpp\nif (ail->codes[i].data() != nullptr && vec.data() != nullptr) {\n    memmove(ail->codes[i].data(), vec.data(), ail->codes[i].size());\n}\n```\n\nThis change replaces `memcpy` with `memmove` and adds null pointer checks to prevent undefined behavior. Always verify that the size argument does not exceed the actual buffer sizes to avoid buffer overflows.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2d27b293-4cc9-3ccb-944a-a5ad56bb7c27",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the `memmove` function is used, which can lead to buffer overflow if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions whenever possible. For instance, instead of `memmove`, consider using `std::copy` from the C++ Standard Library, which is type-safe and less prone to errors.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove` function with `std::copy`. Here is how you can do it:\n\n```cpp\n#include <algorithm> // for std::copy\n\n// ...\n\nstd::copy(codes + i * code_size, codes + i * code_size + code_size, code + coarse_size);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memmove`\n- `<algorithm>` for `std::copy`\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "829d1dd4-e357-3254-a241-891b8e5a8158",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 765,
                  "startColumn": 61,
                  "endLine": 765,
                  "endColumn": 69,
                  "charOffset": 21647,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "55832926-9b88-31cd-b897-314138476b4d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 775,
                  "startColumn": 63,
                  "endLine": 775,
                  "endColumn": 71,
                  "charOffset": 21995,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "146d6b8d-9500-30e4-acbf-b793742fe9fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 471,
                  "startColumn": 12,
                  "endLine": 473,
                  "endColumn": 36,
                  "charOffset": 13270,
                  "charLength": 129,
                  "snippet": {
                    "text": "memcpy(ptr + new_l.offset + new_l.capacity * code_size,\n                   get_ids(list_no),\n                   n * sizeof(idx_t)",
                    "rendered": {
                      "text": "memcpy(ptr + new_l.offset + new_l.capacity * code_size,\n                   get_ids(list_no),\n                   n * sizeof(idx_t)",
                      "markdown": "`memcpy(ptr + new_l.offset + new_l.capacity * code_size,\n                   get_ids(list_no),\n                   n * sizeof(idx_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13270,
                        "charLength": 129
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr + new_l.offset + new_l.capacity * code_size, <size of ptr + new_l.offset + new_l.capacity * code_size>, \n                   get_ids(list_no), \n                   n * sizeof(idx_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "11784b33-ea2d-3411-b7a4-9b55e3fb520c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 648,
                  "startColumn": 4,
                  "endLine": 648,
                  "endColumn": 50,
                  "charOffset": 17839,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(new_lists.data(), &lists[l0], (l1 - l0)",
                    "rendered": {
                      "text": "memcpy(new_lists.data(), &lists[l0], (l1 - l0)",
                      "markdown": "`memcpy(new_lists.data(), &lists[l0], (l1 - l0)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17839,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_lists.data(), <size of new_lists.data()>,  &lists[l0],  (l1 - l0)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f1869165-b929-3ebf-ab27-b2097321677a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 470,
                  "startColumn": 12,
                  "endLine": 470,
                  "endColumn": 73,
                  "charOffset": 13195,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(ptr + new_l.offset, get_codes(list_no), n * code_size)",
                    "rendered": {
                      "text": "memcpy(ptr + new_l.offset, get_codes(list_no), n * code_size)",
                      "markdown": "`memcpy(ptr + new_l.offset, get_codes(list_no), n * code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13195,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr + new_l.offset, <size of ptr + new_l.offset>,  get_codes(list_no),  n * code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9fdb8f84-49f3-3364-9160-2e20b247a0f9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 4,
                  "endLine": 415,
                  "endColumn": 69,
                  "charOffset": 11721,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(codes + offset * code_size, codes_in, code_size * n_entry)",
                    "rendered": {
                      "text": "memcpy(codes + offset * code_size, codes_in, code_size * n_entry)",
                      "markdown": "`memcpy(codes + offset * code_size, codes_in, code_size * n_entry)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11721,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codes + offset * code_size, <size of codes + offset * code_size>,  codes_in,  code_size * n_entry)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "17c9bad1-4dfb-3ab8-be94-9df7f03d028d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 413,
                  "startColumn": 4,
                  "endLine": 413,
                  "endColumn": 50,
                  "charOffset": 11595,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(ids + offset, ids_in, sizeof(ids_in[0])",
                    "rendered": {
                      "text": "memcpy(ids + offset, ids_in, sizeof(ids_in[0])",
                      "markdown": "`memcpy(ids + offset, ids_in, sizeof(ids_in[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11595,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ids + offset, <size of ids + offset>,  ids_in,  sizeof(ids_in[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "886f4aac-e5fe-3289-a467-e133d81a4541",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 61,
                  "endLine": 295,
                  "endColumn": 69,
                  "charOffset": 8432,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fd9b7f22-eff3-399a-94da-50a1c2e20523",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 18,
                  "endLine": 299,
                  "endColumn": 23,
                  "charOffset": 8547,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ad1af128-cc77-3257-b9a5-1957e66c1d2f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/OnDiskInvertedLists.cpp"
                },
                "region": {
                  "startLine": 270,
                  "startColumn": 14,
                  "endLine": 270,
                  "endColumn": 19,
                  "charOffset": 7727,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "08e7519f-ba1e-3f4b-8464-a45e96c0bb35",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 382,
                  "startColumn": 12,
                  "endLine": 382,
                  "endColumn": 44,
                  "charOffset": 11409,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(c, ScopedIds(il, list_no)",
                    "rendered": {
                      "text": "memcpy(c, ScopedIds(il, list_no)",
                      "markdown": "`memcpy(c, ScopedIds(il, list_no)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11409,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c, <size of c>,  ScopedIds(il,  list_no)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f1085e7a-6da6-353b-a098-66c1595c91fb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 347,
                  "startColumn": 12,
                  "endLine": 347,
                  "endColumn": 46,
                  "charOffset": 10324,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(c, ScopedCodes(il, list_no)",
                    "rendered": {
                      "text": "memcpy(c, ScopedCodes(il, list_no)",
                      "markdown": "`memcpy(c, ScopedCodes(il, list_no)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10324,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c, <size of c>,  ScopedCodes(il,  list_no)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "43f97c64-ba69-3c56-b489-21773aca1453",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 4,
                  "endLine": 284,
                  "endColumn": 59,
                  "charOffset": 8389,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(&ids[list_no][offset], ids_in, sizeof(ids_in[0])",
                    "rendered": {
                      "text": "memcpy(&ids[list_no][offset], ids_in, sizeof(ids_in[0])",
                      "markdown": "`memcpy(&ids[list_no][offset], ids_in, sizeof(ids_in[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8389,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ids[list_no][offset], <size of &ids[list_no][offset]>,  ids_in,  sizeof(ids_in[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9a5a4676-a65d-31e5-8720-f6ad309db9ae",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 285,
                  "startColumn": 4,
                  "endLine": 285,
                  "endColumn": 78,
                  "charOffset": 8461,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(&codes[list_no][offset * code_size], codes_in, code_size * n_entry)",
                    "rendered": {
                      "text": "memcpy(&codes[list_no][offset * code_size], codes_in, code_size * n_entry)",
                      "markdown": "`memcpy(&codes[list_no][offset * code_size], codes_in, code_size * n_entry)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8461,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&codes[list_no][offset * code_size], <size of &codes[list_no][offset * code_size]>,  codes_in,  code_size * n_entry)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5ab4dc3a-fe8e-3ae3-b7b1-11d623dc9d74",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 252,
                  "startColumn": 4,
                  "endLine": 252,
                  "endColumn": 69,
                  "charOffset": 7500,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(&codes[list_no][o * code_size], code, code_size * n_entry)",
                    "rendered": {
                      "text": "memcpy(&codes[list_no][o * code_size], code, code_size * n_entry)",
                      "markdown": "`memcpy(&codes[list_no][o * code_size], code, code_size * n_entry)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7500,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&codes[list_no][o * code_size], <size of &codes[list_no][o * code_size]>,  code,  code_size * n_entry)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e70516d9-65a0-3c97-97bd-ed0cf7f1f4c6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/InvertedLists.cpp"
                },
                "region": {
                  "startLine": 250,
                  "startColumn": 4,
                  "endLine": 250,
                  "endColumn": 54,
                  "charOffset": 7379,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])",
                    "rendered": {
                      "text": "memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])",
                      "markdown": "`memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/InvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7379,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ids[list_no][o], <size of &ids[list_no][o]>,  ids_in,  sizeof(ids_in[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1970ef80-8756-33cd-8edd-1ae8241e91e6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 607,
                  "startColumn": 19,
                  "endLine": 607,
                  "endColumn": 26,
                  "charOffset": 14993,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "336fe975-41e7-3c03-9422-77e7974c1cef",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 495,
                  "startColumn": 19,
                  "endLine": 495,
                  "endColumn": 26,
                  "charOffset": 12446,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "65683616-7ceb-3963-b010-176378ea4876",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 310,
                  "startColumn": 19,
                  "endLine": 310,
                  "endColumn": 26,
                  "charOffset": 7846,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "93440079-6472-3e06-aab5-b8afa921cff8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 19,
                  "endLine": 81,
                  "endColumn": 26,
                  "charOffset": 1646,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b9e0180f-0caa-33a3-9dda-38e223b7465a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 8,
                  "endLine": 28,
                  "endColumn": 25,
                  "charOffset": 508,
                  "charLength": 17,
                  "snippet": {
                    "text": "memcpy(u8, x, 32)",
                    "rendered": {
                      "text": "memcpy(u8, x, 32)",
                      "markdown": "`memcpy(u8, x, 32)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 508,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "memcpy_s(u8, <size of u8>,  x,  32)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "57102ed5-1506-320a-8c40-e4297169239d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 8,
                  "endLine": 36,
                  "endColumn": 27,
                  "charOffset": 630,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(ptr, u8, 32)",
                    "rendered": {
                      "text": "memcpy(ptr, u8, 32)",
                      "markdown": "`memcpy(ptr, u8, 32)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 630,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr, <size of ptr>,  u8,  32)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "da45c7af-ae85-35dd-bdeb-6b2c7389070a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_emulated.h"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 8,
                  "endLine": 40,
                  "endColumn": 27,
                  "charOffset": 700,
                  "charLength": 19,
                  "snippet": {
                    "text": "memcpy(u8, ptr, 32)",
                    "rendered": {
                      "text": "memcpy(u8, ptr, 32)",
                      "markdown": "`memcpy(u8, ptr, 32)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_emulated.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 700,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "memcpy_s(u8, <size of u8>,  ptr,  32)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f0dd8a5c-b513-35c7-a2ee-91d90b4163be",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/gpu/GpuAutoTune.cpp"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 47,
                  "endLine": 103,
                  "endColumn": 67,
                  "charOffset": 2867,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(\"quantizer_\")",
                    "rendered": {
                      "text": "strlen(\"quantizer_\")",
                      "markdown": "`strlen(\"quantizer_\")`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/gpu/GpuAutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2867,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/gpu/GpuAutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2867,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d094616b-96df-34f6-a7c0-8a2ab84867d2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/utils.cpp"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 4,
                  "endLine": 339,
                  "endColumn": 37,
                  "charOffset": 8143,
                  "charLength": 33,
                  "snippet": {
                    "text": "memcpy(v2, v2_in, sizeof(int64_t)",
                    "rendered": {
                      "text": "memcpy(v2, v2_in, sizeof(int64_t)",
                      "markdown": "`memcpy(v2, v2_in, sizeof(int64_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/utils.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8143,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "memcpy_s(v2, <size of v2>,  v2_in,  sizeof(int64_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f4fe7a17-d74e-3cc7-a020-cc850d27a743",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/utils.cpp"
                },
                "region": {
                  "startLine": 457,
                  "startColumn": 8,
                  "endLine": 457,
                  "endColumn": 72,
                  "charOffset": 11147,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(&x_subset[i * d], &x[subset[i] * size_t(d)], sizeof(x[0])",
                    "rendered": {
                      "text": "memcpy(&x_subset[i * d], &x[subset[i] * size_t(d)], sizeof(x[0])",
                      "markdown": "`memcpy(&x_subset[i * d], &x[subset[i] * size_t(d)], sizeof(x[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/utils.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11147,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&x_subset[i * d], <size of &x_subset[i * d]>,  &x[subset[i] * size_t(d)],  sizeof(x[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "152ca755-37f1-390e-95ec-7134ee5a85f3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/utils.cpp"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 12,
                  "endLine": 324,
                  "endColumn": 51,
                  "charOffset": 7812,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(lI0, tmpI.data(), sizeof(lI0[0])",
                    "rendered": {
                      "text": "memcpy(lI0, tmpI.data(), sizeof(lI0[0])",
                      "markdown": "`memcpy(lI0, tmpI.data(), sizeof(lI0[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/utils.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7812,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(lI0, <size of lI0>,  tmpI.data(),  sizeof(lI0[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ea2271c2-45db-36d2-8bfa-11dedc5e7f47",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/utils.cpp"
                },
                "region": {
                  "startLine": 323,
                  "startColumn": 12,
                  "endLine": 323,
                  "endColumn": 51,
                  "charOffset": 7754,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(lD0, tmpD.data(), sizeof(lD0[0])",
                    "rendered": {
                      "text": "memcpy(lD0, tmpD.data(), sizeof(lD0[0])",
                      "markdown": "`memcpy(lD0, tmpD.data(), sizeof(lD0[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/utils.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7754,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(lD0, <size of lD0>,  tmpD.data(),  sizeof(lD0[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fe256194-aac1-3eae-902e-58f8d5df2d09",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/utils.cpp"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 4,
                  "endLine": 173,
                  "endColumn": 11,
                  "charOffset": 3414,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1fb9ee43-26cc-383a-aa3c-cc709008218f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/utils.cpp"
                },
                "region": {
                  "startLine": 156,
                  "startColumn": 14,
                  "endLine": 156,
                  "endColumn": 19,
                  "charOffset": 3074,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "59ea5dec-cff1-38bf-a7be-e60499c1b3be",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/sorting.cpp"
                },
                "region": {
                  "startLine": 519,
                  "startColumn": 12,
                  "endLine": 519,
                  "endColumn": 53,
                  "charOffset": 15120,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(ptrs.data(), lims, sizeof(lims[0])",
                    "rendered": {
                      "text": "memcpy(ptrs.data(), lims, sizeof(lims[0])",
                      "markdown": "`memcpy(ptrs.data(), lims, sizeof(lims[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/sorting.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15120,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptrs.data(), <size of ptrs.data()>,  lims,  sizeof(lims[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c55fdf17-d59e-3219-a616-723a70d9d6b7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/sorting.cpp"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 16,
                  "endLine": 183,
                  "endColumn": 36,
                  "charOffset": 5052,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(permB + segs[s].i0,\n                       permA + segs[s].i0,\n                       segs[s].len()",
                    "rendered": {
                      "text": "memcpy(permB + segs[s].i0,\n                       permA + segs[s].i0,\n                       segs[s].len()",
                      "markdown": "`memcpy(permB + segs[s].i0,\n                       permA + segs[s].i0,\n                       segs[s].len()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/sorting.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5052,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(permB + segs[s].i0, <size of permB + segs[s].i0>, \n                       permA + segs[s].i0, \n                       segs[s].len()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ef8b743a-745e-3369-852a-9dde3d4756a8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/Heap.h"
                },
                "region": {
                  "startLine": 338,
                  "startColumn": 4,
                  "endLine": 338,
                  "endColumn": 11,
                  "charOffset": 9345,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d1ef891d-f844-3b7e-86e8-9d5d3cf2e658",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/sorting.cpp"
                },
                "region": {
                  "startLine": 121,
                  "startColumn": 12,
                  "endLine": 121,
                  "endColumn": 55,
                  "charOffset": 3439,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(dst + sw.i0, src + s2t.i0, s2t.len()",
                    "rendered": {
                      "text": "memcpy(dst + sw.i0, src + s2t.i0, s2t.len()",
                      "markdown": "`memcpy(dst + sw.i0, src + s2t.i0, s2t.len()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/sorting.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3439,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst + sw.i0, <size of dst + sw.i0>,  src + s2t.i0,  s2t.len()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c2989b22-2162-30cd-9e07-b331bcf4ca56",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/sorting.cpp"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 12,
                  "endLine": 118,
                  "endColumn": 55,
                  "charOffset": 3285,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(dst + sw.i0, src + s1t.i0, s1t.len()",
                    "rendered": {
                      "text": "memcpy(dst + sw.i0, src + s1t.i0, s1t.len()",
                      "markdown": "`memcpy(dst + sw.i0, src + s1t.i0, s1t.len()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/sorting.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3285,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst + sw.i0, <size of dst + sw.i0>,  src + s1t.i0,  s1t.len()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "91c877d1-90d8-3f14-9489-fe0b56e9a8c0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/Heap.h"
                },
                "region": {
                  "startLine": 337,
                  "startColumn": 4,
                  "endLine": 337,
                  "endColumn": 11,
                  "charOffset": 9285,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "05671d44-76c7-3ed8-b5c8-49008155031d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_avx2.h"
                },
                "region": {
                  "startLine": 473,
                  "startColumn": 19,
                  "endLine": 473,
                  "endColumn": 26,
                  "charOffset": 13002,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c91b88ce-48e8-309d-9581-a1d740df821c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_avx2.h"
                },
                "region": {
                  "startLine": 397,
                  "startColumn": 19,
                  "endLine": 397,
                  "endColumn": 26,
                  "charOffset": 11019,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "eaa16495-16e0-3ff3-ad13-bbd3e523e511",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_avx2.h"
                },
                "region": {
                  "startLine": 278,
                  "startColumn": 19,
                  "endLine": 278,
                  "endColumn": 26,
                  "charOffset": 7666,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "419458cd-4602-378d-9018-60b7b9fde656",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_avx2.h"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 19,
                  "endLine": 95,
                  "endColumn": 26,
                  "charOffset": 2362,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c942bf37-bd46-35e3-a9cc-45155c0855c8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/AlignedTable.h"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 12,
                  "endLine": 102,
                  "endColumn": 44,
                  "charOffset": 2191,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(ptr, other.ptr, sizeof(T)",
                    "rendered": {
                      "text": "memcpy(ptr, other.ptr, sizeof(T)",
                      "markdown": "`memcpy(ptr, other.ptr, sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/AlignedTable.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2191,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr, <size of ptr>,  other.ptr,  sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b72052b8-64c4-3ca0-b234-e10df22d4394",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/AlignedTable.h"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 16,
                  "endLine": 55,
                  "endColumn": 46,
                  "charOffset": 1245,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(new_ptr, ptr, sizeof(T)",
                    "rendered": {
                      "text": "memcpy(new_ptr, ptr, sizeof(T)",
                      "markdown": "`memcpy(new_ptr, ptr, sizeof(T)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/AlignedTable.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1245,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_ptr, <size of new_ptr>,  ptr,  sizeof(T)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "bd247ac0-9838-3c52-b1d8-36a7df58ed5d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/BlockInvertedLists.cpp"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 4,
                  "endLine": 52,
                  "endColumn": 54,
                  "charOffset": 1419,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])",
                    "rendered": {
                      "text": "memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])",
                      "markdown": "`memcpy(&ids[list_no][o], ids_in, sizeof(ids_in[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/BlockInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1419,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ids[list_no][o], <size of &ids[list_no][o]>,  ids_in,  sizeof(ids_in[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8c89d273-2481-32bb-836a-44ffb7f16096",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/invlists/BlockInvertedLists.cpp"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 8,
                  "endLine": 57,
                  "endColumn": 74,
                  "charOffset": 1667,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(&codes[list_no][o * code_size], code, n_block * block_size)",
                    "rendered": {
                      "text": "memcpy(&codes[list_no][o * code_size], code, n_block * block_size)",
                      "markdown": "`memcpy(&codes[list_no][o * code_size], code, n_block * block_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/invlists/BlockInvertedLists.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1667,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&codes[list_no][o * code_size], <size of &codes[list_no][o * code_size]>,  code,  n_block * block_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "62d96ae8-9ad6-3890-9544-8435b41852e2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 140,
                  "startColumn": 15,
                  "endLine": 140,
                  "endColumn": 22,
                  "charOffset": 4005,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5efd201b-72fc-3848-8b86-5c138a820645",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFAdditiveQuantizerFastScan.cpp"
                },
                "region": {
                  "startLine": 463,
                  "startColumn": 12,
                  "endLine": 463,
                  "endColumn": 59,
                  "charOffset": 13522,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(tab, norm_lut, norm_dim12 * sizeof(*tab)",
                    "rendered": {
                      "text": "memcpy(tab, norm_lut, norm_dim12 * sizeof(*tab)",
                      "markdown": "`memcpy(tab, norm_lut, norm_dim12 * sizeof(*tab)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFAdditiveQuantizerFastScan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13522,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tab, <size of tab>,  norm_lut,  norm_dim12 * sizeof(*tab)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d4a3ba91-9e71-332b-aadc-e6fc2e637d5a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFAdditiveQuantizerFastScan.cpp"
                },
                "region": {
                  "startLine": 313,
                  "startColumn": 12,
                  "endLine": 313,
                  "endColumn": 19,
                  "charOffset": 8942,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "65ce472d-9ffe-31f2-9bc9-28a6b3b1930d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/utils/simdlib_neon.h"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 9,
                  "endLine": 113,
                  "endColumn": 39,
                  "charOffset": 3278,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(bytes, ds, sizeof(char)",
                    "rendered": {
                      "text": "memcpy(bytes, ds, sizeof(char)",
                      "markdown": "`memcpy(bytes, ds, sizeof(char)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/utils/simdlib_neon.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3278,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes, <size of bytes>,  ds,  sizeof(char)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "64a16ac3-1fc5-354c-9c7d-32ccab564618",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/lattice_Zn.cpp"
                },
                "region": {
                  "startLine": 632,
                  "startColumn": 12,
                  "endLine": 634,
                  "endColumn": 29,
                  "charOffset": 17273,
                  "charLength": 98,
                  "snippet": {
                    "text": "memcpy(c + i * subdim,\n                   &cache[codes[i] * subdim],\n                   sizeof(*c)",
                    "rendered": {
                      "text": "memcpy(c + i * subdim,\n                   &cache[codes[i] * subdim],\n                   sizeof(*c)",
                      "markdown": "`memcpy(c + i * subdim,\n                   &cache[codes[i] * subdim],\n                   sizeof(*c)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/lattice_Zn.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17273,
                        "charLength": 98
                      },
                      "insertedContent": {
                        "text": "memcpy_s(c + i * subdim, <size of c + i * subdim>, \n                   &cache[codes[i] * subdim], \n                   sizeof(*c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "152d10cc-34aa-3e85-ad1a-e1b6d9704173",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/lattice_Zn.cpp"
                },
                "region": {
                  "startLine": 537,
                  "startColumn": 12,
                  "endLine": 539,
                  "endColumn": 44,
                  "charOffset": 14439,
                  "charLength": 115,
                  "snippet": {
                    "text": "memcpy(&cache[i * dimsub],\n                   c.data() + dim - dimsub,\n                   dimsub * sizeof(*c.data()",
                    "rendered": {
                      "text": "memcpy(&cache[i * dimsub],\n                   c.data() + dim - dimsub,\n                   dimsub * sizeof(*c.data()",
                      "markdown": "`memcpy(&cache[i * dimsub],\n                   c.data() + dim - dimsub,\n                   dimsub * sizeof(*c.data()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/lattice_Zn.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14439,
                        "charLength": 115
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&cache[i * dimsub], <size of &cache[i * dimsub]>, \n                   c.data() + dim - dimsub, \n                   dimsub * sizeof(*c.data()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "730b0633-00ea-332d-881a-74012922eecc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 281,
                  "startColumn": 12,
                  "endLine": 283,
                  "endColumn": 22,
                  "charOffset": 8058,
                  "charLength": 116,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + qi) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + qi) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + qi) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8058,
                        "charLength": 116
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + qi) * 32 + 16, <size of dest + (sq / 2 * nq + qi) * 32 + 16>, \n                   src + (q * nsq + sq + 1) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "114fa345-18d9-309b-91c9-2db23400ed96",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 278,
                  "startColumn": 12,
                  "endLine": 280,
                  "endColumn": 22,
                  "charOffset": 7937,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + qi) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + qi) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + qi) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7937,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + qi) * 32, <size of dest + (sq / 2 * nq + qi) * 32>, \n                   src + (q * nsq + sq) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "578c55e4-4d0f-3c8f-aefc-e39096208a50",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 243,
                  "startColumn": 12,
                  "endLine": 245,
                  "endColumn": 22,
                  "charOffset": 7062,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + q) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + q) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + q) * 32,\n                   src + (q * nsq + sq) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7062,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + q) * 32, <size of dest + (sq / 2 * nq + q) * 32>, \n                   src + (q * nsq + sq) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b0d3fda1-07f6-33a5-9e10-70ab8481fc6d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/pq4_fast_scan.cpp"
                },
                "region": {
                  "startLine": 246,
                  "startColumn": 12,
                  "endLine": 248,
                  "endColumn": 22,
                  "charOffset": 7182,
                  "charLength": 115,
                  "snippet": {
                    "text": "memcpy(dest + (sq / 2 * nq + q) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                    "rendered": {
                      "text": "memcpy(dest + (sq / 2 * nq + q) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)",
                      "markdown": "`memcpy(dest + (sq / 2 * nq + q) * 32 + 16,\n                   src + (q * nsq + sq + 1) * 16,\n                   16)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/pq4_fast_scan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7182,
                        "charLength": 115
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest + (sq / 2 * nq + q) * 32 + 16, <size of dest + (sq / 2 * nq + q) * 32 + 16>, \n                   src + (q * nsq + sq + 1) * 16, \n                   16)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2084664d-108d-3363-b022-3e0ebdae70ae",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexLSH.cpp"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 12,
                  "endLine": 175,
                  "endColumn": 67,
                  "charOffset": 4876,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(x + i * d, xt + i * nbits, nbits * sizeof(xt[0])",
                    "rendered": {
                      "text": "memcpy(x + i * d, xt + i * nbits, nbits * sizeof(xt[0])",
                      "markdown": "`memcpy(x + i * d, xt + i * nbits, nbits * sizeof(xt[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexLSH.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4876,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x + i * d, <size of x + i * d>,  xt + i * nbits,  nbits * sizeof(xt[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f152cc97-359d-3cff-91aa-b59ac107f74a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexLSH.cpp"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 12,
                  "endLine": 61,
                  "endColumn": 36,
                  "charOffset": 1611,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xt, x, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xt, x, sizeof(*x)",
                      "markdown": "`memcpy(xt, x, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexLSH.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1611,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xt, <size of xt>,  x,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "af03e58b-f774-367e-94e8-f95f1ff8b59e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 20,
                  "endLine": 253,
                  "endColumn": 44,
                  "charOffset": 7182,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7182,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3ce35f57-9bc2-3827-bb78-1cb8337ddb40",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 20,
                  "endLine": 222,
                  "endColumn": 44,
                  "charOffset": 6173,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6173,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e072c7fe-67ca-3a7a-9545-684762dd0b88",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 8,
                  "endLine": 125,
                  "endColumn": 73,
                  "charOffset": 3152,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(cb, q->codebooks.data(), sub_codebook_size * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(cb, q->codebooks.data(), sub_codebook_size * sizeof(float)",
                      "markdown": "`memcpy(cb, q->codebooks.data(), sub_codebook_size * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3152,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(cb, <size of cb>,  q->codebooks.data(),  sub_codebook_size * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ef78a412-d7eb-3021-8343-4edb683d13ac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 12,
                  "endLine": 173,
                  "endColumn": 39,
                  "charOffset": 4583,
                  "charLength": 111,
                  "snippet": {
                    "text": "memcpy(xsub.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xsub.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(float)",
                      "markdown": "`memcpy(xsub.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4583,
                        "charLength": 111
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xsub.data() + i * q->d, <size of xsub.data() + i * q->d>, \n                   x + i * d + offset_d, \n                   q->d * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "870414e2-ee65-3b68-8f12-e5d65c184d74",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 12,
                  "endLine": 106,
                  "endColumn": 36,
                  "charOffset": 2520,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(xt.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xt.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(*x)",
                      "markdown": "`memcpy(xt.data() + i * q->d,\n                   x + i * d + offset_d,\n                   q->d * sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2520,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xt.data() + i * q->d, <size of xt.data() + i * q->d>, \n                   x + i * d + offset_d, \n                   q->d * sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c2320358-484a-331b-afc2-ac578f490ddd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexBinaryIVF.cpp"
                },
                "region": {
                  "startLine": 232,
                  "startColumn": 4,
                  "endLine": 232,
                  "endColumn": 61,
                  "charOffset": 6617,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(recons, invlists->get_single_code(list_no, offset)",
                    "rendered": {
                      "text": "memcpy(recons, invlists->get_single_code(list_no, offset)",
                      "markdown": "`memcpy(recons, invlists->get_single_code(list_no, offset)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexBinaryIVF.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6617,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(recons, <size of recons>,  invlists->get_single_code(list_no,  offset)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "58a11958-a1cc-3655-87a0-99e4648597d1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 28,
                  "endLine": 230,
                  "endColumn": 38,
                  "charOffset": 6047,
                  "charLength": 10,
                  "snippet": {
                    "text": "strlen(sx)",
                    "rendered": {
                      "text": "strlen(sx)",
                      "markdown": "`strlen(sx)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6047,
                        "charLength": 10
                      },
                      "insertedContent": {
                        "text": "strlen_s(sx, <size of sx>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6047,
                        "charLength": 10
                      },
                      "insertedContent": {
                        "text": "strnlen(sx, <size of sx>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a5d2717d-e878-33d4-bc4a-8062b34a3bbf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 8,
                  "endLine": 209,
                  "endColumn": 39,
                  "charOffset": 5537,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(buffer.data(), src, nb1)",
                    "rendered": {
                      "text": "memcpy(buffer.data(), src, nb1)",
                      "markdown": "`memcpy(buffer.data(), src, nb1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5537,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer.data(), <size of buffer.data()>,  src,  nb1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "de532ab1-48fe-3c6d-a6a8-4978d74c1876",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NSG.h"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 8,
                  "endLine": 74,
                  "endColumn": 51,
                  "charOffset": 2012,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(data, g.data, N * K * sizeof(node_t)",
                    "rendered": {
                      "text": "memcpy(data, g.data, N * K * sizeof(node_t)",
                      "markdown": "`memcpy(data, g.data, N * K * sizeof(node_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/NSG.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2012,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data, <size of data>,  g.data,  N * K * sizeof(node_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2dc4f657-1f96-3c4a-b264-85598cc8d15a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 8,
                  "endLine": 191,
                  "endColumn": 43,
                  "charOffset": 5005,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(buffer.data() + b0, src, nb)",
                    "rendered": {
                      "text": "memcpy(buffer.data() + b0, src, nb)",
                      "markdown": "`memcpy(buffer.data() + b0, src, nb)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5005,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buffer.data() + b0, <size of buffer.data() + b0>,  src,  nb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9b9f1611-450e-36e8-a28d-51defe71bddc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 8,
                  "endLine": 166,
                  "endColumn": 39,
                  "charOffset": 4371,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(dst, buffer.data(), nb2)",
                    "rendered": {
                      "text": "memcpy(dst, buffer.data(), nb2)",
                      "markdown": "`memcpy(dst, buffer.data(), nb2)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4371,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  buffer.data(),  nb2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "649b1afd-bf2b-3fb8-ba10-4d6aa27fd77e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 8,
                  "endLine": 145,
                  "endColumn": 43,
                  "charOffset": 3855,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(dst, buffer.data() + b0, nb)",
                    "rendered": {
                      "text": "memcpy(dst, buffer.data() + b0, nb)",
                      "markdown": "`memcpy(dst, buffer.data() + b0, nb)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3855,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  buffer.data() + b0,  nb)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dba21b98-c748-3a27-b3dd-15474d13c799",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 8,
                  "endLine": 96,
                  "endColumn": 13,
                  "charOffset": 2539,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6786065e-61c7-3c7b-aca0-8deed6ba7411",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 8,
                  "endLine": 66,
                  "endColumn": 13,
                  "charOffset": 1769,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0ccc6549-8f3d-3762-9d7b-1ead0627e652",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 8,
                  "endLine": 40,
                  "endColumn": 44,
                  "charOffset": 1068,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&data[o], ptr, size * nitems)",
                    "rendered": {
                      "text": "memcpy(&data[o], ptr, size * nitems)",
                      "markdown": "`memcpy(&data[o], ptr, size * nitems)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1068,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&data[o], <size of &data[o]>,  ptr,  size * nitems)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2c46a065-6a91-3b2c-ade3-26242e1cf925",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/io.cpp"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 8,
                  "endLine": 52,
                  "endColumn": 45,
                  "charOffset": 1391,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(ptr, &data[rp], size * nitems)",
                    "rendered": {
                      "text": "memcpy(ptr, &data[rp], size * nitems)",
                      "markdown": "`memcpy(ptr, &data[rp], size * nitems)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1391,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr, <size of ptr>,  &data[rp],  size * nitems)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0c70383c-25ae-345c-90df-8b474838d8fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/python/python_callbacks.cpp"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 8,
                  "endLine": 98,
                  "endColumn": 49,
                  "charOffset": 2603,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(ptr, PyBytes_AsString(result), sz)",
                    "rendered": {
                      "text": "memcpy(ptr, PyBytes_AsString(result), sz)",
                      "markdown": "`memcpy(ptr, PyBytes_AsString(result), sz)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/python/python_callbacks.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2603,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr, <size of ptr>,  PyBytes_AsString(result),  sz)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "64180376-1b1c-3b46-a98a-a43d6eacfdcc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/kmeans1d.cpp"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 8,
                  "endLine": 197,
                  "endColumn": 43,
                  "charOffset": 5261,
                  "charLength": 35,
                  "snippet": {
                    "text": "memcpy(centroids, x, n * sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(centroids, x, n * sizeof(*x)",
                      "markdown": "`memcpy(centroids, x, n * sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/kmeans1d.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5261,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids, <size of centroids>,  x,  n * sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fe14c683-0ec4-32f3-af98-4c77d2542070",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexRowwiseMinMax.cpp"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 17,
                  "endLine": 184,
                  "endColumn": 34,
                  "charOffset": 5258,
                  "charLength": 175,
                  "snippet": {
                    "text": "memcpy(\n                    tmp.data() + i * old_code_size,\n                    bytes + i * new_code_size + (new_code_size - old_code_size),\n                    old_code_size)",
                    "rendered": {
                      "text": "memcpy(\n                    tmp.data() + i * old_code_size,\n                    bytes + i * new_code_size + (new_code_size - old_code_size),\n                    old_code_size)",
                      "markdown": "`memcpy(\n                    tmp.data() + i * old_code_size,\n                    bytes + i * new_code_size + (new_code_size - old_code_size),\n                    old_code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexRowwiseMinMax.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5258,
                        "charLength": 175
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n                    tmp.data() + i * old_code_size, <size of \n                    tmp.data() + i * old_code_size>, \n                    bytes + i * new_code_size + (new_code_size - old_code_size), \n                    old_code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ce7d3c8a-02fb-3cd2-968f-84327cf0b07b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexRowwiseMinMax.cpp"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 17,
                  "endLine": 126,
                  "endColumn": 24,
                  "charOffset": 3617,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "018a8ee2-3c31-3d45-b99e-f219e8cc4f4f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/MetaIndexes.cpp"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 12,
                  "endLine": 99,
                  "endColumn": 76,
                  "charOffset": 3181,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(sub_x + i * sub_d, x + ofs + i * d, sub_d * sizeof(sub_x)",
                    "rendered": {
                      "text": "memcpy(sub_x + i * sub_d, x + ofs + i * d, sub_d * sizeof(sub_x)",
                      "markdown": "`memcpy(sub_x + i * sub_d, x + ofs + i * d, sub_d * sizeof(sub_x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/MetaIndexes.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3181,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(sub_x + i * sub_d, <size of sub_x + i * sub_d>,  x + ofs + i * d,  sub_d * sizeof(sub_x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fa6777c6-3a7b-3661-b932-8ef4d4b1aeac",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 513,
                  "startColumn": 4,
                  "endLine": 513,
                  "endColumn": 30,
                  "charOffset": 14757,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(&norm2, &norm_i, 4)",
                    "rendered": {
                      "text": "memcpy(&norm2, &norm_i, 4)",
                      "markdown": "`memcpy(&norm2, &norm_i, 4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14757,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&norm2, <size of &norm2>,  &norm_i,  4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4f1fd3bf-2b1f-3163-b6a9-a44a10046044",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 12,
                  "endLine": 335,
                  "endColumn": 37,
                  "charOffset": 9620,
                  "charLength": 25,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*xi)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*xi)",
                      "markdown": "`memcpy(xi, c, sizeof(*xi)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9620,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*xi)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "30394aae-25d1-396e-acb7-3a7ad1986dca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 384,
                  "startColumn": 12,
                  "endLine": 384,
                  "endColumn": 41,
                  "charOffset": 10698,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(ips, LUT, sizeof(*ips)",
                    "rendered": {
                      "text": "memcpy(ips, LUT, sizeof(*ips)",
                      "markdown": "`memcpy(ips, LUT, sizeof(*ips)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10698,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ips, <size of ips>,  LUT,  sizeof(*ips)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a2c11e15-4514-3a7c-be79-bcb17aa257ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 16,
                  "endLine": 301,
                  "endColumn": 40,
                  "charOffset": 8549,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8549,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b168ac0e-b0a7-3d56-8ff8-764ce3c43096",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 272,
                  "startColumn": 16,
                  "endLine": 272,
                  "endColumn": 40,
                  "charOffset": 7730,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(xi, c, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(xi, c, sizeof(*x)",
                      "markdown": "`memcpy(xi, c, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7730,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  c,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1836240b-80c0-30c9-ad4f-58fbb19d69a3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 198,
                  "startColumn": 12,
                  "endLine": 198,
                  "endColumn": 36,
                  "charOffset": 5148,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(&inorm, &norm, 4)",
                    "rendered": {
                      "text": "memcpy(&inorm, &norm, 4)",
                      "markdown": "`memcpy(&inorm, &norm, 4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5148,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&inorm, <size of &inorm>,  &norm,  4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "67227c77-9f64-32d0-8505-d3f16f997747",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexFlat.cpp"
                },
                "region": {
                  "startLine": 179,
                  "startColumn": 8,
                  "endLine": 179,
                  "endColumn": 38,
                  "charOffset": 5075,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(x, bytes, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(x, bytes, sizeof(float)",
                      "markdown": "`memcpy(x, bytes, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5075,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x, <size of x>,  bytes,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a3158f47-333d-37fb-9664-b492fd9ec4e4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexFlat.cpp"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 8,
                  "endLine": 173,
                  "endColumn": 38,
                  "charOffset": 4925,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(bytes, x, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(bytes, x, sizeof(float)",
                      "markdown": "`memcpy(bytes, x, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4925,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bytes, <size of bytes>,  x,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7b1488f8-4a99-356b-9729-ad6a88078f11",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexFlat.cpp"
                },
                "region": {
                  "startLine": 168,
                  "startColumn": 4,
                  "endLine": 168,
                  "endColumn": 56,
                  "charOffset": 4768,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(recons, &(codes[key * code_size]), code_size)",
                    "rendered": {
                      "text": "memcpy(recons, &(codes[key * code_size]), code_size)",
                      "markdown": "`memcpy(recons, &(codes[key * code_size]), code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4768,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(recons, <size of recons>,  &(codes[key * code_size]),  code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5f984b00-e9dd-388f-b5fe-40f9fe14d1c5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 932,
                  "startColumn": 12,
                  "endLine": 934,
                  "endColumn": 46,
                  "charOffset": 29263,
                  "charLength": 134,
                  "snippet": {
                    "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                    "rendered": {
                      "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                      "markdown": "`memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29263,
                        "charLength": 134
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids + perm[i] * dsub, <size of centroids + perm[i] * dsub>, \n                   centroids_copy.data() + i * dsub, \n                   dsub * sizeof(centroids[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e28b967e-a65a-3db9-ab26-e014990fba94",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 909,
                  "startColumn": 28,
                  "endLine": 909,
                  "endColumn": 33,
                  "charOffset": 28554,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "021f3c2c-16c9-3c36-adda-160d4c1eb053",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 878,
                  "startColumn": 12,
                  "endLine": 880,
                  "endColumn": 32,
                  "charOffset": 27593,
                  "charLength": 114,
                  "snippet": {
                    "text": "memcpy(gt_distances.data(),\n                   pq.sdc_table.data() + m * nq * nb,\n                   sizeof(float)",
                    "rendered": {
                      "text": "memcpy(gt_distances.data(),\n                   pq.sdc_table.data() + m * nq * nb,\n                   sizeof(float)",
                      "markdown": "`memcpy(gt_distances.data(),\n                   pq.sdc_table.data() + m * nq * nb,\n                   sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27593,
                        "charLength": 114
                      },
                      "insertedContent": {
                        "text": "memcpy_s(gt_distances.data(), <size of gt_distances.data()>, \n                   pq.sdc_table.data() + m * nq * nb, \n                   sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6f66c3aa-50ec-3d84-9e94-00c1e4cb4790",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 854,
                  "startColumn": 16,
                  "endLine": 856,
                  "endColumn": 36,
                  "charOffset": 26855,
                  "charLength": 117,
                  "snippet": {
                    "text": "memcpy(xtrain.data() + i * dsub,\n                       x + i * pq.d + m * dsub,\n                       sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xtrain.data() + i * dsub,\n                       x + i * pq.d + m * dsub,\n                       sizeof(float)",
                      "markdown": "`memcpy(xtrain.data() + i * dsub,\n                       x + i * pq.d + m * dsub,\n                       sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26855,
                        "charLength": 117
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xtrain.data() + i * dsub, <size of xtrain.data() + i * dsub>, \n                       x + i * pq.d + m * dsub, \n                       sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "92936ba7-557c-3fa7-acd2-7fd793592b88",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 822,
                  "startColumn": 12,
                  "endLine": 824,
                  "endColumn": 46,
                  "charOffset": 25981,
                  "charLength": 134,
                  "snippet": {
                    "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                    "rendered": {
                      "text": "memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])",
                      "markdown": "`memcpy(centroids + perm[i] * dsub,\n                   centroids_copy.data() + i * dsub,\n                   dsub * sizeof(centroids[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25981,
                        "charLength": 134
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids + perm[i] * dsub, <size of centroids + perm[i] * dsub>, \n                   centroids_copy.data() + i * dsub, \n                   dsub * sizeof(centroids[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a27a49a3-24ca-3339-b76d-940a9c0aff8f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 802,
                  "startColumn": 28,
                  "endLine": 802,
                  "endColumn": 33,
                  "charOffset": 25355,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "aa176703-4dad-37ad-a8ae-7052aed91d0f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/PolysemousTraining.cpp"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 12,
                  "endLine": 94,
                  "endColumn": 58,
                  "charOffset": 2619,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(best_perm, perm.data(), sizeof(perm[0])",
                    "rendered": {
                      "text": "memcpy(best_perm, perm.data(), sizeof(perm[0])",
                      "markdown": "`memcpy(best_perm, perm.data(), sizeof(perm[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/PolysemousTraining.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2619,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(best_perm, <size of best_perm>,  perm.data(),  sizeof(perm[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7807379b-00b5-3856-8435-1e62bae444f3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexFlatCodes.cpp"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 4,
                  "endLine": 97,
                  "endColumn": 37,
                  "charOffset": 2783,
                  "charLength": 113,
                  "snippet": {
                    "text": "memcpy(codes.data() + (ntotal * code_size),\n           other->codes.data(),\n           other->ntotal * code_size)",
                    "rendered": {
                      "text": "memcpy(codes.data() + (ntotal * code_size),\n           other->codes.data(),\n           other->ntotal * code_size)",
                      "markdown": "`memcpy(codes.data() + (ntotal * code_size),\n           other->codes.data(),\n           other->ntotal * code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexFlatCodes.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2783,
                        "charLength": 113
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codes.data() + (ntotal * code_size), <size of codes.data() + (ntotal * code_size)>, \n           other->codes.data(), \n           other->ntotal * code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "decbf71b-43e0-362f-a1ef-5c876e8df23d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexFlatCodes.cpp"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 16,
                  "endLine": 49,
                  "endColumn": 23,
                  "charOffset": 1247,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6421bb04-abd0-3cb4-af94-dbf5cb46b341",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1243,
                  "startColumn": 4,
                  "endLine": 1243,
                  "endColumn": 31,
                  "charOffset": 33944,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(x, xt, sizeof(xt[0])",
                    "rendered": {
                      "text": "memcpy(x, xt, sizeof(xt[0])",
                      "markdown": "`memcpy(x, xt, sizeof(xt[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/VectorTransform.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33944,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x, <size of x>,  xt,  sizeof(xt[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b9437365-b71d-3619-85cd-9755c3d6e132",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1232,
                  "startColumn": 8,
                  "endLine": 1232,
                  "endColumn": 34,
                  "charOffset": 33681,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(xt, x, sizeof(x[0])",
                    "rendered": {
                      "text": "memcpy(xt, x, sizeof(x[0])",
                      "markdown": "`memcpy(xt, x, sizeof(x[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/VectorTransform.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33681,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xt, <size of xt>,  x,  sizeof(x[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d7ed3af0-f9f8-3a38-80fb-0bbcd1144b49",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1211,
                  "startColumn": 12,
                  "endLine": 1211,
                  "endColumn": 19,
                  "charOffset": 33075,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "853e9c18-a99f-30e2-96db-c506dfa67d79",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 740,
                  "startColumn": 8,
                  "endLine": 742,
                  "endColumn": 42,
                  "charOffset": 19533,
                  "charLength": 103,
                  "snippet": {
                    "text": "memcpy(rotation.data(),\n               init_rotation.data(),\n               d * d * sizeof(rotation[0])",
                    "rendered": {
                      "text": "memcpy(rotation.data(),\n               init_rotation.data(),\n               d * d * sizeof(rotation[0])",
                      "markdown": "`memcpy(rotation.data(),\n               init_rotation.data(),\n               d * d * sizeof(rotation[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/VectorTransform.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19533,
                        "charLength": 103
                      },
                      "insertedContent": {
                        "text": "memcpy_s(rotation.data(), <size of rotation.data()>, \n               init_rotation.data(), \n               d * d * sizeof(rotation[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "26bda864-deb0-3fe7-9bbb-413c237fc3d1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1026,
                  "startColumn": 8,
                  "endLine": 1026,
                  "endColumn": 14,
                  "charOffset": 27744,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1ec83b91-c85f-3c39-98bb-7bb2af23d59f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 1023,
                  "startColumn": 8,
                  "endLine": 1023,
                  "endColumn": 14,
                  "charOffset": 27619,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2a911b2a-91cc-3b8f-8da6-c0c27c8e93c2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/VectorTransform.cpp"
                },
                "region": {
                  "startLine": 664,
                  "startColumn": 16,
                  "endLine": 664,
                  "endColumn": 78,
                  "charOffset": 17437,
                  "charLength": 62,
                  "snippet": {
                    "text": "memcpy(&A[row_dst * d_in], &Ain[i * d_in], d_in * sizeof(A[0])",
                    "rendered": {
                      "text": "memcpy(&A[row_dst * d_in], &Ain[i * d_in], d_in * sizeof(A[0])",
                      "markdown": "`memcpy(&A[row_dst * d_in], &Ain[i * d_in], d_in * sizeof(A[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/VectorTransform.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17437,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&A[row_dst * d_in], <size of &A[row_dst * d_in]>,  &Ain[i * d_in],  d_in * sizeof(A[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e4df549a-bf42-3887-896e-5420643a1965",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 576,
                  "startColumn": 8,
                  "endLine": 578,
                  "endColumn": 39,
                  "charOffset": 19050,
                  "charLength": 119,
                  "snippet": {
                    "text": "memcpy(distances + i * k,\n               beam_distances.data() + beam_size * i,\n               k * sizeof(distances[0])",
                    "rendered": {
                      "text": "memcpy(distances + i * k,\n               beam_distances.data() + beam_size * i,\n               k * sizeof(distances[0])",
                      "markdown": "`memcpy(distances + i * k,\n               beam_distances.data() + beam_size * i,\n               k * sizeof(distances[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexAdditiveQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19050,
                        "charLength": 119
                      },
                      "insertedContent": {
                        "text": "memcpy_s(distances + i * k, <size of distances + i * k>, \n               beam_distances.data() + beam_size * i, \n               k * sizeof(distances[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "df80cc9b-5f10-3deb-936a-92fb84377c33",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexAdditiveQuantizerFastScan.cpp"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 12,
                  "endLine": 182,
                  "endColumn": 59,
                  "charOffset": 5299,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(lut, norm_lut, norm_dim12 * sizeof(*lut)",
                    "rendered": {
                      "text": "memcpy(lut, norm_lut, norm_dim12 * sizeof(*lut)",
                      "markdown": "`memcpy(lut, norm_lut, norm_dim12 * sizeof(*lut)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexAdditiveQuantizerFastScan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5299,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(lut, <size of lut>,  norm_lut,  norm_dim12 * sizeof(*lut)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "53eec251-26af-3b31-a2e9-c9dcbec57443",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexRefine.cpp"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 8,
                  "endLine": 182,
                  "endColumn": 66,
                  "charOffset": 5618,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(tmp2.get() + i * cs2, bytes + i * (cs1 + cs2), cs2)",
                    "rendered": {
                      "text": "memcpy(tmp2.get() + i * cs2, bytes + i * (cs1 + cs2), cs2)",
                      "markdown": "`memcpy(tmp2.get() + i * cs2, bytes + i * (cs1 + cs2), cs2)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexRefine.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5618,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tmp2.get() + i * cs2, <size of tmp2.get() + i * cs2>,  bytes + i * (cs1 + cs2),  cs2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "758a599d-efc8-3474-9a29-7fa5b4bdb1bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexRefine.cpp"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 8,
                  "endLine": 173,
                  "endColumn": 50,
                  "charOffset": 5265,
                  "charLength": 42,
                  "snippet": {
                    "text": "memcpy(b + cs1, tmp2.get() + cs2 * i, cs2)",
                    "rendered": {
                      "text": "memcpy(b + cs1, tmp2.get() + cs2 * i, cs2)",
                      "markdown": "`memcpy(b + cs1, tmp2.get() + cs2 * i, cs2)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexRefine.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5265,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "memcpy_s(b + cs1, <size of b + cs1>,  tmp2.get() + cs2 * i,  cs2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "12c3174d-dd03-3441-ad53-29954fe33f5f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexAdditiveQuantizerFastScan.cpp"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 12,
                  "endLine": 180,
                  "endColumn": 77,
                  "charOffset": 5190,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(lut, ip_lut.data() + i * ip_dim12, ip_dim12 * sizeof(*lut)",
                    "rendered": {
                      "text": "memcpy(lut, ip_lut.data() + i * ip_dim12, ip_dim12 * sizeof(*lut)",
                      "markdown": "`memcpy(lut, ip_lut.data() + i * ip_dim12, ip_dim12 * sizeof(*lut)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexAdditiveQuantizerFastScan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5190,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(lut, <size of lut>,  ip_lut.data() + i * ip_dim12,  ip_dim12 * sizeof(*lut)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "388b1ae6-fc83-33d6-80a7-9c5729ee0295",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexRefine.cpp"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 8,
                  "endLine": 172,
                  "endColumn": 44,
                  "charOffset": 5219,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(b, tmp1.get() + cs1 * i, cs1)",
                    "rendered": {
                      "text": "memcpy(b, tmp1.get() + cs1 * i, cs1)",
                      "markdown": "`memcpy(b, tmp1.get() + cs1 * i, cs1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexRefine.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5219,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(b, <size of b>,  tmp1.get() + cs1 * i,  cs1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "537d19a5-2f2c-355f-afa6-a3db1a93df29",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                },
                "region": {
                  "startLine": 579,
                  "startColumn": 8,
                  "endLine": 579,
                  "endColumn": 56,
                  "charOffset": 16351,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(codes, best_codes.data(), sizeof(int32_t)",
                    "rendered": {
                      "text": "memcpy(codes, best_codes.data(), sizeof(int32_t)",
                      "markdown": "`memcpy(codes, best_codes.data(), sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16351,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codes, <size of codes>,  best_codes.data(),  sizeof(int32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5733ed89-3957-3ebd-8a12-dc6f11e3f2b9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                },
                "region": {
                  "startLine": 570,
                  "startColumn": 16,
                  "endLine": 572,
                  "endColumn": 38,
                  "charOffset": 16108,
                  "charLength": 110,
                  "snippet": {
                    "text": "memcpy(best_codes.data() + i * M,\n                       codes + i * M,\n                       sizeof(int32_t)",
                    "rendered": {
                      "text": "memcpy(best_codes.data() + i * M,\n                       codes + i * M,\n                       sizeof(int32_t)",
                      "markdown": "`memcpy(best_codes.data() + i * M,\n                       codes + i * M,\n                       sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/LocalSearchQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16108,
                        "charLength": 110
                      },
                      "insertedContent": {
                        "text": "memcpy_s(best_codes.data() + i * M, <size of best_codes.data() + i * M>, \n                       codes + i * M, \n                       sizeof(int32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3aac61c9-2d55-3b10-9c32-a90c2a05fb7f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFPQFastScan.cpp"
                },
                "region": {
                  "startLine": 250,
                  "startColumn": 16,
                  "endLine": 250,
                  "endColumn": 62,
                  "charOffset": 6722,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(biases.get(), coarse_dis, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(biases.get(), coarse_dis, sizeof(float)",
                      "markdown": "`memcpy(biases.get(), coarse_dis, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFPQFastScan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6722,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(biases.get(), <size of biases.get()>,  coarse_dis,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "457753e3-3a9a-35f4-88ae-6b17fa8d6672",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFPQFastScan.cpp"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 12,
                  "endLine": 196,
                  "endColumn": 19,
                  "charOffset": 5320,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "120f3087-779a-3e45-aee0-e8b072ffef29",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFPQFastScan.cpp"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 12,
                  "endLine": 304,
                  "endColumn": 58,
                  "charOffset": 8903,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(biases.get(), coarse_dis, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(biases.get(), coarse_dis, sizeof(float)",
                      "markdown": "`memcpy(biases.get(), coarse_dis, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFPQFastScan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8903,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(biases.get(), <size of biases.get()>,  coarse_dis,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "22a7e8fc-ad2f-3065-99e4-8a93fd3b1e96",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFPQFastScan.cpp"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 8,
                  "endLine": 80,
                  "endColumn": 41,
                  "charOffset": 1954,
                  "charLength": 119,
                  "snippet": {
                    "text": "memcpy(precomputed_table.get(),\n               orig.precomputed_table.data(),\n               precomputed_table.nbytes()",
                    "rendered": {
                      "text": "memcpy(precomputed_table.get(),\n               orig.precomputed_table.data(),\n               precomputed_table.nbytes()",
                      "markdown": "`memcpy(precomputed_table.get(),\n               orig.precomputed_table.data(),\n               precomputed_table.nbytes()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFPQFastScan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1954,
                        "charLength": 119
                      },
                      "insertedContent": {
                        "text": "memcpy_s(precomputed_table.get(), <size of precomputed_table.get()>, \n               orig.precomputed_table.data(), \n               precomputed_table.nbytes()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8ff0a4bd-2348-3885-ba75-821957064ecf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexPQ.cpp"
                },
                "region": {
                  "startLine": 1069,
                  "startColumn": 12,
                  "endLine": 1069,
                  "endColumn": 55,
                  "charOffset": 30730,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(xdest, xsrc, dsub * sizeof(xdest[0])",
                    "rendered": {
                      "text": "memcpy(xdest, xsrc, dsub * sizeof(xdest[0])",
                      "markdown": "`memcpy(xdest, xsrc, dsub * sizeof(xdest[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexPQ.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30730,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xdest, <size of xdest>,  xsrc,  dsub * sizeof(xdest[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "52613f04-ff2b-3e97-8c27-2429f8f1bc0c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexPQ.cpp"
                },
                "region": {
                  "startLine": 980,
                  "startColumn": 8,
                  "endLine": 980,
                  "endColumn": 45,
                  "charOffset": 28240,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(recons, pq.get_centroids(m, n)",
                    "rendered": {
                      "text": "memcpy(recons, pq.get_centroids(m, n)",
                      "markdown": "`memcpy(recons, pq.get_centroids(m, n)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexPQ.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28240,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(recons, <size of recons>,  pq.get_centroids(m,  n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "010d6744-47f0-30de-ba0c-04085965e944",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/Index2Layer.cpp"
                },
                "region": {
                  "startLine": 319,
                  "startColumn": 8,
                  "endLine": 319,
                  "endColumn": 15,
                  "charOffset": 8768,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "059270fa-9b64-3407-b56b-952b5e663460",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/Index2Layer.cpp"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 8,
                  "endLine": 229,
                  "endColumn": 49,
                  "charOffset": 6001,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(&key01, code, storage.code_size_1)",
                    "rendered": {
                      "text": "memcpy(&key01, code, storage.code_size_1)",
                      "markdown": "`memcpy(&key01, code, storage.code_size_1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/Index2Layer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6001,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&key01, <size of &key01>,  code,  storage.code_size_1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "808724ab-1297-35af-9187-c4ecf3919b72",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/Index2Layer.cpp"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 8,
                  "endLine": 183,
                  "endColumn": 47,
                  "charOffset": 4531,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(&key, code, storage.code_size_1)",
                    "rendered": {
                      "text": "memcpy(&key, code, storage.code_size_1)",
                      "markdown": "`memcpy(&key, code, storage.code_size_1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/Index2Layer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4531,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&key, <size of &key>,  code,  storage.code_size_1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6311d02f-f675-3e1b-938e-5d04ecb5d556",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/Index2Layer.cpp"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 8,
                  "endLine": 128,
                  "endColumn": 37,
                  "charOffset": 3111,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(&key, rp, code_size_1)",
                    "rendered": {
                      "text": "memcpy(&key, rp, code_size_1)",
                      "markdown": "`memcpy(&key, rp, code_size_1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/Index2Layer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3111,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&key, <size of &key>,  rp,  code_size_1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "982cc8d3-1c6a-3a54-b13d-ec428abcb61f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFFastScan.cpp"
                },
                "region": {
                  "startLine": 169,
                  "startColumn": 12,
                  "endLine": 171,
                  "endColumn": 29,
                  "charOffset": 4748,
                  "charLength": 139,
                  "snippet": {
                    "text": "memcpy(list_codes.data() + (i - i0) * code_size,\n                   flat_codes.data() + order[i] * code_size,\n                   code_size)",
                    "rendered": {
                      "text": "memcpy(list_codes.data() + (i - i0) * code_size,\n                   flat_codes.data() + order[i] * code_size,\n                   code_size)",
                      "markdown": "`memcpy(list_codes.data() + (i - i0) * code_size,\n                   flat_codes.data() + order[i] * code_size,\n                   code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFFastScan.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4748,
                        "charLength": 139
                      },
                      "insertedContent": {
                        "text": "memcpy_s(list_codes.data() + (i - i0) * code_size, <size of list_codes.data() + (i - i0) * code_size>, \n                   flat_codes.data() + order[i] * code_size, \n                   code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "04dd7141-420f-30a5-92eb-a0da6be48a16",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NNDescent.cpp"
                },
                "region": {
                  "startLine": 137,
                  "startColumn": 4,
                  "endLine": 137,
                  "endColumn": 11,
                  "charOffset": 3609,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "89b28d0d-efda-3074-87b0-7f58c40385e3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NNDescent.cpp"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 8,
                  "endLine": 111,
                  "endColumn": 15,
                  "charOffset": 2918,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "47cb8447-c292-3ec5-a85e-7cfe201aeec2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexBinaryFlat.cpp"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 4,
                  "endLine": 101,
                  "endColumn": 58,
                  "charOffset": 2626,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(recons, &(xb[code_size * key]), sizeof(*recons)",
                    "rendered": {
                      "text": "memcpy(recons, &(xb[code_size * key]), sizeof(*recons)",
                      "markdown": "`memcpy(recons, &(xb[code_size * key]), sizeof(*recons)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexBinaryFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2626,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(recons, <size of recons>,  &(xb[code_size * key]),  sizeof(*recons)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "82f506bb-aa8b-3466-8223-1139c2f7b2f2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexNSG.cpp"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 16,
                  "endLine": 190,
                  "endColumn": 23,
                  "charOffset": 5317,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b77ab18d-ead1-36e2-a6d0-92e44f83740a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexBinaryFlat.cpp"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 16,
                  "endLine": 85,
                  "endColumn": 23,
                  "charOffset": 2239,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a27bda8f-4d08-362d-bfd9-9e794fa5e00d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFFlat.cpp"
                },
                "region": {
                  "startLine": 386,
                  "startColumn": 12,
                  "endLine": 386,
                  "endColumn": 63,
                  "charOffset": 11610,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(dis1 + j0, dis2.data() + j0, sizeof(dis2[0])",
                    "rendered": {
                      "text": "memcpy(dis1 + j0, dis2.data() + j0, sizeof(dis2[0])",
                      "markdown": "`memcpy(dis1 + j0, dis2.data() + j0, sizeof(dis2[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11610,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dis1 + j0, <size of dis1 + j0>,  dis2.data() + j0,  sizeof(dis2[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "00143001-9998-3f9f-827e-a58dd8462c1a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFFlat.cpp"
                },
                "region": {
                  "startLine": 383,
                  "startColumn": 12,
                  "endLine": 385,
                  "endColumn": 37,
                  "charOffset": 11486,
                  "charLength": 98,
                  "snippet": {
                    "text": "memcpy(labels1 + j0,\n                   labels2.data() + j0,\n                   sizeof(labels1[0])",
                    "rendered": {
                      "text": "memcpy(labels1 + j0,\n                   labels2.data() + j0,\n                   sizeof(labels1[0])",
                      "markdown": "`memcpy(labels1 + j0,\n                   labels2.data() + j0,\n                   sizeof(labels1[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11486,
                        "charLength": 98
                      },
                      "insertedContent": {
                        "text": "memcpy_s(labels1 + j0, <size of labels1 + j0>, \n                   labels2.data() + j0, \n                   sizeof(labels1[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f9eeecd7-48eb-361d-aee1-4b846010b38b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFFlat.cpp"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 4,
                  "endLine": 228,
                  "endColumn": 61,
                  "charOffset": 6676,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(recons, invlists->get_single_code(list_no, offset)",
                    "rendered": {
                      "text": "memcpy(recons, invlists->get_single_code(list_no, offset)",
                      "markdown": "`memcpy(recons, invlists->get_single_code(list_no, offset)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6676,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(recons, <size of recons>,  invlists->get_single_code(list_no,  offset)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ecd6c576-3252-3c23-8f2d-70e18c31f1b1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFFlat.cpp"
                },
                "region": {
                  "startLine": 254,
                  "startColumn": 12,
                  "endLine": 254,
                  "endColumn": 59,
                  "charOffset": 7549,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(x2.get() + n2 * d, x + i * d, code_size)",
                    "rendered": {
                      "text": "memcpy(x2.get() + n2 * d, x + i * d, code_size)",
                      "markdown": "`memcpy(x2.get() + n2 * d, x + i * d, code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7549,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x2.get() + n2 * d, <size of x2.get() + n2 * d>,  x + i * d,  code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "db72fe5c-a832-38b8-9a43-4bc28c642a24",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFFlat.cpp"
                },
                "region": {
                  "startLine": 115,
                  "startColumn": 8,
                  "endLine": 115,
                  "endColumn": 49,
                  "charOffset": 3146,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(xi, code + coarse_size, code_size)",
                    "rendered": {
                      "text": "memcpy(xi, code + coarse_size, code_size)",
                      "markdown": "`memcpy(xi, code + coarse_size, code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3146,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xi, <size of xi>,  code + coarse_size,  code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1a28c168-5e34-33a0-ab90-5e5fcc87c31c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFFlat.cpp"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 16,
                  "endLine": 102,
                  "endColumn": 57,
                  "charOffset": 2723,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(code + coarse_size, xi, code_size)",
                    "rendered": {
                      "text": "memcpy(code + coarse_size, xi, code_size)",
                      "markdown": "`memcpy(code + coarse_size, xi, code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2723,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(code + coarse_size, <size of code + coarse_size>,  xi,  code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "50e667da-aea3-321a-82ab-511f5c099dce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFFlat.cpp"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 8,
                  "endLine": 93,
                  "endColumn": 39,
                  "charOffset": 2342,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(codes, x, code_size * n)",
                    "rendered": {
                      "text": "memcpy(codes, x, code_size * n)",
                      "markdown": "`memcpy(codes, x, code_size * n)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFFlat.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2342,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codes, <size of codes>,  x,  code_size * n)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3fe1bef2-9c7b-395b-84b4-9b822b48894d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 565,
                  "startColumn": 47,
                  "endLine": 565,
                  "endColumn": 67,
                  "charOffset": 16173,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(\"quantizer_\")",
                    "rendered": {
                      "text": "strlen(\"quantizer_\")",
                      "markdown": "`strlen(\"quantizer_\")`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16173,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16173,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b68dfac8-504e-30c8-a6bf-804008e22e38",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 470,
                  "startColumn": 47,
                  "endLine": 470,
                  "endColumn": 67,
                  "charOffset": 13649,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(\"quantizer_\")",
                    "rendered": {
                      "text": "strlen(\"quantizer_\")",
                      "markdown": "`strlen(\"quantizer_\")`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13649,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13649,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(\"quantizer_\", <size of \"quantizer_\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7e5e844a-37e5-3172-958c-ab9d50f7c36a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 14,
                  "endLine": 209,
                  "endColumn": 19,
                  "charOffset": 5790,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "44c1fe05-e811-32ae-a18a-295bd46cb975",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 14,
                  "endLine": 195,
                  "endColumn": 19,
                  "charOffset": 5399,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "23bbf271-a5c1-384a-a122-ab4cae62c798",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 58,
                  "startColumn": 4,
                  "endLine": 58,
                  "endColumn": 48,
                  "charOffset": 1478,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(gt_I.data(), gt_I_in, sizeof(gt_I[0])",
                    "rendered": {
                      "text": "memcpy(gt_I.data(), gt_I_in, sizeof(gt_I[0])",
                      "markdown": "`memcpy(gt_I.data(), gt_I_in, sizeof(gt_I[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1478,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(gt_I.data(), <size of gt_I.data()>,  gt_I_in,  sizeof(gt_I[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "07d44a22-be0d-3b9e-bba8-bd681389267a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/AutoTune.cpp"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 8,
                  "endLine": 55,
                  "endColumn": 52,
                  "charOffset": 1377,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(gt_D.data(), gt_D_in, sizeof(gt_D[0])",
                    "rendered": {
                      "text": "memcpy(gt_D.data(), gt_D_in, sizeof(gt_D[0])",
                      "markdown": "`memcpy(gt_D.data(), gt_D_in, sizeof(gt_D[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/AutoTune.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1377,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(gt_D.data(), <size of gt_D.data()>,  gt_D_in,  sizeof(gt_D[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "94eec2ea-7cd8-3ba9-a1c7-32fdc0c7ee9d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NSG.cpp"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 4,
                  "endLine": 133,
                  "endColumn": 11,
                  "charOffset": 3070,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8ff697c7-556b-3e15-9f70-d7165241ec51",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/NSG.cpp"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 8,
                  "endLine": 103,
                  "endColumn": 15,
                  "charOffset": 2353,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6f1d9a41-b6c8-34d2-a373-5878483b4e1b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFPQ.cpp"
                },
                "region": {
                  "startLine": 499,
                  "startColumn": 16,
                  "endLine": 500,
                  "endColumn": 46,
                  "charOffset": 15154,
                  "charLength": 94,
                  "snippet": {
                    "text": "memcpy(centroids.data() + i * d + m * cpq.dsub,\n                       cpq.get_centroids(m, i)",
                    "rendered": {
                      "text": "memcpy(centroids.data() + i * d + m * cpq.dsub,\n                       cpq.get_centroids(m, i)",
                      "markdown": "`memcpy(centroids.data() + i * d + m * cpq.dsub,\n                       cpq.get_centroids(m, i)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IndexIVFPQ.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15154,
                        "charLength": 94
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids.data() + i * d + m * cpq.dsub, <size of centroids.data() + i * d + m * cpq.dsub>, \n                       cpq.get_centroids(m,  i)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "09cd632e-33a4-3c25-87fd-832af6c8e13b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFPQ.cpp"
                },
                "region": {
                  "startLine": 232,
                  "startColumn": 12,
                  "endLine": 232,
                  "endColumn": 19,
                  "charOffset": 6451,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "aeca8cbe-7a71-3eb5-a36b-c90a749d7f6b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/CodePacker.cpp"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 4,
                  "endLine": 48,
                  "endColumn": 40,
                  "charOffset": 1197,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(flat_codes, block, code_size)",
                    "rendered": {
                      "text": "memcpy(flat_codes, block, code_size)",
                      "markdown": "`memcpy(flat_codes, block, code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/CodePacker.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1197,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(flat_codes, <size of flat_codes>,  block,  code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "58f4d292-5aa8-3e07-9472-356e50bff644",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/CodePacker.cpp"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 4,
                  "endLine": 43,
                  "endColumn": 40,
                  "charOffset": 1061,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(block, flat_codes, code_size)",
                    "rendered": {
                      "text": "memcpy(block, flat_codes, code_size)",
                      "markdown": "`memcpy(block, flat_codes, code_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/CodePacker.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1061,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(block, <size of block>,  flat_codes,  code_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6c3d703f-bd48-3b5d-846a-2c1df6e4cb02",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/MatrixStats.cpp"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 18,
                  "endLine": 70,
                  "endColumn": 27,
                  "charOffset": 1495,
                  "charLength": 9,
                  "snippet": {
                    "text": "vsnprintf",
                    "rendered": {
                      "text": "vsnprintf",
                      "markdown": "`vsnprintf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3b1bbd62-36aa-3a0a-8a2d-ca77a8683c35",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IVFlib.cpp"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 4,
                  "endLine": 187,
                  "endColumn": 60,
                  "charOffset": 5802,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(dst.data() + insert_point, src.data(), src.size()",
                    "rendered": {
                      "text": "memcpy(dst.data() + insert_point, src.data(), src.size()",
                      "markdown": "`memcpy(dst.data() + insert_point, src.data(), src.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/IVFlib.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5802,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst.data() + insert_point, <size of dst.data() + insert_point>,  src.data(),  src.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f72f6d4c-bb38-3496-a8db-2b0f3a71dfc3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IVFlib.cpp"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 8,
                  "endLine": 182,
                  "endColumn": 15,
                  "charOffset": 5599,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4fc94590-ccbf-3da5-bcd0-3627e5a6a1c4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 8,
                  "endLine": 287,
                  "endColumn": 37,
                  "charOffset": 8690,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(x + m * pq.dsub,\n               pq.get_centroids(m, c)",
                    "rendered": {
                      "text": "memcpy(x + m * pq.dsub,\n               pq.get_centroids(m, c)",
                      "markdown": "`memcpy(x + m * pq.dsub,\n               pq.get_centroids(m, c)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8690,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x + m * pq.dsub, <size of x + m * pq.dsub>, \n               pq.get_centroids(m,  c)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1697bdaa-81e2-3606-8217-9dcee7c6a69d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 354,
                  "startColumn": 16,
                  "endLine": 356,
                  "endColumn": 43,
                  "charOffset": 10541,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(xslice + (i - i0) * dsub,\n                       x + i * d + m * dsub,\n                       dsub * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xslice + (i - i0) * dsub,\n                       x + i * d + m * dsub,\n                       dsub * sizeof(float)",
                      "markdown": "`memcpy(xslice + (i - i0) * dsub,\n                       x + i * d + m * dsub,\n                       dsub * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10541,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xslice + (i - i0) * dsub, <size of xslice + (i - i0) * dsub>, \n                       x + i * d + m * dsub, \n                       dsub * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c7ec45dd-3e5f-3145-abc9-3d1f90a92516",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 20,
                  "endLine": 164,
                  "endColumn": 46,
                  "charOffset": 4588,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(clus.centroids.data(),\n                           get_centroids(m, 0)",
                    "rendered": {
                      "text": "memcpy(clus.centroids.data(),\n                           get_centroids(m, 0)",
                      "markdown": "`memcpy(clus.centroids.data(),\n                           get_centroids(m, 0)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4588,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(clus.centroids.data(), <size of clus.centroids.data()>, \n                           get_centroids(m,  0)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8ee942d6-d2af-381d-8f9c-678c505933f2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ProductQuantizer.cpp"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 16,
                  "endLine": 144,
                  "endColumn": 43,
                  "charOffset": 3783,
                  "charLength": 114,
                  "snippet": {
                    "text": "memcpy(xslice + j * dsub,\n                       x + j * d + m * dsub,\n                       dsub * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(xslice + j * dsub,\n                       x + j * d + m * dsub,\n                       dsub * sizeof(float)",
                      "markdown": "`memcpy(xslice + j * dsub,\n                       x + j * d + m * dsub,\n                       dsub * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ProductQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3783,
                        "charLength": 114
                      },
                      "insertedContent": {
                        "text": "memcpy_s(xslice + j * dsub, <size of xslice + j * dsub>, \n                       x + j * d + m * dsub, \n                       dsub * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "02131c1e-ade1-31ea-801f-1cd901c6fff2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "c_api/IndexIVF_c.cpp"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 4,
                  "endLine": 125,
                  "endColumn": 51,
                  "charOffset": 3571,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(invlist, list, list_size * sizeof(idx_t)",
                    "rendered": {
                      "text": "memcpy(invlist, list, list_size * sizeof(idx_t)",
                      "markdown": "`memcpy(invlist, list, list_size * sizeof(idx_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "c_api/IndexIVF_c.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3571,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(invlist, <size of invlist>,  list,  list_size * sizeof(idx_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f2668f77-7e12-3200-ac08-27afd13e71ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1511,
                  "startColumn": 8,
                  "endLine": 1513,
                  "endColumn": 54,
                  "charOffset": 48723,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(out_distances,\n               distances_ptr,\n               distances_size * sizeof(*distances_ptr)",
                    "rendered": {
                      "text": "memcpy(out_distances,\n               distances_ptr,\n               distances_size * sizeof(*distances_ptr)",
                      "markdown": "`memcpy(out_distances,\n               distances_ptr,\n               distances_size * sizeof(*distances_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48723,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_distances, <size of out_distances>, \n               distances_ptr, \n               distances_size * sizeof(*distances_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0228618e-67ca-3c8c-9643-cfbd42b6b5dc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1505,
                  "startColumn": 8,
                  "endLine": 1505,
                  "endColumn": 68,
                  "charOffset": 48492,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                    "rendered": {
                      "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                      "markdown": "`memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 48492,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_codes, <size of out_codes>,  codes_ptr,  codes_size * sizeof(*codes_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "aa1cab7a-5cd8-3292-9346-03252528663a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 1385,
                  "startColumn": 16,
                  "endLine": 1385,
                  "endColumn": 68,
                  "charOffset": 44706,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                    "rendered": {
                      "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                      "markdown": "`memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 44706,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_codes_i, <size of new_codes_i>,  codes_i + js * m,  sizeof(*codes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3213c710-6b62-300e-8aa2-9c9a98155fa3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 932,
                  "startColumn": 8,
                  "endLine": 934,
                  "endColumn": 57,
                  "charOffset": 29070,
                  "charLength": 117,
                  "snippet": {
                    "text": "memcpy(out_distances,\n               pool.distances.data(),\n               distances_size * sizeof(pool.distances[0])",
                    "rendered": {
                      "text": "memcpy(out_distances,\n               pool.distances.data(),\n               distances_size * sizeof(pool.distances[0])",
                      "markdown": "`memcpy(out_distances,\n               pool.distances.data(),\n               distances_size * sizeof(pool.distances[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29070,
                        "charLength": 117
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_distances, <size of out_distances>, \n               pool.distances.data(), \n               distances_size * sizeof(pool.distances[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "037da8d4-ba58-3c16-8d0a-bdd979bceca8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 924,
                  "startColumn": 8,
                  "endLine": 926,
                  "endColumn": 54,
                  "charOffset": 28793,
                  "charLength": 106,
                  "snippet": {
                    "text": "memcpy(out_residuals,\n               residuals_ptr,\n               residuals_size * sizeof(*residuals_ptr)",
                    "rendered": {
                      "text": "memcpy(out_residuals,\n               residuals_ptr,\n               residuals_size * sizeof(*residuals_ptr)",
                      "markdown": "`memcpy(out_residuals,\n               residuals_ptr,\n               residuals_size * sizeof(*residuals_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28793,
                        "charLength": 106
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_residuals, <size of out_residuals>, \n               residuals_ptr, \n               residuals_size * sizeof(*residuals_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c09f8625-1aec-3f91-afc6-96755c3547fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 918,
                  "startColumn": 8,
                  "endLine": 918,
                  "endColumn": 68,
                  "charOffset": 28562,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                    "rendered": {
                      "text": "memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)",
                      "markdown": "`memcpy(out_codes, codes_ptr, codes_size * sizeof(*codes_ptr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28562,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_codes, <size of out_codes>,  codes_ptr,  codes_size * sizeof(*codes_ptr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "689c600e-ae99-3a4e-a3e5-c898414bc490",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 345,
                  "startColumn": 8,
                  "endLine": 347,
                  "endColumn": 31,
                  "charOffset": 11121,
                  "charLength": 121,
                  "snippet": {
                    "text": "memcpy(this->codebooks.data() + codebook_offsets[m] * d,\n               codebooks.data(),\n               codebooks.size()",
                    "rendered": {
                      "text": "memcpy(this->codebooks.data() + codebook_offsets[m] * d,\n               codebooks.data(),\n               codebooks.size()",
                      "markdown": "`memcpy(this->codebooks.data() + codebook_offsets[m] * d,\n               codebooks.data(),\n               codebooks.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11121,
                        "charLength": 121
                      },
                      "insertedContent": {
                        "text": "memcpy_s(this->codebooks.data() + codebook_offsets[m] * d, <size of this->codebooks.data() + codebook_offsets[m] * d>, \n               codebooks.data(), \n               codebooks.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7de317c0-460f-3b18-acca-8bda9c60e47e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 306,
                  "startColumn": 16,
                  "endLine": 308,
                  "endColumn": 43,
                  "charOffset": 9668,
                  "charLength": 142,
                  "snippet": {
                    "text": "memcpy(residuals1.data() + j * d,\n                       residuals.data() + j * d * cur_beam_size,\n                       sizeof(residuals[0])",
                    "rendered": {
                      "text": "memcpy(residuals1.data() + j * d,\n                       residuals.data() + j * d * cur_beam_size,\n                       sizeof(residuals[0])",
                      "markdown": "`memcpy(residuals1.data() + j * d,\n                       residuals.data() + j * d * cur_beam_size,\n                       sizeof(residuals[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9668,
                        "charLength": 142
                      },
                      "insertedContent": {
                        "text": "memcpy_s(residuals1.data() + j * d, <size of residuals1.data() + j * d>, \n                       residuals.data() + j * d * cur_beam_size, \n                       sizeof(residuals[0])"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "796bc0f1-54c8-3ab2-8ad8-2b8d2364f7bd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 265,
                  "startColumn": 20,
                  "endLine": 265,
                  "endColumn": 72,
                  "charOffset": 8434,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                    "rendered": {
                      "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                      "markdown": "`memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8434,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_codes_i, <size of new_codes_i>,  codes_i + js * m,  sizeof(*codes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e95e1201-8c57-31fa-abb0-725ef3106ca9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 20,
                  "endLine": 211,
                  "endColumn": 72,
                  "charOffset": 6304,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                    "rendered": {
                      "text": "memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)",
                      "markdown": "`memcpy(new_codes_i, codes_i + js * m, sizeof(*codes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6304,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(new_codes_i, <size of new_codes_i>,  codes_i + js * m,  sizeof(*codes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e370e54a-532f-3817-b473-6d750b5cfcbb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 121,
                  "startColumn": 8,
                  "endLine": 123,
                  "endColumn": 31,
                  "charOffset": 2857,
                  "charLength": 132,
                  "snippet": {
                    "text": "memcpy(codebooks.data(),\n               other.codebooks.data() + other.codebook_offsets[skip_M] * d,\n               codebooks.size()",
                    "rendered": {
                      "text": "memcpy(codebooks.data(),\n               other.codebooks.data() + other.codebook_offsets[skip_M] * d,\n               codebooks.size()",
                      "markdown": "`memcpy(codebooks.data(),\n               other.codebooks.data() + other.codebook_offsets[skip_M] * d,\n               codebooks.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2857,
                        "charLength": 132
                      },
                      "insertedContent": {
                        "text": "memcpy_s(codebooks.data(), <size of codebooks.data()>, \n               other.codebooks.data() + other.codebook_offsets[skip_M] * d, \n               codebooks.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0b329990-7068-3021-af51-00a62557defb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ResidualQuantizer.cpp"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 4,
                  "endLine": 113,
                  "endColumn": 23,
                  "charOffset": 2518,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(nbits.data(),\n           other.nbits.data() + skip_M,\n           nbits.size()",
                    "rendered": {
                      "text": "memcpy(nbits.data(),\n           other.nbits.data() + skip_M,\n           nbits.size()",
                      "markdown": "`memcpy(nbits.data(),\n           other.nbits.data() + skip_M,\n           nbits.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ResidualQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2518,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(nbits.data(), <size of nbits.data()>, \n           other.nbits.data() + skip_M, \n           nbits.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "54008130-9785-3b33-bfad-2b305b08fcc7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/Clustering.cpp"
                },
                "region": {
                  "startLine": 628,
                  "startColumn": 8,
                  "endLine": 628,
                  "endColumn": 39,
                  "charOffset": 18842,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(dest, src, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(dest, src, sizeof(float)",
                      "markdown": "`memcpy(dest, src, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/Clustering.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18842,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest, <size of dest>,  src,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8e8f3fd3-dec0-3ef6-9c5c-dac0f8a0b477",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/Clustering.cpp"
                },
                "region": {
                  "startLine": 597,
                  "startColumn": 4,
                  "endLine": 597,
                  "endColumn": 63,
                  "charOffset": 17742,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(centroids, clus.centroids.data(), sizeof(*centroids)",
                    "rendered": {
                      "text": "memcpy(centroids, clus.centroids.data(), sizeof(*centroids)",
                      "markdown": "`memcpy(centroids, clus.centroids.data(), sizeof(*centroids)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/Clustering.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17742,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids, <size of centroids>,  clus.centroids.data(),  sizeof(*centroids)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d61dba31-3363-3bc7-9c98-ac1dfaf756c6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/Clustering.cpp"
                },
                "region": {
                  "startLine": 416,
                  "startColumn": 16,
                  "endLine": 416,
                  "endColumn": 77,
                  "charOffset": 12335,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(&centroids[i * d], x + perm[i] * line_size, line_size)",
                    "rendered": {
                      "text": "memcpy(&centroids[i * d], x + perm[i] * line_size, line_size)",
                      "markdown": "`memcpy(&centroids[i * d], x + perm[i] * line_size, line_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/Clustering.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12335,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&centroids[i * d], <size of &centroids[i * d]>,  x + perm[i] * line_size,  line_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "82530a3e-989d-35fd-95b6-17f7f4673715",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/Clustering.cpp"
                },
                "region": {
                  "startLine": 342,
                  "startColumn": 12,
                  "endLine": 342,
                  "endColumn": 56,
                  "charOffset": 9983,
                  "charLength": 44,
                  "snippet": {
                    "text": "memcpy(centroids.data(), x_in, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(centroids.data(), x_in, sizeof(float)",
                      "markdown": "`memcpy(centroids.data(), x_in, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/Clustering.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9983,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids.data(), <size of centroids.data()>,  x_in,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dc989425-8c7c-3095-8db7-9c50b76f3483",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/Clustering.cpp"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 8,
                  "endLine": 110,
                  "endColumn": 73,
                  "charOffset": 2774,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(x_new + i * line_size, x + perm[i] * line_size, line_size)",
                    "rendered": {
                      "text": "memcpy(x_new + i * line_size, x + perm[i] * line_size, line_size)",
                      "markdown": "`memcpy(x_new + i * line_size, x + perm[i] * line_size, line_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/Clustering.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2774,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x_new + i * line_size, <size of x_new + i * line_size>,  x + perm[i] * line_size,  line_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cda31d14-1b01-313f-bbdc-42c2f4dbb5a6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/Clustering.cpp"
                },
                "region": {
                  "startLine": 242,
                  "startColumn": 12,
                  "endLine": 244,
                  "endColumn": 37,
                  "charOffset": 6897,
                  "charLength": 103,
                  "snippet": {
                    "text": "memcpy(centroids + ci * d,\n                   centroids + cj * d,\n                   sizeof(*centroids)",
                    "rendered": {
                      "text": "memcpy(centroids + ci * d,\n                   centroids + cj * d,\n                   sizeof(*centroids)",
                      "markdown": "`memcpy(centroids + ci * d,\n                   centroids + cj * d,\n                   sizeof(*centroids)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/Clustering.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6897,
                        "charLength": 103
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids + ci * d, <size of centroids + ci * d>, \n                   centroids + cj * d, \n                   sizeof(*centroids)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2b94c2c6-b1be-3564-94e9-f99967b317c9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_sift1M.cpp"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 8,
                  "endLine": 211,
                  "endColumn": 14,
                  "charOffset": 5842,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "595d2e22-8404-3a78-9efe-bcd969df96f9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_sift1M.cpp"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 8,
                  "endLine": 103,
                  "endColumn": 14,
                  "charOffset": 2688,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5889f598-58ef-3ece-885c-6d0bc4695919",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_sift1M.cpp"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 8,
                  "endLine": 60,
                  "endColumn": 15,
                  "charOffset": 1540,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2879a931-9b2f-3f6b-a5d0-17b50a483c90",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_sift1M.cpp"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 14,
                  "endLine": 36,
                  "endColumn": 19,
                  "charOffset": 826,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4d94f2a8-19c7-3ad9-824e-ac45aba262ad",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "c_api/AutoTune_c.cpp"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 8,
                  "endLine": 55,
                  "endColumn": 47,
                  "charOffset": 1544,
                  "charLength": 39,
                  "snippet": {
                    "text": "strncpy(char_buffer, rep.c_str(), size)",
                    "rendered": {
                      "text": "strncpy(char_buffer, rep.c_str(), size)",
                      "markdown": "`strncpy(char_buffer, rep.c_str(), size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "c_api/AutoTune_c.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1544,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s(char_buffer,  size,  rep.c_str())"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "c_api/AutoTune_c.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1544,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy(char_buffer,  rep.c_str(),  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c4b8cb65-7040-32ca-8b1f-b269c41a31fd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_weighted_kmeans.cpp"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 27,
                  "endLine": 128,
                  "endColumn": 31,
                  "charOffset": 3182,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4ab8e6b3-9cfd-37c5-9f7c-8fb7ef5eb6f8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_weighted_kmeans.cpp"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 24,
                  "endLine": 127,
                  "endColumn": 28,
                  "charOffset": 3140,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ef9ecb8b-a49d-3647-9324-be5d800db9ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "demos/demo_weighted_kmeans.cpp"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 4,
                  "endLine": 60,
                  "endColumn": 63,
                  "charOffset": 1457,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(centroids, clus.centroids.data(), sizeof(*centroids)",
                    "rendered": {
                      "text": "memcpy(centroids, clus.centroids.data(), sizeof(*centroids)",
                      "markdown": "`memcpy(centroids, clus.centroids.data(), sizeof(*centroids)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "demos/demo_weighted_kmeans.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1457,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(centroids, <size of centroids>,  clus.centroids.data(),  sizeof(*centroids)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5ea9d47f-64dd-3f55-aa04-e7203db2b072",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ScalarQuantizer.cpp"
                },
                "region": {
                  "startLine": 577,
                  "startColumn": 8,
                  "endLine": 577,
                  "endColumn": 34,
                  "charOffset": 17333,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(vmax, x, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(vmax, x, sizeof(*x)",
                      "markdown": "`memcpy(vmax, x, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ScalarQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17333,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vmax, <size of vmax>,  x,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3bbec019-e182-3e3a-8884-924dd7f0bf62",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ScalarQuantizer.cpp"
                },
                "region": {
                  "startLine": 576,
                  "startColumn": 8,
                  "endLine": 576,
                  "endColumn": 34,
                  "charOffset": 17292,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(vmin, x, sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(vmin, x, sizeof(*x)",
                      "markdown": "`memcpy(vmin, x, sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ScalarQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17292,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(vmin, <size of vmin>,  x,  sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7805de82-ccb9-3258-8dba-b1999b6d2f0f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/ScalarQuantizer.cpp"
                },
                "region": {
                  "startLine": 488,
                  "startColumn": 8,
                  "endLine": 488,
                  "endColumn": 47,
                  "charOffset": 14897,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(x_copy.data(), x, n * sizeof(*x)",
                    "rendered": {
                      "text": "memcpy(x_copy.data(), x, n * sizeof(*x)",
                      "markdown": "`memcpy(x_copy.data(), x, n * sizeof(*x)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/ScalarQuantizer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14897,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(x_copy.data(), <size of x_copy.data()>,  x,  n * sizeof(*x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0470a315-ab4a-3a76-95d4-ba955ab8ab05",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AuxIndexStructures.cpp"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 8,
                  "endLine": 102,
                  "endColumn": 65,
                  "charOffset": 2671,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis)",
                    "rendered": {
                      "text": "memcpy(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis)",
                      "markdown": "`memcpy(dest_dis, buf.dis + ofs, ncopy * sizeof(*dest_dis)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AuxIndexStructures.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2671,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest_dis, <size of dest_dis>,  buf.dis + ofs,  ncopy * sizeof(*dest_dis)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "51c9f610-24b4-3eed-a8b8-2ceab3119963",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/AuxIndexStructures.cpp"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 8,
                  "endLine": 101,
                  "endColumn": 65,
                  "charOffset": 2603,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids)",
                    "rendered": {
                      "text": "memcpy(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids)",
                      "markdown": "`memcpy(dest_ids, buf.ids + ofs, ncopy * sizeof(*dest_ids)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/AuxIndexStructures.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2603,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dest_ids, <size of dest_ids>,  buf.ids + ofs,  ncopy * sizeof(*dest_ids)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1d70bb79-65c8-3ed4-a529-0bda9dbc1673",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/impl/index_read.cpp"
                },
                "region": {
                  "startLine": 750,
                  "startColumn": 16,
                  "endLine": 750,
                  "endColumn": 77,
                  "charOffset": 24070,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(ail->codes[i].data(), vec.data(), ail->codes[i].size()",
                    "rendered": {
                      "text": "memcpy(ail->codes[i].data(), vec.data(), ail->codes[i].size()",
                      "markdown": "`memcpy(ail->codes[i].data(), vec.data(), ail->codes[i].size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "faiss/impl/index_read.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24070,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ail->codes[i].data(), <size of ail->codes[i].data()>,  vec.data(),  ail->codes[i].size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2d27b293-4cc9-3ccb-944a-a5ad56bb7c27",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "faiss/IndexIVFAdditiveQuantizer.cpp"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 12,
                  "endLine": 97,
                  "endColumn": 19,
                  "charOffset": 2928,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}